{"ast":null,"code":"var keys = exports.keys = function (object) {\n  return values(Object.keys(object));\n};\n\nfunction abortCb(cb, abort, onAbort) {\n  cb(abort);\n  onAbort && onAbort(abort === true ? null : abort);\n  return;\n}\n\nvar once = exports.once = function (value, onAbort) {\n  return function (abort, cb) {\n    if (abort) return abortCb(cb, abort, onAbort);\n\n    if (value != null) {\n      var _value = value;\n      value = null;\n      cb(null, _value);\n    } else cb(true);\n  };\n};\n\nvar values = exports.values = exports.readArray = function (array, onAbort) {\n  if (!array) return function (abort, cb) {\n    if (abort) return abortCb(cb, abort, onAbort);\n    return cb(true);\n  };\n  if (!Array.isArray(array)) array = Object.keys(array).map(function (k) {\n    return array[k];\n  });\n  var i = 0;\n  return function (abort, cb) {\n    if (abort) return abortCb(cb, abort, onAbort);\n    cb(i >= array.length || null, array[i++]);\n  };\n};\n\nvar count = exports.count = function (max) {\n  var i = 0;\n  max = max || Infinity;\n  return function (end, cb) {\n    if (end) return cb && cb(end);\n    if (i > max) return cb(true);\n    cb(null, i++);\n  };\n};\n\nvar infinite = exports.infinite = function (generate) {\n  generate = generate || Math.random;\n  return function (end, cb) {\n    if (end) return cb && cb(end);\n    return cb(null, generate());\n  };\n};\n\nvar defer = exports.defer = function () {\n  var _read,\n      cbs = [],\n      _end;\n\n  var read = function (end, cb) {\n    if (!_read) {\n      _end = end;\n      cbs.push(cb);\n    } else _read(end, cb);\n  };\n\n  read.resolve = function (read) {\n    if (_read) throw new Error('already resolved');\n    _read = read;\n    if (!_read) throw new Error('no read cannot resolve!' + _read);\n\n    while (cbs.length) _read(_end, cbs.shift());\n  };\n\n  read.abort = function (err) {\n    read.resolve(function (_, cb) {\n      cb(err || true);\n    });\n  };\n\n  return read;\n};\n\nvar empty = exports.empty = function () {\n  return function (abort, cb) {\n    cb(true);\n  };\n};\n\nvar error = exports.error = function (err) {\n  return function (abort, cb) {\n    cb(err);\n  };\n};\n\nvar depthFirst = exports.depthFirst = function (start, createStream) {\n  var reads = [];\n  reads.unshift(once(start));\n  return function next(end, cb) {\n    if (!reads.length) return cb(true);\n    reads[0](end, function (end, data) {\n      if (end) {\n        //if this stream has ended, go to the next queue\n        reads.shift();\n        return next(null, cb);\n      }\n\n      reads.unshift(createStream(data));\n      cb(end, data);\n    });\n  };\n}; //width first is just like depth first,\n//but push each new stream onto the end of the queue\n\n\nvar widthFirst = exports.widthFirst = function (start, createStream) {\n  var reads = [];\n  reads.push(once(start));\n  return function next(end, cb) {\n    if (!reads.length) return cb(true);\n    reads[0](end, function (end, data) {\n      if (end) {\n        reads.shift();\n        return next(null, cb);\n      }\n\n      reads.push(createStream(data));\n      cb(end, data);\n    });\n  };\n}; //this came out different to the first (strm)\n//attempt at leafFirst, but it's still a valid\n//topological sort.\n\n\nvar leafFirst = exports.leafFirst = function (start, createStream) {\n  var reads = [];\n  var output = [];\n  reads.push(once(start));\n  return function next(end, cb) {\n    reads[0](end, function (end, data) {\n      if (end) {\n        reads.shift();\n        if (!output.length) return cb(true);\n        return cb(null, output.shift());\n      }\n\n      reads.unshift(createStream(data));\n      output.unshift(data);\n      next(null, cb);\n    });\n  };\n};","map":null,"metadata":{},"sourceType":"script"}