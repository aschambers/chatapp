{"ast":null,"code":"var common = require('./common.js');\n\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar IIISideInfo = require('./IIISideInfo.js');\n\nvar ScaleFac = require('./ScaleFac.js');\n\nvar NsPsy = require('./NsPsy.js');\n\nvar VBRSeekInfo = require('./VBRSeekInfo.js');\n\nvar III_psy_xmin = require('./III_psy_xmin.js');\n\nvar Encoder = require('./Encoder.js');\n\nvar L3Side = require('./L3Side.js');\n\nLameInternalFlags.MFSIZE = 3 * 1152 + Encoder.ENCDELAY - Encoder.MDCTDELAY;\nLameInternalFlags.MAX_HEADER_BUF = 256;\nLameInternalFlags.MAX_BITS_PER_CHANNEL = 4095;\nLameInternalFlags.MAX_BITS_PER_GRANULE = 7680;\nLameInternalFlags.BPC = 320;\n\nfunction LameInternalFlags() {\n  var MAX_HEADER_LEN = 40;\n  /********************************************************************\n   * internal variables NOT set by calling program, and should not be *\n   * modified by the calling program *\n   ********************************************************************/\n\n  /**\n   * Some remarks to the Class_ID field: The Class ID is an Identifier for a\n   * pointer to this struct. It is very unlikely that a pointer to\n   * lame_global_flags has the same 32 bits in it's structure (large and other\n   * special properties, for instance prime).\n   *\n   * To test that the structure is right and initialized, use: if ( gfc .\n   * Class_ID == LAME_ID ) ... Other remark: If you set a flag to 0 for uninit\n   * data and 1 for init data, the right test should be \"if (flag == 1)\" and\n   * NOT \"if (flag)\". Unintended modification of this element will be\n   * otherwise misinterpreted as an init.\n   */\n\n  this.Class_ID = 0;\n  this.lame_encode_frame_init = 0;\n  this.iteration_init_init = 0;\n  this.fill_buffer_resample_init = 0; //public float mfbuf[][] = new float[2][MFSIZE];\n\n  this.mfbuf = new_float_n([2, LameInternalFlags.MFSIZE]);\n  /**\n   * granules per frame\n   */\n\n  this.mode_gr = 0;\n  /**\n   * number of channels in the input data stream (PCM or decoded PCM)\n   */\n\n  this.channels_in = 0;\n  /**\n   * number of channels in the output data stream (not used for decoding)\n   */\n\n  this.channels_out = 0;\n  /**\n   * input_samp_rate/output_samp_rate\n   */\n  //public double resample_ratio;\n\n  this.resample_ratio = 0.;\n  this.mf_samples_to_encode = 0;\n  this.mf_size = 0;\n  /**\n   * min bitrate index\n   */\n\n  this.VBR_min_bitrate = 0;\n  /**\n   * max bitrate index\n   */\n\n  this.VBR_max_bitrate = 0;\n  this.bitrate_index = 0;\n  this.samplerate_index = 0;\n  this.mode_ext = 0;\n  /* lowpass and highpass filter control */\n\n  /**\n   * normalized frequency bounds of passband\n   */\n\n  this.lowpass1 = 0.;\n  this.lowpass2 = 0.;\n  /**\n   * normalized frequency bounds of passband\n   */\n\n  this.highpass1 = 0.;\n  this.highpass2 = 0.;\n  /**\n   * 0 = none 1 = ISO AAC model 2 = allow scalefac_select=1\n   */\n\n  this.noise_shaping = 0;\n  /**\n   * 0 = ISO model: amplify all distorted bands<BR>\n   * 1 = amplify within 50% of max (on db scale)<BR>\n   * 2 = amplify only most distorted band<BR>\n   * 3 = method 1 and refine with method 2<BR>\n   */\n\n  this.noise_shaping_amp = 0;\n  /**\n   * 0 = no substep<BR>\n   * 1 = use substep shaping at last step(VBR only)<BR>\n   * (not implemented yet)<BR>\n   * 2 = use substep inside loop<BR>\n   * 3 = use substep inside loop and last step<BR>\n   */\n\n  this.substep_shaping = 0;\n  /**\n   * 1 = gpsycho. 0 = none\n   */\n\n  this.psymodel = 0;\n  /**\n   * 0 = stop at over=0, all scalefacs amplified or<BR>\n   * a scalefac has reached max value<BR>\n   * 1 = stop when all scalefacs amplified or a scalefac has reached max value<BR>\n   * 2 = stop when all scalefacs amplified\n   */\n\n  this.noise_shaping_stop = 0;\n  /**\n   * 0 = no, 1 = yes\n   */\n\n  this.subblock_gain = 0;\n  /**\n   * 0 = no. 1=outside loop 2=inside loop(slow)\n   */\n\n  this.use_best_huffman = 0;\n  /**\n   * 0 = stop early after 0 distortion found. 1 = full search\n   */\n\n  this.full_outer_loop = 0; //public IIISideInfo l3_side = new IIISideInfo();\n\n  this.l3_side = new IIISideInfo();\n  this.ms_ratio = new_float(2);\n  /* used for padding */\n\n  /**\n   * padding for the current frame?\n   */\n\n  this.padding = 0;\n  this.frac_SpF = 0;\n  this.slot_lag = 0;\n  /**\n   * optional ID3 tags\n   */\n  //public ID3TagSpec tag_spec;\n\n  this.tag_spec = null;\n  this.nMusicCRC = 0;\n  /* variables used by Quantize */\n  //public int OldValue[] = new int[2];\n\n  this.OldValue = new_int(2); //public int CurrentStep[] = new int[2];\n\n  this.CurrentStep = new_int(2);\n  this.masking_lower = 0.; //public int bv_scf[] = new int[576];\n\n  this.bv_scf = new_int(576); //public int pseudohalf[] = new int[L3Side.SFBMAX];\n\n  this.pseudohalf = new_int(L3Side.SFBMAX);\n  /**\n   * will be set in lame_init_params\n   */\n\n  this.sfb21_extra = false;\n  /* BPC = maximum number of filter convolution windows to precompute */\n  //public float[][] inbuf_old = new float[2][];\n\n  this.inbuf_old = new Array(2); //public float[][] blackfilt = new float[2 * BPC + 1][];\n\n  this.blackfilt = new Array(2 * LameInternalFlags.BPC + 1); //public double itime[] = new double[2];\n\n  this.itime = new_double(2);\n  this.sideinfo_len = 0;\n  /* variables for newmdct.c */\n  //public float sb_sample[][][][] = new float[2][2][18][Encoder.SBLIMIT];\n\n  this.sb_sample = new_float_n([2, 2, 18, Encoder.SBLIMIT]);\n  this.amp_filter = new_float(32);\n  /* variables for BitStream */\n\n  /**\n   * <PRE>\n   * mpeg1: buffer=511 bytes  smallest frame: 96-38(sideinfo)=58\n   * max number of frames in reservoir:  8\n   * mpeg2: buffer=255 bytes.  smallest frame: 24-23bytes=1\n   * with VBR, if you are encoding all silence, it is possible to\n   * have 8kbs/24khz frames with 1byte of data each, which means we need\n   * to buffer up to 255 headers!\n   * </PRE>\n   */\n\n  /**\n   * also, max_header_buf has to be a power of two\n   */\n\n  /**\n   * max size of header is 38\n   */\n\n  function Header() {\n    this.write_timing = 0;\n    this.ptr = 0; //public byte buf[] = new byte[MAX_HEADER_LEN];\n\n    this.buf = new_byte(MAX_HEADER_LEN);\n  }\n\n  this.header = new Array(LameInternalFlags.MAX_HEADER_BUF);\n  this.h_ptr = 0;\n  this.w_ptr = 0;\n  this.ancillary_flag = 0;\n  /* variables for Reservoir */\n\n  /**\n   * in bits\n   */\n\n  this.ResvSize = 0;\n  /**\n   * in bits\n   */\n\n  this.ResvMax = 0; //public ScaleFac scalefac_band = new ScaleFac();\n\n  this.scalefac_band = new ScaleFac();\n  /* daa from PsyModel */\n\n  /* The static variables \"r\", \"phi_sav\", \"new\", \"old\" and \"oldest\" have */\n\n  /* to be remembered for the unpredictability measure. For \"r\" and */\n\n  /* \"phi_sav\", the first index from the left is the channel select and */\n\n  /* the second index is the \"age\" of the data. */\n\n  this.minval_l = new_float(Encoder.CBANDS);\n  this.minval_s = new_float(Encoder.CBANDS);\n  this.nb_1 = new_float_n([4, Encoder.CBANDS]);\n  this.nb_2 = new_float_n([4, Encoder.CBANDS]);\n  this.nb_s1 = new_float_n([4, Encoder.CBANDS]);\n  this.nb_s2 = new_float_n([4, Encoder.CBANDS]);\n  this.s3_ss = null;\n  this.s3_ll = null;\n  this.decay = 0.; //public III_psy_xmin[] thm = new III_psy_xmin[4];\n  //public III_psy_xmin[] en = new III_psy_xmin[4];\n\n  this.thm = new Array(4);\n  this.en = new Array(4);\n  /**\n   * fft and energy calculation\n   */\n\n  this.tot_ener = new_float(4);\n  /* loudness calculation (for adaptive threshold of hearing) */\n\n  /**\n   * loudness^2 approx. per granule and channel\n   */\n\n  this.loudness_sq = new_float_n([2, 2]);\n  /**\n   * account for granule delay of L3psycho_anal\n   */\n\n  this.loudness_sq_save = new_float(2);\n  /**\n   * Scale Factor Bands\n   */\n\n  this.mld_l = new_float(Encoder.SBMAX_l);\n  this.mld_s = new_float(Encoder.SBMAX_s);\n  this.bm_l = new_int(Encoder.SBMAX_l);\n  this.bo_l = new_int(Encoder.SBMAX_l);\n  this.bm_s = new_int(Encoder.SBMAX_s);\n  this.bo_s = new_int(Encoder.SBMAX_s);\n  this.npart_l = 0;\n  this.npart_s = 0;\n  this.s3ind = new_int_n([Encoder.CBANDS, 2]);\n  this.s3ind_s = new_int_n([Encoder.CBANDS, 2]);\n  this.numlines_s = new_int(Encoder.CBANDS);\n  this.numlines_l = new_int(Encoder.CBANDS);\n  this.rnumlines_l = new_float(Encoder.CBANDS);\n  this.mld_cb_l = new_float(Encoder.CBANDS);\n  this.mld_cb_s = new_float(Encoder.CBANDS);\n  this.numlines_s_num1 = 0;\n  this.numlines_l_num1 = 0;\n  /* ratios */\n\n  this.pe = new_float(4);\n  this.ms_ratio_s_old = 0.;\n  this.ms_ratio_l_old = 0.;\n  this.ms_ener_ratio_old = 0.;\n  /**\n   * block type\n   */\n\n  this.blocktype_old = new_int(2);\n  /**\n   * variables used for --nspsytune\n   */\n\n  this.nsPsy = new NsPsy();\n  /**\n   * used for Xing VBR header\n   */\n\n  this.VBR_seek_table = new VBRSeekInfo();\n  /**\n   * all ATH related stuff\n   */\n  //public ATH ATH;\n\n  this.ATH = null;\n  this.PSY = null;\n  this.nogap_total = 0;\n  this.nogap_current = 0;\n  /* ReplayGain */\n\n  this.decode_on_the_fly = true;\n  this.findReplayGain = true;\n  this.findPeakSample = true;\n  this.PeakSample = 0.;\n  this.RadioGain = 0;\n  this.AudiophileGain = 0; //public ReplayGain rgdata;\n\n  this.rgdata = null;\n  /**\n   * gain change required for preventing clipping\n   */\n\n  this.noclipGainChange = 0;\n  /**\n   * user-specified scale factor required for preventing clipping\n   */\n\n  this.noclipScale = 0.;\n  /* simple statistics */\n\n  this.bitrate_stereoMode_Hist = new_int_n([16, 4 + 1]);\n  /**\n   * norm/start/short/stop/mixed(short)/sum\n   */\n\n  this.bitrate_blockType_Hist = new_int_n([16, 4 + 1 + 1]); //public PlottingData pinfo;\n  //public MPGLib.mpstr_tag hip;\n\n  this.pinfo = null;\n  this.hip = null;\n  this.in_buffer_nsamples = 0; //public float[] in_buffer_0;\n  //public float[] in_buffer_1;\n\n  this.in_buffer_0 = null;\n  this.in_buffer_1 = null; //public IIterationLoop iteration_loop;\n\n  this.iteration_loop = null;\n\n  for (var i = 0; i < this.en.length; i++) {\n    this.en[i] = new III_psy_xmin();\n  }\n\n  for (var i = 0; i < this.thm.length; i++) {\n    this.thm[i] = new III_psy_xmin();\n  }\n\n  for (var i = 0; i < this.header.length; i++) {\n    this.header[i] = new Header();\n  }\n}\n\nmodule.exports = LameInternalFlags;","map":null,"metadata":{},"sourceType":"script"}