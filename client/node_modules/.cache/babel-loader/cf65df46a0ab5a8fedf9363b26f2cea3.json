{"ast":null,"code":"/*\n * MP3 quantization\n *\n *      Copyright (c) 1999-2000 Mark Taylor\n *      Copyright (c) 1999-2003 Takehiro Tominaga\n *      Copyright (c) 2000-2007 Robert Hegemann\n *      Copyright (c) 2001-2005 Gabriel Bouvigne\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.     See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: Quantize.java,v 1.24 2011/05/24 20:48:06 kenchis Exp $ */\n//package mp3;\n//import java.util.Arrays;\nvar common = require('./common.js');\n\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar VBRQuantize = require('./VBRQuantize.js');\n\nvar CalcNoiseResult = require('./CalcNoiseResult.js');\n\nvar CalcNoiseData = require('./CalcNoiseData.js');\n\nvar Encoder = require('./Encoder.js');\n\nvar GrInfo = require('./GrInfo.js');\n\nvar L3Side = require('./L3Side.js');\n\nfunction Quantize() {\n  var bs;\n  this.rv = null;\n  var rv;\n  this.qupvt = null;\n  var qupvt;\n  var vbr = new VBRQuantize();\n  var tk;\n\n  this.setModules = function (_bs, _rv, _qupvt, _tk) {\n    bs = _bs;\n    rv = _rv;\n    this.rv = _rv;\n    qupvt = _qupvt;\n    this.qupvt = _qupvt;\n    tk = _tk;\n    vbr.setModules(qupvt, tk);\n  };\n  /**\n   * convert from L/R <. Mid/Side\n   */\n\n\n  this.ms_convert = function (l3_side, gr) {\n    for (var i = 0; i < 576; ++i) {\n      var l = l3_side.tt[gr][0].xr[i];\n      var r = l3_side.tt[gr][1].xr[i];\n      l3_side.tt[gr][0].xr[i] = (l + r) * (Util.SQRT2 * 0.5);\n      l3_side.tt[gr][1].xr[i] = (l - r) * (Util.SQRT2 * 0.5);\n    }\n  };\n  /**\n   * mt 6/99\n   *\n   * initializes cod_info, scalefac and xrpow\n   *\n   * returns 0 if all energies in xr are zero, else 1\n   */\n\n\n  function init_xrpow_core(cod_info, xrpow, upper, sum) {\n    sum = 0;\n\n    for (var i = 0; i <= upper; ++i) {\n      var tmp = Math.abs(cod_info.xr[i]);\n      sum += tmp;\n      xrpow[i] = Math.sqrt(tmp * Math.sqrt(tmp));\n      if (xrpow[i] > cod_info.xrpow_max) cod_info.xrpow_max = xrpow[i];\n    }\n\n    return sum;\n  }\n\n  this.init_xrpow = function (gfc, cod_info, xrpow) {\n    var sum = 0;\n    var upper = 0 | cod_info.max_nonzero_coeff;\n    assert(xrpow != null);\n    cod_info.xrpow_max = 0;\n    /*\n     * check if there is some energy we have to quantize and calculate xrpow\n     * matching our fresh scalefactors\n     */\n\n    assert(0 <= upper && upper <= 575);\n    Arrays.fill(xrpow, upper, 576, 0);\n    sum = init_xrpow_core(cod_info, xrpow, upper, sum);\n    /*\n     * return 1 if we have something to quantize, else 0\n     */\n\n    if (sum > 1E-20) {\n      var j = 0;\n      if ((gfc.substep_shaping & 2) != 0) j = 1;\n\n      for (var i = 0; i < cod_info.psymax; i++) gfc.pseudohalf[i] = j;\n\n      return true;\n    }\n\n    Arrays.fill(cod_info.l3_enc, 0, 576, 0);\n    return false;\n  };\n  /**\n   * Gabriel Bouvigne feb/apr 2003<BR>\n   * Analog silence detection in partitionned sfb21 or sfb12 for short blocks\n   *\n   * From top to bottom of sfb, changes to 0 coeffs which are below ath. It\n   * stops on the first coeff higher than ath.\n   */\n\n\n  function psfb21_analogsilence(gfc, cod_info) {\n    var ath = gfc.ATH;\n    var xr = cod_info.xr;\n\n    if (cod_info.block_type != Encoder.SHORT_TYPE) {\n      /* NORM, START or STOP type, but not SHORT blocks */\n      var stop = false;\n\n      for (var gsfb = Encoder.PSFB21 - 1; gsfb >= 0 && !stop; gsfb--) {\n        var start = gfc.scalefac_band.psfb21[gsfb];\n        var end = gfc.scalefac_band.psfb21[gsfb + 1];\n        var ath21 = qupvt.athAdjust(ath.adjust, ath.psfb21[gsfb], ath.floor);\n        if (gfc.nsPsy.longfact[21] > 1e-12) ath21 *= gfc.nsPsy.longfact[21];\n\n        for (var j = end - 1; j >= start; j--) {\n          if (Math.abs(xr[j]) < ath21) xr[j] = 0;else {\n            stop = true;\n            break;\n          }\n        }\n      }\n    } else {\n      /* note: short blocks coeffs are reordered */\n      for (var block = 0; block < 3; block++) {\n        var stop = false;\n\n        for (var gsfb = Encoder.PSFB12 - 1; gsfb >= 0 && !stop; gsfb--) {\n          var start = gfc.scalefac_band.s[12] * 3 + (gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12]) * block + (gfc.scalefac_band.psfb12[gsfb] - gfc.scalefac_band.psfb12[0]);\n          var end = start + (gfc.scalefac_band.psfb12[gsfb + 1] - gfc.scalefac_band.psfb12[gsfb]);\n          var ath12 = qupvt.athAdjust(ath.adjust, ath.psfb12[gsfb], ath.floor);\n          if (gfc.nsPsy.shortfact[12] > 1e-12) ath12 *= gfc.nsPsy.shortfact[12];\n\n          for (var j = end - 1; j >= start; j--) {\n            if (Math.abs(xr[j]) < ath12) xr[j] = 0;else {\n              stop = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  this.init_outer_loop = function (gfc, cod_info) {\n    /*\n     * initialize fresh cod_info\n     */\n    cod_info.part2_3_length = 0;\n    cod_info.big_values = 0;\n    cod_info.count1 = 0;\n    cod_info.global_gain = 210;\n    cod_info.scalefac_compress = 0;\n    /* mixed_block_flag, block_type was set in psymodel.c */\n\n    cod_info.table_select[0] = 0;\n    cod_info.table_select[1] = 0;\n    cod_info.table_select[2] = 0;\n    cod_info.subblock_gain[0] = 0;\n    cod_info.subblock_gain[1] = 0;\n    cod_info.subblock_gain[2] = 0;\n    cod_info.subblock_gain[3] = 0;\n    /* this one is always 0 */\n\n    cod_info.region0_count = 0;\n    cod_info.region1_count = 0;\n    cod_info.preflag = 0;\n    cod_info.scalefac_scale = 0;\n    cod_info.count1table_select = 0;\n    cod_info.part2_length = 0;\n    cod_info.sfb_lmax = Encoder.SBPSY_l;\n    cod_info.sfb_smin = Encoder.SBPSY_s;\n    cod_info.psy_lmax = gfc.sfb21_extra ? Encoder.SBMAX_l : Encoder.SBPSY_l;\n    cod_info.psymax = cod_info.psy_lmax;\n    cod_info.sfbmax = cod_info.sfb_lmax;\n    cod_info.sfbdivide = 11;\n\n    for (var sfb = 0; sfb < Encoder.SBMAX_l; sfb++) {\n      cod_info.width[sfb] = gfc.scalefac_band.l[sfb + 1] - gfc.scalefac_band.l[sfb];\n      /* which is always 0. */\n\n      cod_info.window[sfb] = 3;\n    }\n\n    if (cod_info.block_type == Encoder.SHORT_TYPE) {\n      var ixwork = new_float(576);\n      cod_info.sfb_smin = 0;\n      cod_info.sfb_lmax = 0;\n\n      if (cod_info.mixed_block_flag != 0) {\n        /*\n         * MPEG-1: sfbs 0-7 long block, 3-12 short blocks MPEG-2(.5):\n         * sfbs 0-5 long block, 3-12 short blocks\n         */\n        cod_info.sfb_smin = 3;\n        cod_info.sfb_lmax = gfc.mode_gr * 2 + 4;\n      }\n\n      cod_info.psymax = cod_info.sfb_lmax + 3 * ((gfc.sfb21_extra ? Encoder.SBMAX_s : Encoder.SBPSY_s) - cod_info.sfb_smin);\n      cod_info.sfbmax = cod_info.sfb_lmax + 3 * (Encoder.SBPSY_s - cod_info.sfb_smin);\n      cod_info.sfbdivide = cod_info.sfbmax - 18;\n      cod_info.psy_lmax = cod_info.sfb_lmax;\n      /* re-order the short blocks, for more efficient encoding below */\n\n      /* By Takehiro TOMINAGA */\n\n      /*\n       * Within each scalefactor band, data is given for successive time\n       * windows, beginning with window 0 and ending with window 2. Within\n       * each window, the quantized values are then arranged in order of\n       * increasing frequency...\n       */\n\n      var ix = gfc.scalefac_band.l[cod_info.sfb_lmax];\n      System.arraycopy(cod_info.xr, 0, ixwork, 0, 576);\n\n      for (var sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n        var start = gfc.scalefac_band.s[sfb];\n        var end = gfc.scalefac_band.s[sfb + 1];\n\n        for (var window = 0; window < 3; window++) {\n          for (var l = start; l < end; l++) {\n            cod_info.xr[ix++] = ixwork[3 * l + window];\n          }\n        }\n      }\n\n      var j = cod_info.sfb_lmax;\n\n      for (var sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n        cod_info.width[j] = cod_info.width[j + 1] = cod_info.width[j + 2] = gfc.scalefac_band.s[sfb + 1] - gfc.scalefac_band.s[sfb];\n        cod_info.window[j] = 0;\n        cod_info.window[j + 1] = 1;\n        cod_info.window[j + 2] = 2;\n        j += 3;\n      }\n    }\n\n    cod_info.count1bits = 0;\n    cod_info.sfb_partition_table = qupvt.nr_of_sfb_block[0][0];\n    cod_info.slen[0] = 0;\n    cod_info.slen[1] = 0;\n    cod_info.slen[2] = 0;\n    cod_info.slen[3] = 0;\n    cod_info.max_nonzero_coeff = 575;\n    /*\n     * fresh scalefactors are all zero\n     */\n\n    Arrays.fill(cod_info.scalefac, 0);\n    psfb21_analogsilence(gfc, cod_info);\n  };\n\n  function BinSearchDirection(ordinal) {\n    this.ordinal = ordinal;\n  }\n\n  BinSearchDirection.BINSEARCH_NONE = new BinSearchDirection(0);\n  BinSearchDirection.BINSEARCH_UP = new BinSearchDirection(1);\n  BinSearchDirection.BINSEARCH_DOWN = new BinSearchDirection(2);\n  /**\n   * author/date??\n   *\n   * binary step size search used by outer_loop to get a quantizer step size\n   * to start with\n   */\n\n  function bin_search_StepSize(gfc, cod_info, desired_rate, ch, xrpow) {\n    var nBits;\n    var CurrentStep = gfc.CurrentStep[ch];\n    var flagGoneOver = false;\n    var start = gfc.OldValue[ch];\n    var Direction = BinSearchDirection.BINSEARCH_NONE;\n    cod_info.global_gain = start;\n    desired_rate -= cod_info.part2_length;\n    assert(CurrentStep != 0);\n\n    for (;;) {\n      var step;\n      nBits = tk.count_bits(gfc, xrpow, cod_info, null);\n      if (CurrentStep == 1 || nBits == desired_rate) break;\n      /* nothing to adjust anymore */\n\n      if (nBits > desired_rate) {\n        /* increase Quantize_StepSize */\n        if (Direction == BinSearchDirection.BINSEARCH_DOWN) flagGoneOver = true;\n        if (flagGoneOver) CurrentStep /= 2;\n        Direction = BinSearchDirection.BINSEARCH_UP;\n        step = CurrentStep;\n      } else {\n        /* decrease Quantize_StepSize */\n        if (Direction == BinSearchDirection.BINSEARCH_UP) flagGoneOver = true;\n        if (flagGoneOver) CurrentStep /= 2;\n        Direction = BinSearchDirection.BINSEARCH_DOWN;\n        step = -CurrentStep;\n      }\n\n      cod_info.global_gain += step;\n\n      if (cod_info.global_gain < 0) {\n        cod_info.global_gain = 0;\n        flagGoneOver = true;\n      }\n\n      if (cod_info.global_gain > 255) {\n        cod_info.global_gain = 255;\n        flagGoneOver = true;\n      }\n    }\n\n    assert(cod_info.global_gain >= 0);\n    assert(cod_info.global_gain < 256);\n\n    while (nBits > desired_rate && cod_info.global_gain < 255) {\n      cod_info.global_gain++;\n      nBits = tk.count_bits(gfc, xrpow, cod_info, null);\n    }\n\n    gfc.CurrentStep[ch] = start - cod_info.global_gain >= 4 ? 4 : 2;\n    gfc.OldValue[ch] = cod_info.global_gain;\n    cod_info.part2_3_length = nBits;\n    return nBits;\n  }\n\n  this.trancate_smallspectrums = function (gfc, gi, l3_xmin, work) {\n    var distort = new_float(L3Side.SFBMAX);\n    if (0 == (gfc.substep_shaping & 4) && gi.block_type == Encoder.SHORT_TYPE || (gfc.substep_shaping & 0x80) != 0) return;\n    qupvt.calc_noise(gi, l3_xmin, distort, new CalcNoiseResult(), null);\n\n    for (var j = 0; j < 576; j++) {\n      var xr = 0.0;\n      if (gi.l3_enc[j] != 0) xr = Math.abs(gi.xr[j]);\n      work[j] = xr;\n    }\n\n    var j = 0;\n    var sfb = 8;\n    if (gi.block_type == Encoder.SHORT_TYPE) sfb = 6;\n\n    do {\n      var allowedNoise, trancateThreshold;\n      var nsame, start;\n      var width = gi.width[sfb];\n      j += width;\n      if (distort[sfb] >= 1.0) continue;\n      Arrays.sort(work, j - width, width);\n      if (BitStream.EQ(work[j - 1], 0.0)) continue;\n      /* all zero sfb */\n\n      allowedNoise = (1.0 - distort[sfb]) * l3_xmin[sfb];\n      trancateThreshold = 0.0;\n      start = 0;\n\n      do {\n        var noise;\n\n        for (nsame = 1; start + nsame < width; nsame++) if (BitStream.NEQ(work[start + j - width], work[start + j + nsame - width])) break;\n\n        noise = work[start + j - width] * work[start + j - width] * nsame;\n\n        if (allowedNoise < noise) {\n          if (start != 0) trancateThreshold = work[start + j - width - 1];\n          break;\n        }\n\n        allowedNoise -= noise;\n        start += nsame;\n      } while (start < width);\n\n      if (BitStream.EQ(trancateThreshold, 0.0)) continue;\n\n      do {\n        if (Math.abs(gi.xr[j - width]) <= trancateThreshold) gi.l3_enc[j - width] = 0;\n      } while (--width > 0);\n    } while (++sfb < gi.psymax);\n\n    gi.part2_3_length = tk.noquant_count_bits(gfc, gi, null);\n  };\n  /**\n   * author/date??\n   *\n   * Function: Returns zero if there is a scalefac which has not been\n   * amplified. Otherwise it returns one.\n   */\n\n\n  function loop_break(cod_info) {\n    for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) if (cod_info.scalefac[sfb] + cod_info.subblock_gain[cod_info.window[sfb]] == 0) return false;\n\n    return true;\n  }\n  /* mt 5/99: Function: Improved calc_noise for a single channel */\n\n\n  function penalties(noise) {\n    return Util.FAST_LOG10(0.368 + 0.632 * noise * noise * noise);\n  }\n  /**\n   * author/date??\n   *\n   * several different codes to decide which quantization is better\n   */\n\n\n  function get_klemm_noise(distort, gi) {\n    var klemm_noise = 1E-37;\n\n    for (var sfb = 0; sfb < gi.psymax; sfb++) klemm_noise += penalties(distort[sfb]);\n\n    return Math.max(1e-20, klemm_noise);\n  }\n\n  function quant_compare(quant_comp, best, calc, gi, distort) {\n    /**\n     * noise is given in decibels (dB) relative to masking thesholds.<BR>\n     *\n     * over_noise: ??? (the previous comment is fully wrong)<BR>\n     * tot_noise: ??? (the previous comment is fully wrong)<BR>\n     * max_noise: max quantization noise\n     */\n    var better;\n\n    switch (quant_comp) {\n      default:\n      case 9:\n        {\n          if (best.over_count > 0) {\n            /* there are distorted sfb */\n            better = calc.over_SSD <= best.over_SSD;\n            if (calc.over_SSD == best.over_SSD) better = calc.bits < best.bits;\n          } else {\n            /* no distorted sfb */\n            better = calc.max_noise < 0 && calc.max_noise * 10 + calc.bits <= best.max_noise * 10 + best.bits;\n          }\n\n          break;\n        }\n\n      case 0:\n        better = calc.over_count < best.over_count || calc.over_count == best.over_count && calc.over_noise < best.over_noise || calc.over_count == best.over_count && BitStream.EQ(calc.over_noise, best.over_noise) && calc.tot_noise < best.tot_noise;\n        break;\n\n      case 8:\n        calc.max_noise = get_klemm_noise(distort, gi);\n      //$FALL-THROUGH$\n\n      case 1:\n        better = calc.max_noise < best.max_noise;\n        break;\n\n      case 2:\n        better = calc.tot_noise < best.tot_noise;\n        break;\n\n      case 3:\n        better = calc.tot_noise < best.tot_noise && calc.max_noise < best.max_noise;\n        break;\n\n      case 4:\n        better = calc.max_noise <= 0.0 && best.max_noise > 0.2 || calc.max_noise <= 0.0 && best.max_noise < 0.0 && best.max_noise > calc.max_noise - 0.2 && calc.tot_noise < best.tot_noise || calc.max_noise <= 0.0 && best.max_noise > 0.0 && best.max_noise > calc.max_noise - 0.2 && calc.tot_noise < best.tot_noise + best.over_noise || calc.max_noise > 0.0 && best.max_noise > -0.05 && best.max_noise > calc.max_noise - 0.1 && calc.tot_noise + calc.over_noise < best.tot_noise + best.over_noise || calc.max_noise > 0.0 && best.max_noise > -0.1 && best.max_noise > calc.max_noise - 0.15 && calc.tot_noise + calc.over_noise + calc.over_noise < best.tot_noise + best.over_noise + best.over_noise;\n        break;\n\n      case 5:\n        better = calc.over_noise < best.over_noise || BitStream.EQ(calc.over_noise, best.over_noise) && calc.tot_noise < best.tot_noise;\n        break;\n\n      case 6:\n        better = calc.over_noise < best.over_noise || BitStream.EQ(calc.over_noise, best.over_noise) && (calc.max_noise < best.max_noise || BitStream.EQ(calc.max_noise, best.max_noise) && calc.tot_noise <= best.tot_noise);\n        break;\n\n      case 7:\n        better = calc.over_count < best.over_count || calc.over_noise < best.over_noise;\n        break;\n    }\n\n    if (best.over_count == 0) {\n      /*\n       * If no distorted bands, only use this quantization if it is\n       * better, and if it uses less bits. Unfortunately, part2_3_length\n       * is sometimes a poor estimator of the final size at low bitrates.\n       */\n      better = better && calc.bits < best.bits;\n    }\n\n    return better;\n  }\n  /**\n   * author/date??\n   *\n   * <PRE>\n   *  Amplify the scalefactor bands that violate the masking threshold.\n   *  See ISO 11172-3 Section C.1.5.4.3.5\n   *\n   *  distort[] = noise/masking\n   *  distort[] > 1   ==> noise is not masked\n   *  distort[] < 1   ==> noise is masked\n   *  max_dist = maximum value of distort[]\n   *\n   *  Three algorithms:\n   *  noise_shaping_amp\n   *        0             Amplify all bands with distort[]>1.\n   *\n   *        1             Amplify all bands with distort[] >= max_dist^(.5);\n   *                     ( 50% in the db scale)\n   *\n   *        2             Amplify first band with distort[] >= max_dist;\n   *\n   *\n   *  For algorithms 0 and 1, if max_dist < 1, then amplify all bands\n   *  with distort[] >= .95*max_dist.  This is to make sure we always\n   *  amplify at least one band.\n   * </PRE>\n   */\n\n\n  function amp_scalefac_bands(gfp, cod_info, distort, xrpow, bRefine) {\n    var gfc = gfp.internal_flags;\n    var ifqstep34;\n\n    if (cod_info.scalefac_scale == 0) {\n      ifqstep34 = 1.29683955465100964055;\n      /* 2**(.75*.5) */\n    } else {\n      ifqstep34 = 1.68179283050742922612;\n      /* 2**(.75*1) */\n    }\n    /* compute maximum value of distort[] */\n\n\n    var trigger = 0;\n\n    for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n      if (trigger < distort[sfb]) trigger = distort[sfb];\n    }\n\n    var noise_shaping_amp = gfc.noise_shaping_amp;\n\n    if (noise_shaping_amp == 3) {\n      if (bRefine) noise_shaping_amp = 2;else noise_shaping_amp = 1;\n    }\n\n    switch (noise_shaping_amp) {\n      case 2:\n        /* amplify exactly 1 band */\n        break;\n\n      case 1:\n        /* amplify bands within 50% of max (on db scale) */\n        if (trigger > 1.0) trigger = Math.pow(trigger, .5);else trigger *= .95;\n        break;\n\n      case 0:\n      default:\n        /* ISO algorithm. amplify all bands with distort>1 */\n        if (trigger > 1.0) trigger = 1.0;else trigger *= .95;\n        break;\n    }\n\n    var j = 0;\n\n    for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n      var width = cod_info.width[sfb];\n      var l;\n      j += width;\n      if (distort[sfb] < trigger) continue;\n\n      if ((gfc.substep_shaping & 2) != 0) {\n        gfc.pseudohalf[sfb] = 0 == gfc.pseudohalf[sfb] ? 1 : 0;\n        if (0 == gfc.pseudohalf[sfb] && gfc.noise_shaping_amp == 2) return;\n      }\n\n      cod_info.scalefac[sfb]++;\n\n      for (l = -width; l < 0; l++) {\n        xrpow[j + l] *= ifqstep34;\n        if (xrpow[j + l] > cod_info.xrpow_max) cod_info.xrpow_max = xrpow[j + l];\n      }\n\n      if (gfc.noise_shaping_amp == 2) return;\n    }\n  }\n  /**\n   * Takehiro Tominaga 2000-xx-xx\n   *\n   * turns on scalefac scale and adjusts scalefactors\n   */\n\n\n  function inc_scalefac_scale(cod_info, xrpow) {\n    var ifqstep34 = 1.29683955465100964055;\n    var j = 0;\n\n    for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n      var width = cod_info.width[sfb];\n      var s = cod_info.scalefac[sfb];\n      if (cod_info.preflag != 0) s += qupvt.pretab[sfb];\n      j += width;\n\n      if ((s & 1) != 0) {\n        s++;\n\n        for (var l = -width; l < 0; l++) {\n          xrpow[j + l] *= ifqstep34;\n          if (xrpow[j + l] > cod_info.xrpow_max) cod_info.xrpow_max = xrpow[j + l];\n        }\n      }\n\n      cod_info.scalefac[sfb] = s >> 1;\n    }\n\n    cod_info.preflag = 0;\n    cod_info.scalefac_scale = 1;\n  }\n  /**\n   * Takehiro Tominaga 2000-xx-xx\n   *\n   * increases the subblock gain and adjusts scalefactors\n   */\n\n\n  function inc_subblock_gain(gfc, cod_info, xrpow) {\n    var sfb;\n    var scalefac = cod_info.scalefac;\n    /* subbloc_gain can't do anything in the long block region */\n\n    for (sfb = 0; sfb < cod_info.sfb_lmax; sfb++) {\n      if (scalefac[sfb] >= 16) return true;\n    }\n\n    for (var window = 0; window < 3; window++) {\n      var s1 = 0;\n      var s2 = 0;\n\n      for (sfb = cod_info.sfb_lmax + window; sfb < cod_info.sfbdivide; sfb += 3) {\n        if (s1 < scalefac[sfb]) s1 = scalefac[sfb];\n      }\n\n      for (; sfb < cod_info.sfbmax; sfb += 3) {\n        if (s2 < scalefac[sfb]) s2 = scalefac[sfb];\n      }\n\n      if (s1 < 16 && s2 < 8) continue;\n      if (cod_info.subblock_gain[window] >= 7) return true;\n      /*\n       * even though there is no scalefactor for sfb12 subblock gain\n       * affects upper frequencies too, that's why we have to go up to\n       * SBMAX_s\n       */\n\n      cod_info.subblock_gain[window]++;\n      var j = gfc.scalefac_band.l[cod_info.sfb_lmax];\n\n      for (sfb = cod_info.sfb_lmax + window; sfb < cod_info.sfbmax; sfb += 3) {\n        var amp;\n        var width = cod_info.width[sfb];\n        var s = scalefac[sfb];\n        assert(s >= 0);\n        s = s - (4 >> cod_info.scalefac_scale);\n\n        if (s >= 0) {\n          scalefac[sfb] = s;\n          j += width * 3;\n          continue;\n        }\n\n        scalefac[sfb] = 0;\n        {\n          var gain = 210 + (s << cod_info.scalefac_scale + 1);\n          amp = qupvt.IPOW20(gain);\n        }\n        j += width * (window + 1);\n\n        for (var l = -width; l < 0; l++) {\n          xrpow[j + l] *= amp;\n          if (xrpow[j + l] > cod_info.xrpow_max) cod_info.xrpow_max = xrpow[j + l];\n        }\n\n        j += width * (3 - window - 1);\n      }\n\n      {\n        var amp = qupvt.IPOW20(202);\n        j += cod_info.width[sfb] * (window + 1);\n\n        for (var l = -cod_info.width[sfb]; l < 0; l++) {\n          xrpow[j + l] *= amp;\n          if (xrpow[j + l] > cod_info.xrpow_max) cod_info.xrpow_max = xrpow[j + l];\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\n   * <PRE>\n   *  Takehiro Tominaga /date??\n   *  Robert Hegemann 2000-09-06: made a function of it\n   *\n   *  amplifies scalefactor bands,\n   *   - if all are already amplified returns 0\n   *   - if some bands are amplified too much:\n   *      * try to increase scalefac_scale\n   *      * if already scalefac_scale was set\n   *          try on short blocks to increase subblock gain\n   * </PRE>\n   */\n\n\n  function balance_noise(gfp, cod_info, distort, xrpow, bRefine) {\n    var gfc = gfp.internal_flags;\n    amp_scalefac_bands(gfp, cod_info, distort, xrpow, bRefine);\n    /*\n     * check to make sure we have not amplified too much loop_break returns\n     * 0 if there is an unamplified scalefac scale_bitcount returns 0 if no\n     * scalefactors are too large\n     */\n\n    var status = loop_break(cod_info);\n    if (status) return false;\n    /* all bands amplified */\n\n    /*\n     * not all scalefactors have been amplified. so these scalefacs are\n     * possibly valid. encode them:\n     */\n\n    if (gfc.mode_gr == 2) status = tk.scale_bitcount(cod_info);else status = tk.scale_bitcount_lsf(gfc, cod_info);\n    if (!status) return true;\n    /* amplified some bands not exceeding limits */\n\n    /*\n     * some scalefactors are too large. lets try setting scalefac_scale=1\n     */\n\n    if (gfc.noise_shaping > 1) {\n      Arrays.fill(gfc.pseudohalf, 0);\n\n      if (0 == cod_info.scalefac_scale) {\n        inc_scalefac_scale(cod_info, xrpow);\n        status = false;\n      } else {\n        if (cod_info.block_type == Encoder.SHORT_TYPE && gfc.subblock_gain > 0) {\n          status = inc_subblock_gain(gfc, cod_info, xrpow) || loop_break(cod_info);\n        }\n      }\n    }\n\n    if (!status) {\n      if (gfc.mode_gr == 2) status = tk.scale_bitcount(cod_info);else status = tk.scale_bitcount_lsf(gfc, cod_info);\n    }\n\n    return !status;\n  }\n  /**\n   * <PRE>\n   *  Function: The outer iteration loop controls the masking conditions\n   *  of all scalefactorbands. It computes the best scalefac and\n   *  global gain. This module calls the inner iteration loop\n   *\n   *  mt 5/99 completely rewritten to allow for bit reservoir control,\n   *  mid/side channels with L/R or mid/side masking thresholds,\n   *  and chooses best quantization instead of last quantization when\n   *  no distortion free quantization can be found.\n   *\n   *  added VBR support mt 5/99\n   *\n   *  some code shuffle rh 9/00\n   * </PRE>\n   *\n   * @param l3_xmin\n   *            allowed distortion\n   * @param xrpow\n   *            coloured magnitudes of spectral\n   * @param targ_bits\n   *            maximum allowed bits\n   */\n\n\n  this.outer_loop = function (gfp, cod_info, l3_xmin, xrpow, ch, targ_bits) {\n    var gfc = gfp.internal_flags;\n    var cod_info_w = new GrInfo();\n    var save_xrpow = new_float(576);\n    var distort = new_float(L3Side.SFBMAX);\n    var best_noise_info = new CalcNoiseResult();\n    var better;\n    var prev_noise = new CalcNoiseData();\n    var best_part2_3_length = 9999999;\n    var bEndOfSearch = false;\n    var bRefine = false;\n    var best_ggain_pass1 = 0;\n    bin_search_StepSize(gfc, cod_info, targ_bits, ch, xrpow);\n    if (0 == gfc.noise_shaping)\n      /* fast mode, no noise shaping, we are ready */\n      return 100;\n    /* default noise_info.over_count */\n\n    /* compute the distortion in this quantization */\n\n    /* coefficients and thresholds both l/r (or both mid/side) */\n\n    qupvt.calc_noise(cod_info, l3_xmin, distort, best_noise_info, prev_noise);\n    best_noise_info.bits = cod_info.part2_3_length;\n    cod_info_w.assign(cod_info);\n    var age = 0;\n    System.arraycopy(xrpow, 0, save_xrpow, 0, 576);\n\n    while (!bEndOfSearch) {\n      /* BEGIN MAIN LOOP */\n      do {\n        var noise_info = new CalcNoiseResult();\n        var search_limit;\n        var maxggain = 255;\n        /*\n         * When quantization with no distorted bands is found, allow up\n         * to X new unsuccesful tries in serial. This gives us more\n         * possibilities for different quant_compare modes. Much more\n         * than 3 makes not a big difference, it is only slower.\n         */\n\n        if ((gfc.substep_shaping & 2) != 0) {\n          search_limit = 20;\n        } else {\n          search_limit = 3;\n        }\n        /*\n         * Check if the last scalefactor band is distorted. in VBR mode\n         * we can't get rid of the distortion, so quit now and VBR mode\n         * will try again with more bits. (makes a 10% speed increase,\n         * the files I tested were binary identical, 2000/05/20 Robert\n         * Hegemann) distort[] > 1 means noise > allowed noise\n         */\n\n\n        if (gfc.sfb21_extra) {\n          if (distort[cod_info_w.sfbmax] > 1.0) break;\n          if (cod_info_w.block_type == Encoder.SHORT_TYPE && (distort[cod_info_w.sfbmax + 1] > 1.0 || distort[cod_info_w.sfbmax + 2] > 1.0)) break;\n        }\n        /* try a new scalefactor conbination on cod_info_w */\n\n\n        if (!balance_noise(gfp, cod_info_w, distort, xrpow, bRefine)) break;\n        if (cod_info_w.scalefac_scale != 0) maxggain = 254;\n        /*\n         * inner_loop starts with the initial quantization step computed\n         * above and slowly increases until the bits < huff_bits. Thus\n         * it is important not to start with too large of an inital\n         * quantization step. Too small is ok, but inner_loop will take\n         * longer\n         */\n\n        var huff_bits = targ_bits - cod_info_w.part2_length;\n        if (huff_bits <= 0) break;\n        /*\n         * increase quantizer stepsize until needed bits are below\n         * maximum\n         */\n\n        while ((cod_info_w.part2_3_length = tk.count_bits(gfc, xrpow, cod_info_w, prev_noise)) > huff_bits && cod_info_w.global_gain <= maxggain) cod_info_w.global_gain++;\n\n        if (cod_info_w.global_gain > maxggain) break;\n\n        if (best_noise_info.over_count == 0) {\n          while ((cod_info_w.part2_3_length = tk.count_bits(gfc, xrpow, cod_info_w, prev_noise)) > best_part2_3_length && cod_info_w.global_gain <= maxggain) cod_info_w.global_gain++;\n\n          if (cod_info_w.global_gain > maxggain) break;\n        }\n        /* compute the distortion in this quantization */\n\n\n        qupvt.calc_noise(cod_info_w, l3_xmin, distort, noise_info, prev_noise);\n        noise_info.bits = cod_info_w.part2_3_length;\n        /*\n         * check if this quantization is better than our saved\n         * quantization\n         */\n\n        if (cod_info.block_type != Encoder.SHORT_TYPE) {\n          // NORM, START or STOP type\n          better = gfp.quant_comp;\n        } else better = gfp.quant_comp_short;\n\n        better = quant_compare(better, best_noise_info, noise_info, cod_info_w, distort) ? 1 : 0;\n        /* save data so we can restore this quantization later */\n\n        if (better != 0) {\n          best_part2_3_length = cod_info.part2_3_length;\n          best_noise_info = noise_info;\n          cod_info.assign(cod_info_w);\n          age = 0;\n          /* save data so we can restore this quantization later */\n\n          /* store for later reuse */\n\n          System.arraycopy(xrpow, 0, save_xrpow, 0, 576);\n        } else {\n          /* early stop? */\n          if (gfc.full_outer_loop == 0) {\n            if (++age > search_limit && best_noise_info.over_count == 0) break;\n            if (gfc.noise_shaping_amp == 3 && bRefine && age > 30) break;\n            if (gfc.noise_shaping_amp == 3 && bRefine && cod_info_w.global_gain - best_ggain_pass1 > 15) break;\n          }\n        }\n      } while (cod_info_w.global_gain + cod_info_w.scalefac_scale < 255);\n\n      if (gfc.noise_shaping_amp == 3) {\n        if (!bRefine) {\n          /* refine search */\n          cod_info_w.assign(cod_info);\n          System.arraycopy(save_xrpow, 0, xrpow, 0, 576);\n          age = 0;\n          best_ggain_pass1 = cod_info_w.global_gain;\n          bRefine = true;\n        } else {\n          /* search already refined, stop */\n          bEndOfSearch = true;\n        }\n      } else {\n        bEndOfSearch = true;\n      }\n    }\n\n    assert(cod_info.global_gain + cod_info.scalefac_scale <= 255);\n    /*\n     * finish up\n     */\n\n    if (gfp.VBR == VbrMode.vbr_rh || gfp.VBR == VbrMode.vbr_mtrh)\n      /* restore for reuse on next try */\n      System.arraycopy(save_xrpow, 0, xrpow, 0, 576);\n      /*\n       * do the 'substep shaping'\n       */\n    else if ((gfc.substep_shaping & 1) != 0) trancate_smallspectrums(gfc, cod_info, l3_xmin, xrpow);\n    return best_noise_info.over_count;\n  };\n  /**\n   * Robert Hegemann 2000-09-06\n   *\n   * update reservoir status after FINAL quantization/bitrate\n   */\n\n\n  this.iteration_finish_one = function (gfc, gr, ch) {\n    var l3_side = gfc.l3_side;\n    var cod_info = l3_side.tt[gr][ch];\n    /*\n     * try some better scalefac storage\n     */\n\n    tk.best_scalefac_store(gfc, gr, ch, l3_side);\n    /*\n     * best huffman_divide may save some bits too\n     */\n\n    if (gfc.use_best_huffman == 1) tk.best_huffman_divide(gfc, cod_info);\n    /*\n     * update reservoir status after FINAL quantization/bitrate\n     */\n\n    rv.ResvAdjust(gfc, cod_info);\n  };\n  /**\n   *\n   * 2000-09-04 Robert Hegemann\n   *\n   * @param l3_xmin\n   *            allowed distortion of the scalefactor\n   * @param xrpow\n   *            coloured magnitudes of spectral values\n   */\n\n\n  this.VBR_encode_granule = function (gfp, cod_info, l3_xmin, xrpow, ch, min_bits, max_bits) {\n    var gfc = gfp.internal_flags;\n    var bst_cod_info = new GrInfo();\n    var bst_xrpow = new_float(576);\n    var Max_bits = max_bits;\n    var real_bits = max_bits + 1;\n    var this_bits = (max_bits + min_bits) / 2;\n    var dbits,\n        over,\n        found = 0;\n    var sfb21_extra = gfc.sfb21_extra;\n    assert(Max_bits <= LameInternalFlags.MAX_BITS_PER_CHANNEL);\n    Arrays.fill(bst_cod_info.l3_enc, 0);\n    /*\n     * search within round about 40 bits of optimal\n     */\n\n    do {\n      assert(this_bits >= min_bits);\n      assert(this_bits <= max_bits);\n      assert(min_bits <= max_bits);\n      if (this_bits > Max_bits - 42) gfc.sfb21_extra = false;else gfc.sfb21_extra = sfb21_extra;\n      over = outer_loop(gfp, cod_info, l3_xmin, xrpow, ch, this_bits);\n      /*\n       * is quantization as good as we are looking for ? in this case: is\n       * no scalefactor band distorted?\n       */\n\n      if (over <= 0) {\n        found = 1;\n        /*\n         * now we know it can be done with \"real_bits\" and maybe we can\n         * skip some iterations\n         */\n\n        real_bits = cod_info.part2_3_length;\n        /*\n         * store best quantization so far\n         */\n\n        bst_cod_info.assign(cod_info);\n        System.arraycopy(xrpow, 0, bst_xrpow, 0, 576);\n        /*\n         * try with fewer bits\n         */\n\n        max_bits = real_bits - 32;\n        dbits = max_bits - min_bits;\n        this_bits = (max_bits + min_bits) / 2;\n      } else {\n        /*\n         * try with more bits\n         */\n        min_bits = this_bits + 32;\n        dbits = max_bits - min_bits;\n        this_bits = (max_bits + min_bits) / 2;\n\n        if (found != 0) {\n          found = 2;\n          /*\n           * start again with best quantization so far\n           */\n\n          cod_info.assign(bst_cod_info);\n          System.arraycopy(bst_xrpow, 0, xrpow, 0, 576);\n        }\n      }\n    } while (dbits > 12);\n\n    gfc.sfb21_extra = sfb21_extra;\n    /*\n     * found=0 => nothing found, use last one found=1 => we just found the\n     * best and left the loop found=2 => we restored a good one and have now\n     * l3_enc to restore too\n     */\n\n    if (found == 2) {\n      System.arraycopy(bst_cod_info.l3_enc, 0, cod_info.l3_enc, 0, 576);\n    }\n\n    assert(cod_info.part2_3_length <= Max_bits);\n  };\n  /**\n   * Robert Hegemann 2000-09-05\n   *\n   * calculates * how many bits are available for analog silent granules * how\n   * many bits to use for the lowest allowed bitrate * how many bits each\n   * bitrate would provide\n   */\n\n\n  this.get_framebits = function (gfp, frameBits) {\n    var gfc = gfp.internal_flags;\n    /*\n     * always use at least this many bits per granule per channel unless we\n     * detect analog silence, see below\n     */\n\n    gfc.bitrate_index = gfc.VBR_min_bitrate;\n    var bitsPerFrame = bs.getframebits(gfp);\n    /*\n     * bits for analog silence\n     */\n\n    gfc.bitrate_index = 1;\n    bitsPerFrame = bs.getframebits(gfp);\n\n    for (var i = 1; i <= gfc.VBR_max_bitrate; i++) {\n      gfc.bitrate_index = i;\n      var mb = new MeanBits(bitsPerFrame);\n      frameBits[i] = rv.ResvFrameBegin(gfp, mb);\n      bitsPerFrame = mb.bits;\n    }\n  };\n  /* RH: this one needs to be overhauled sometime */\n\n  /**\n   * <PRE>\n   *  2000-09-04 Robert Hegemann\n   *\n   *  * converts LR to MS coding when necessary\n   *  * calculates allowed/adjusted quantization noise amounts\n   *  * detects analog silent frames\n   *\n   *  some remarks:\n   *  - lower masking depending on Quality setting\n   *  - quality control together with adjusted ATH MDCT scaling\n   *    on lower quality setting allocate more noise from\n   *    ATH masking, and on higher quality setting allocate\n   *    less noise from ATH masking.\n   *  - experiments show that going more than 2dB over GPSYCHO's\n   *    limits ends up in very annoying artefacts\n   * </PRE>\n   */\n\n\n  this.VBR_old_prepare = function (gfp, pe, ms_ener_ratio, ratio, l3_xmin, frameBits, min_bits, max_bits, bands) {\n    var gfc = gfp.internal_flags;\n    var masking_lower_db,\n        adjust = 0.0;\n    var analog_silence = 1;\n    var bits = 0;\n    gfc.bitrate_index = gfc.VBR_max_bitrate;\n    var avg = rv.ResvFrameBegin(gfp, new MeanBits(0)) / gfc.mode_gr;\n    get_framebits(gfp, frameBits);\n\n    for (var gr = 0; gr < gfc.mode_gr; gr++) {\n      var mxb = qupvt.on_pe(gfp, pe, max_bits[gr], avg, gr, 0);\n\n      if (gfc.mode_ext == Encoder.MPG_MD_MS_LR) {\n        ms_convert(gfc.l3_side, gr);\n        qupvt.reduce_side(max_bits[gr], ms_ener_ratio[gr], avg, mxb);\n      }\n\n      for (var ch = 0; ch < gfc.channels_out; ++ch) {\n        var cod_info = gfc.l3_side.tt[gr][ch];\n\n        if (cod_info.block_type != Encoder.SHORT_TYPE) {\n          // NORM, START or STOP type\n          adjust = 1.28 / (1 + Math.exp(3.5 - pe[gr][ch] / 300.)) - 0.05;\n          masking_lower_db = gfc.PSY.mask_adjust - adjust;\n        } else {\n          adjust = 2.56 / (1 + Math.exp(3.5 - pe[gr][ch] / 300.)) - 0.14;\n          masking_lower_db = gfc.PSY.mask_adjust_short - adjust;\n        }\n\n        gfc.masking_lower = Math.pow(10.0, masking_lower_db * 0.1);\n        init_outer_loop(gfc, cod_info);\n        bands[gr][ch] = qupvt.calc_xmin(gfp, ratio[gr][ch], cod_info, l3_xmin[gr][ch]);\n        if (bands[gr][ch] != 0) analog_silence = 0;\n        min_bits[gr][ch] = 126;\n        bits += max_bits[gr][ch];\n      }\n    }\n\n    for (var gr = 0; gr < gfc.mode_gr; gr++) {\n      for (var ch = 0; ch < gfc.channels_out; ch++) {\n        if (bits > frameBits[gfc.VBR_max_bitrate]) {\n          max_bits[gr][ch] *= frameBits[gfc.VBR_max_bitrate];\n          max_bits[gr][ch] /= bits;\n        }\n\n        if (min_bits[gr][ch] > max_bits[gr][ch]) min_bits[gr][ch] = max_bits[gr][ch];\n      }\n      /* for ch */\n\n    }\n    /* for gr */\n\n\n    return analog_silence;\n  };\n\n  this.bitpressure_strategy = function (gfc, l3_xmin, min_bits, max_bits) {\n    for (var gr = 0; gr < gfc.mode_gr; gr++) {\n      for (var ch = 0; ch < gfc.channels_out; ch++) {\n        var gi = gfc.l3_side.tt[gr][ch];\n        var pxmin = l3_xmin[gr][ch];\n        var pxminPos = 0;\n\n        for (var sfb = 0; sfb < gi.psy_lmax; sfb++) pxmin[pxminPos++] *= 1. + .029 * sfb * sfb / Encoder.SBMAX_l / Encoder.SBMAX_l;\n\n        if (gi.block_type == Encoder.SHORT_TYPE) {\n          for (var sfb = gi.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n            pxmin[pxminPos++] *= 1. + .029 * sfb * sfb / Encoder.SBMAX_s / Encoder.SBMAX_s;\n            pxmin[pxminPos++] *= 1. + .029 * sfb * sfb / Encoder.SBMAX_s / Encoder.SBMAX_s;\n            pxmin[pxminPos++] *= 1. + .029 * sfb * sfb / Encoder.SBMAX_s / Encoder.SBMAX_s;\n          }\n        }\n\n        max_bits[gr][ch] = 0 | Math.max(min_bits[gr][ch], 0.9 * max_bits[gr][ch]);\n      }\n    }\n  };\n\n  this.VBR_new_prepare = function (gfp, pe, ratio, l3_xmin, frameBits, max_bits) {\n    var gfc = gfp.internal_flags;\n    var analog_silence = 1;\n    var avg = 0,\n        bits = 0;\n    var maximum_framebits;\n\n    if (!gfp.free_format) {\n      gfc.bitrate_index = gfc.VBR_max_bitrate;\n      var mb = new MeanBits(avg);\n      rv.ResvFrameBegin(gfp, mb);\n      avg = mb.bits;\n      get_framebits(gfp, frameBits);\n      maximum_framebits = frameBits[gfc.VBR_max_bitrate];\n    } else {\n      gfc.bitrate_index = 0;\n      var mb = new MeanBits(avg);\n      maximum_framebits = rv.ResvFrameBegin(gfp, mb);\n      avg = mb.bits;\n      frameBits[0] = maximum_framebits;\n    }\n\n    for (var gr = 0; gr < gfc.mode_gr; gr++) {\n      qupvt.on_pe(gfp, pe, max_bits[gr], avg, gr, 0);\n\n      if (gfc.mode_ext == Encoder.MPG_MD_MS_LR) {\n        ms_convert(gfc.l3_side, gr);\n      }\n\n      for (var ch = 0; ch < gfc.channels_out; ++ch) {\n        var cod_info = gfc.l3_side.tt[gr][ch];\n        gfc.masking_lower = Math.pow(10.0, gfc.PSY.mask_adjust * 0.1);\n        init_outer_loop(gfc, cod_info);\n        if (0 != qupvt.calc_xmin(gfp, ratio[gr][ch], cod_info, l3_xmin[gr][ch])) analog_silence = 0;\n        bits += max_bits[gr][ch];\n      }\n    }\n\n    for (var gr = 0; gr < gfc.mode_gr; gr++) {\n      for (var ch = 0; ch < gfc.channels_out; ch++) {\n        if (bits > maximum_framebits) {\n          max_bits[gr][ch] *= maximum_framebits;\n          max_bits[gr][ch] /= bits;\n        }\n      }\n      /* for ch */\n\n    }\n    /* for gr */\n\n\n    return analog_silence;\n  };\n  /**\n   * calculates target bits for ABR encoding\n   *\n   * mt 2000/05/31\n   */\n\n\n  this.calc_target_bits = function (gfp, pe, ms_ener_ratio, targ_bits, analog_silence_bits, max_frame_bits) {\n    var gfc = gfp.internal_flags;\n    var l3_side = gfc.l3_side;\n    var res_factor;\n    var gr,\n        ch,\n        totbits,\n        mean_bits = 0;\n    gfc.bitrate_index = gfc.VBR_max_bitrate;\n    var mb = new MeanBits(mean_bits);\n    max_frame_bits[0] = rv.ResvFrameBegin(gfp, mb);\n    mean_bits = mb.bits;\n    gfc.bitrate_index = 1;\n    mean_bits = bs.getframebits(gfp) - gfc.sideinfo_len * 8;\n    analog_silence_bits[0] = mean_bits / (gfc.mode_gr * gfc.channels_out);\n    mean_bits = gfp.VBR_mean_bitrate_kbps * gfp.framesize * 1000;\n    if ((gfc.substep_shaping & 1) != 0) mean_bits *= 1.09;\n    mean_bits /= gfp.out_samplerate;\n    mean_bits -= gfc.sideinfo_len * 8;\n    mean_bits /= gfc.mode_gr * gfc.channels_out;\n    /**\n     * <PRE>\n     *           res_factor is the percentage of the target bitrate that should\n     *           be used on average.  the remaining bits are added to the\n     *           bitreservoir and used for difficult to encode frames.\n     *\n     *           Since we are tracking the average bitrate, we should adjust\n     *           res_factor \"on the fly\", increasing it if the average bitrate\n     *           is greater than the requested bitrate, and decreasing it\n     *           otherwise.  Reasonable ranges are from .9 to 1.0\n     *\n     *           Until we get the above suggestion working, we use the following\n     *           tuning:\n     *           compression ratio    res_factor\n     *           5.5  (256kbps)         1.0      no need for bitreservoir\n     *           11   (128kbps)         .93      7% held for reservoir\n     *\n     *           with linear interpolation for other values.\n     * </PRE>\n     */\n\n    res_factor = .93 + .07 * (11.0 - gfp.compression_ratio) / (11.0 - 5.5);\n    if (res_factor < .90) res_factor = .90;\n    if (res_factor > 1.00) res_factor = 1.00;\n\n    for (gr = 0; gr < gfc.mode_gr; gr++) {\n      var sum = 0;\n\n      for (ch = 0; ch < gfc.channels_out; ch++) {\n        targ_bits[gr][ch] = int(res_factor * mean_bits);\n\n        if (pe[gr][ch] > 700) {\n          var add_bits = int((pe[gr][ch] - 700) / 1.4);\n          var cod_info = l3_side.tt[gr][ch];\n          targ_bits[gr][ch] = int(res_factor * mean_bits);\n          /* short blocks use a little extra, no matter what the pe */\n\n          if (cod_info.block_type == Encoder.SHORT_TYPE) {\n            if (add_bits < mean_bits / 2) add_bits = mean_bits / 2;\n          }\n          /* at most increase bits by 1.5*average */\n\n\n          if (add_bits > mean_bits * 3 / 2) add_bits = mean_bits * 3 / 2;else if (add_bits < 0) add_bits = 0;\n          targ_bits[gr][ch] += add_bits;\n        }\n\n        if (targ_bits[gr][ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL) {\n          targ_bits[gr][ch] = LameInternalFlags.MAX_BITS_PER_CHANNEL;\n        }\n\n        sum += targ_bits[gr][ch];\n      }\n      /* for ch */\n\n\n      if (sum > LameInternalFlags.MAX_BITS_PER_GRANULE) {\n        for (ch = 0; ch < gfc.channels_out; ++ch) {\n          targ_bits[gr][ch] *= LameInternalFlags.MAX_BITS_PER_GRANULE;\n          targ_bits[gr][ch] /= sum;\n        }\n      }\n    }\n    /* for gr */\n\n\n    if (gfc.mode_ext == Encoder.MPG_MD_MS_LR) for (gr = 0; gr < gfc.mode_gr; gr++) {\n      qupvt.reduce_side(targ_bits[gr], ms_ener_ratio[gr], mean_bits * gfc.channels_out, LameInternalFlags.MAX_BITS_PER_GRANULE);\n    }\n    /*\n     * sum target bits\n     */\n\n    totbits = 0;\n\n    for (gr = 0; gr < gfc.mode_gr; gr++) {\n      for (ch = 0; ch < gfc.channels_out; ch++) {\n        if (targ_bits[gr][ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL) targ_bits[gr][ch] = LameInternalFlags.MAX_BITS_PER_CHANNEL;\n        totbits += targ_bits[gr][ch];\n      }\n    }\n    /*\n     * repartion target bits if needed\n     */\n\n\n    if (totbits > max_frame_bits[0]) {\n      for (gr = 0; gr < gfc.mode_gr; gr++) {\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          targ_bits[gr][ch] *= max_frame_bits[0];\n          targ_bits[gr][ch] /= totbits;\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = Quantize;","map":null,"metadata":{},"sourceType":"script"}