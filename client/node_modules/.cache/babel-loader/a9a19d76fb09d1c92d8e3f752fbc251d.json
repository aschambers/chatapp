{"ast":null,"code":"/*\n *\tMP3 huffman table selecting and bit counting\n *\n *\tCopyright (c) 1999-2005 Takehiro TOMINAGA\n *\tCopyright (c) 2002-2005 Gabriel Bouvigne\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: Takehiro.java,v 1.26 2011/05/24 20:48:06 kenchis Exp $ */\n//package mp3;\n//import java.util.Arrays;\nvar common = require('./common.js');\n\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar Encoder = require('./Encoder.js');\n\nvar Tables = require('./Tables.js');\n\nvar GrInfo = require('./GrInfo.js');\n\nvar QuantizePVT = require('./QuantizePVT.js');\n\nfunction Takehiro() {\n  var qupvt = null;\n  this.qupvt = null;\n\n  this.setModules = function (_qupvt) {\n    this.qupvt = _qupvt;\n    qupvt = _qupvt;\n  };\n\n  function Bits(b) {\n    this.bits = 0 | b;\n  }\n\n  var subdv_table = [[0, 0],\n  /* 0 bands */\n  [0, 0],\n  /* 1 bands */\n  [0, 0],\n  /* 2 bands */\n  [0, 0],\n  /* 3 bands */\n  [0, 0],\n  /* 4 bands */\n  [0, 1],\n  /* 5 bands */\n  [1, 1],\n  /* 6 bands */\n  [1, 1],\n  /* 7 bands */\n  [1, 2],\n  /* 8 bands */\n  [2, 2],\n  /* 9 bands */\n  [2, 3],\n  /* 10 bands */\n  [2, 3],\n  /* 11 bands */\n  [3, 4],\n  /* 12 bands */\n  [3, 4],\n  /* 13 bands */\n  [3, 4],\n  /* 14 bands */\n  [4, 5],\n  /* 15 bands */\n  [4, 5],\n  /* 16 bands */\n  [4, 6],\n  /* 17 bands */\n  [5, 6],\n  /* 18 bands */\n  [5, 6],\n  /* 19 bands */\n  [5, 7],\n  /* 20 bands */\n  [6, 7],\n  /* 21 bands */\n  [6, 7]];\n  /**\n   * nonlinear quantization of xr More accurate formula than the ISO formula.\n   * Takes into account the fact that we are quantizing xr . ix, but we want\n   * ix^4/3 to be as close as possible to x^4/3. (taking the nearest int would\n   * mean ix is as close as possible to xr, which is different.)\n   *\n   * From Segher Boessenkool <segher@eastsite.nl> 11/1999\n   *\n   * 09/2000: ASM code removed in favor of IEEE754 hack by Takehiro Tominaga.\n   * If you need the ASM code, check CVS circa Aug 2000.\n   *\n   * 01/2004: Optimizations by Gabriel Bouvigne\n   */\n\n  function quantize_lines_xrpow_01(l, istep, xr, xrPos, ix, ixPos) {\n    var compareval0 = (1.0 - 0.4054) / istep;\n    assert(l > 0);\n    l = l >> 1;\n\n    while (l-- != 0) {\n      ix[ixPos++] = compareval0 > xr[xrPos++] ? 0 : 1;\n      ix[ixPos++] = compareval0 > xr[xrPos++] ? 0 : 1;\n    }\n  }\n  /**\n   * XRPOW_FTOI is a macro to convert floats to ints.<BR>\n   * if XRPOW_FTOI(x) = nearest_int(x), then QUANTFAC(x)=adj43asm[x]<BR>\n   * ROUNDFAC= -0.0946<BR>\n   *\n   * if XRPOW_FTOI(x) = floor(x), then QUANTFAC(x)=asj43[x]<BR>\n   * ROUNDFAC=0.4054<BR>\n   *\n   * Note: using floor() or 0| is extremely slow. On machines where the\n   * TAKEHIRO_IEEE754_HACK code above does not work, it is worthwile to write\n   * some ASM for XRPOW_FTOI().\n   */\n\n\n  function quantize_lines_xrpow(l, istep, xr, xrPos, ix, ixPos) {\n    assert(l > 0);\n    l = l >> 1;\n    var remaining = l % 2;\n    l = l >> 1;\n\n    while (l-- != 0) {\n      var x0, x1, x2, x3;\n      var rx0, rx1, rx2, rx3;\n      x0 = xr[xrPos++] * istep;\n      x1 = xr[xrPos++] * istep;\n      rx0 = 0 | x0;\n      x2 = xr[xrPos++] * istep;\n      rx1 = 0 | x1;\n      x3 = xr[xrPos++] * istep;\n      rx2 = 0 | x2;\n      x0 += qupvt.adj43[rx0];\n      rx3 = 0 | x3;\n      x1 += qupvt.adj43[rx1];\n      ix[ixPos++] = 0 | x0;\n      x2 += qupvt.adj43[rx2];\n      ix[ixPos++] = 0 | x1;\n      x3 += qupvt.adj43[rx3];\n      ix[ixPos++] = 0 | x2;\n      ix[ixPos++] = 0 | x3;\n    }\n\n    if (remaining != 0) {\n      var x0, x1;\n      var rx0, rx1;\n      x0 = xr[xrPos++] * istep;\n      x1 = xr[xrPos++] * istep;\n      rx0 = 0 | x0;\n      rx1 = 0 | x1;\n      x0 += qupvt.adj43[rx0];\n      x1 += qupvt.adj43[rx1];\n      ix[ixPos++] = 0 | x0;\n      ix[ixPos++] = 0 | x1;\n    }\n  }\n  /**\n   * Quantization function This function will select which lines to quantize\n   * and call the proper quantization function\n   */\n\n\n  function quantize_xrpow(xp, pi, istep, codInfo, prevNoise) {\n    /* quantize on xr^(3/4) instead of xr */\n    var sfb;\n    var sfbmax;\n    var j = 0;\n    var prev_data_use;\n    var accumulate = 0;\n    var accumulate01 = 0;\n    var xpPos = 0;\n    var iData = pi;\n    var iDataPos = 0;\n    var acc_iData = iData;\n    var acc_iDataPos = 0;\n    var acc_xp = xp;\n    var acc_xpPos = 0;\n    /*\n     * Reusing previously computed data does not seems to work if global\n     * gain is changed. Finding why it behaves this way would allow to use a\n     * cache of previously computed values (let's 10 cached values per sfb)\n     * that would probably provide a noticeable speedup\n     */\n\n    prev_data_use = prevNoise != null && codInfo.global_gain == prevNoise.global_gain;\n    if (codInfo.block_type == Encoder.SHORT_TYPE) sfbmax = 38;else sfbmax = 21;\n\n    for (sfb = 0; sfb <= sfbmax; sfb++) {\n      var step = -1;\n\n      if (prev_data_use || codInfo.block_type == Encoder.NORM_TYPE) {\n        step = codInfo.global_gain - (codInfo.scalefac[sfb] + (codInfo.preflag != 0 ? qupvt.pretab[sfb] : 0) << codInfo.scalefac_scale + 1) - codInfo.subblock_gain[codInfo.window[sfb]] * 8;\n      }\n\n      assert(codInfo.width[sfb] >= 0);\n\n      if (prev_data_use && prevNoise.step[sfb] == step) {\n        /*\n         * do not recompute this part, but compute accumulated lines\n         */\n        if (accumulate != 0) {\n          quantize_lines_xrpow(accumulate, istep, acc_xp, acc_xpPos, acc_iData, acc_iDataPos);\n          accumulate = 0;\n        }\n\n        if (accumulate01 != 0) {\n          quantize_lines_xrpow_01(accumulate01, istep, acc_xp, acc_xpPos, acc_iData, acc_iDataPos);\n          accumulate01 = 0;\n        }\n      } else {\n        /* should compute this part */\n        var l = codInfo.width[sfb];\n\n        if (j + codInfo.width[sfb] > codInfo.max_nonzero_coeff) {\n          /* do not compute upper zero part */\n          var usefullsize;\n          usefullsize = codInfo.max_nonzero_coeff - j + 1;\n          Arrays.fill(pi, codInfo.max_nonzero_coeff, 576, 0);\n          l = usefullsize;\n\n          if (l < 0) {\n            l = 0;\n          }\n          /* no need to compute higher sfb values */\n\n\n          sfb = sfbmax + 1;\n        }\n        /* accumulate lines to quantize */\n\n\n        if (0 == accumulate && 0 == accumulate01) {\n          acc_iData = iData;\n          acc_iDataPos = iDataPos;\n          acc_xp = xp;\n          acc_xpPos = xpPos;\n        }\n\n        if (prevNoise != null && prevNoise.sfb_count1 > 0 && sfb >= prevNoise.sfb_count1 && prevNoise.step[sfb] > 0 && step >= prevNoise.step[sfb]) {\n          if (accumulate != 0) {\n            quantize_lines_xrpow(accumulate, istep, acc_xp, acc_xpPos, acc_iData, acc_iDataPos);\n            accumulate = 0;\n            acc_iData = iData;\n            acc_iDataPos = iDataPos;\n            acc_xp = xp;\n            acc_xpPos = xpPos;\n          }\n\n          accumulate01 += l;\n        } else {\n          if (accumulate01 != 0) {\n            quantize_lines_xrpow_01(accumulate01, istep, acc_xp, acc_xpPos, acc_iData, acc_iDataPos);\n            accumulate01 = 0;\n            acc_iData = iData;\n            acc_iDataPos = iDataPos;\n            acc_xp = xp;\n            acc_xpPos = xpPos;\n          }\n\n          accumulate += l;\n        }\n\n        if (l <= 0) {\n          /*\n           * rh: 20040215 may happen due to \"prev_data_use\"\n           * optimization\n           */\n          if (accumulate01 != 0) {\n            quantize_lines_xrpow_01(accumulate01, istep, acc_xp, acc_xpPos, acc_iData, acc_iDataPos);\n            accumulate01 = 0;\n          }\n\n          if (accumulate != 0) {\n            quantize_lines_xrpow(accumulate, istep, acc_xp, acc_xpPos, acc_iData, acc_iDataPos);\n            accumulate = 0;\n          }\n\n          break;\n          /* ends for-loop */\n        }\n      }\n\n      if (sfb <= sfbmax) {\n        iDataPos += codInfo.width[sfb];\n        xpPos += codInfo.width[sfb];\n        j += codInfo.width[sfb];\n      }\n    }\n\n    if (accumulate != 0) {\n      /* last data part */\n      quantize_lines_xrpow(accumulate, istep, acc_xp, acc_xpPos, acc_iData, acc_iDataPos);\n      accumulate = 0;\n    }\n\n    if (accumulate01 != 0) {\n      /* last data part */\n      quantize_lines_xrpow_01(accumulate01, istep, acc_xp, acc_xpPos, acc_iData, acc_iDataPos);\n      accumulate01 = 0;\n    }\n  }\n  /**\n   * ix_max\n   */\n\n\n  function ix_max(ix, ixPos, endPos) {\n    var max1 = 0,\n        max2 = 0;\n\n    do {\n      var x1 = ix[ixPos++];\n      var x2 = ix[ixPos++];\n      if (max1 < x1) max1 = x1;\n      if (max2 < x2) max2 = x2;\n    } while (ixPos < endPos);\n\n    if (max1 < max2) max1 = max2;\n    return max1;\n  }\n\n  function count_bit_ESC(ix, ixPos, end, t1, t2, s) {\n    /* ESC-table is used */\n    var linbits = Tables.ht[t1].xlen * 65536 + Tables.ht[t2].xlen;\n    var sum = 0,\n        sum2;\n\n    do {\n      var x = ix[ixPos++];\n      var y = ix[ixPos++];\n\n      if (x != 0) {\n        if (x > 14) {\n          x = 15;\n          sum += linbits;\n        }\n\n        x *= 16;\n      }\n\n      if (y != 0) {\n        if (y > 14) {\n          y = 15;\n          sum += linbits;\n        }\n\n        x += y;\n      }\n\n      sum += Tables.largetbl[x];\n    } while (ixPos < end);\n\n    sum2 = sum & 0xffff;\n    sum >>= 16;\n\n    if (sum > sum2) {\n      sum = sum2;\n      t1 = t2;\n    }\n\n    s.bits += sum;\n    return t1;\n  }\n\n  function count_bit_noESC(ix, ixPos, end, s) {\n    /* No ESC-words */\n    var sum1 = 0;\n    var hlen1 = Tables.ht[1].hlen;\n\n    do {\n      var x = ix[ixPos + 0] * 2 + ix[ixPos + 1];\n      ixPos += 2;\n      sum1 += hlen1[x];\n    } while (ixPos < end);\n\n    s.bits += sum1;\n    return 1;\n  }\n\n  function count_bit_noESC_from2(ix, ixPos, end, t1, s) {\n    /* No ESC-words */\n    var sum = 0,\n        sum2;\n    var xlen = Tables.ht[t1].xlen;\n    var hlen;\n    if (t1 == 2) hlen = Tables.table23;else hlen = Tables.table56;\n\n    do {\n      var x = ix[ixPos + 0] * xlen + ix[ixPos + 1];\n      ixPos += 2;\n      sum += hlen[x];\n    } while (ixPos < end);\n\n    sum2 = sum & 0xffff;\n    sum >>= 16;\n\n    if (sum > sum2) {\n      sum = sum2;\n      t1++;\n    }\n\n    s.bits += sum;\n    return t1;\n  }\n\n  function count_bit_noESC_from3(ix, ixPos, end, t1, s) {\n    /* No ESC-words */\n    var sum1 = 0;\n    var sum2 = 0;\n    var sum3 = 0;\n    var xlen = Tables.ht[t1].xlen;\n    var hlen1 = Tables.ht[t1].hlen;\n    var hlen2 = Tables.ht[t1 + 1].hlen;\n    var hlen3 = Tables.ht[t1 + 2].hlen;\n\n    do {\n      var x = ix[ixPos + 0] * xlen + ix[ixPos + 1];\n      ixPos += 2;\n      sum1 += hlen1[x];\n      sum2 += hlen2[x];\n      sum3 += hlen3[x];\n    } while (ixPos < end);\n\n    var t = t1;\n\n    if (sum1 > sum2) {\n      sum1 = sum2;\n      t++;\n    }\n\n    if (sum1 > sum3) {\n      sum1 = sum3;\n      t = t1 + 2;\n    }\n\n    s.bits += sum1;\n    return t;\n  }\n  /*************************************************************************/\n\n  /* choose table */\n\n  /*************************************************************************/\n\n\n  var huf_tbl_noESC = [1, 2, 5, 7, 7, 10, 10, 13, 13, 13, 13, 13, 13, 13, 13];\n  /**\n   * Choose the Huffman table that will encode ix[begin..end] with the fewest\n   * bits.\n   *\n   * Note: This code contains knowledge about the sizes and characteristics of\n   * the Huffman tables as defined in the IS (Table B.7), and will not work\n   * with any arbitrary tables.\n   */\n\n  function choose_table(ix, ixPos, endPos, s) {\n    var max = ix_max(ix, ixPos, endPos);\n\n    switch (max) {\n      case 0:\n        return max;\n\n      case 1:\n        return count_bit_noESC(ix, ixPos, endPos, s);\n\n      case 2:\n      case 3:\n        return count_bit_noESC_from2(ix, ixPos, endPos, huf_tbl_noESC[max - 1], s);\n\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 13:\n      case 14:\n      case 15:\n        return count_bit_noESC_from3(ix, ixPos, endPos, huf_tbl_noESC[max - 1], s);\n\n      default:\n        /* try tables with linbits */\n        if (max > QuantizePVT.IXMAX_VAL) {\n          s.bits = QuantizePVT.LARGE_BITS;\n          return -1;\n        }\n\n        max -= 15;\n        var choice2;\n\n        for (choice2 = 24; choice2 < 32; choice2++) {\n          if (Tables.ht[choice2].linmax >= max) {\n            break;\n          }\n        }\n\n        var choice;\n\n        for (choice = choice2 - 8; choice < 24; choice++) {\n          if (Tables.ht[choice].linmax >= max) {\n            break;\n          }\n        }\n\n        return count_bit_ESC(ix, ixPos, endPos, choice, choice2, s);\n    }\n  }\n  /**\n   * count_bit\n   */\n\n\n  this.noquant_count_bits = function (gfc, gi, prev_noise) {\n    var ix = gi.l3_enc;\n    var i = Math.min(576, gi.max_nonzero_coeff + 2 >> 1 << 1);\n    if (prev_noise != null) prev_noise.sfb_count1 = 0;\n    /* Determine count1 region */\n\n    for (; i > 1; i -= 2) if ((ix[i - 1] | ix[i - 2]) != 0) break;\n\n    gi.count1 = i;\n    /* Determines the number of bits to encode the quadruples. */\n\n    var a1 = 0;\n    var a2 = 0;\n\n    for (; i > 3; i -= 4) {\n      var p;\n      /* hack to check if all values <= 1 */\n      //throw \"TODO: HACK         if ((((long) ix[i - 1] | (long) ix[i - 2] | (long) ix[i - 3] | (long) ix[i - 4]) & 0xffffffffL) > 1L        \"\n      //if (true) {\n\n      if (((ix[i - 1] | ix[i - 2] | ix[i - 3] | ix[i - 4]) & 0x7fffffff) > 1) {\n        break;\n      }\n\n      p = ((ix[i - 4] * 2 + ix[i - 3]) * 2 + ix[i - 2]) * 2 + ix[i - 1];\n      a1 += Tables.t32l[p];\n      a2 += Tables.t33l[p];\n    }\n\n    var bits = a1;\n    gi.count1table_select = 0;\n\n    if (a1 > a2) {\n      bits = a2;\n      gi.count1table_select = 1;\n    }\n\n    gi.count1bits = bits;\n    gi.big_values = i;\n    if (i == 0) return bits;\n\n    if (gi.block_type == Encoder.SHORT_TYPE) {\n      a1 = 3 * gfc.scalefac_band.s[3];\n      if (a1 > gi.big_values) a1 = gi.big_values;\n      a2 = gi.big_values;\n    } else if (gi.block_type == Encoder.NORM_TYPE) {\n      assert(i <= 576);\n      /* bv_scf has 576 entries (0..575) */\n\n      a1 = gi.region0_count = gfc.bv_scf[i - 2];\n      a2 = gi.region1_count = gfc.bv_scf[i - 1];\n      assert(a1 + a2 + 2 < Encoder.SBPSY_l);\n      a2 = gfc.scalefac_band.l[a1 + a2 + 2];\n      a1 = gfc.scalefac_band.l[a1 + 1];\n\n      if (a2 < i) {\n        var bi = new Bits(bits);\n        gi.table_select[2] = choose_table(ix, a2, i, bi);\n        bits = bi.bits;\n      }\n    } else {\n      gi.region0_count = 7;\n      /* gi.region1_count = SBPSY_l - 7 - 1; */\n\n      gi.region1_count = Encoder.SBMAX_l - 1 - 7 - 1;\n      a1 = gfc.scalefac_band.l[7 + 1];\n      a2 = i;\n\n      if (a1 > a2) {\n        a1 = a2;\n      }\n    }\n    /* have to allow for the case when bigvalues < region0 < region1 */\n\n    /* (and region0, region1 are ignored) */\n\n\n    a1 = Math.min(a1, i);\n    a2 = Math.min(a2, i);\n    assert(a1 >= 0);\n    assert(a2 >= 0);\n    /* Count the number of bits necessary to code the bigvalues region. */\n\n    if (0 < a1) {\n      var bi = new Bits(bits);\n      gi.table_select[0] = choose_table(ix, 0, a1, bi);\n      bits = bi.bits;\n    }\n\n    if (a1 < a2) {\n      var bi = new Bits(bits);\n      gi.table_select[1] = choose_table(ix, a1, a2, bi);\n      bits = bi.bits;\n    }\n\n    if (gfc.use_best_huffman == 2) {\n      gi.part2_3_length = bits;\n      best_huffman_divide(gfc, gi);\n      bits = gi.part2_3_length;\n    }\n\n    if (prev_noise != null) {\n      if (gi.block_type == Encoder.NORM_TYPE) {\n        var sfb = 0;\n\n        while (gfc.scalefac_band.l[sfb] < gi.big_values) {\n          sfb++;\n        }\n\n        prev_noise.sfb_count1 = sfb;\n      }\n    }\n\n    return bits;\n  };\n\n  this.count_bits = function (gfc, xr, gi, prev_noise) {\n    var ix = gi.l3_enc;\n    /* since quantize_xrpow uses table lookup, we need to check this first: */\n\n    var w = QuantizePVT.IXMAX_VAL / qupvt.IPOW20(gi.global_gain);\n    if (gi.xrpow_max > w) return QuantizePVT.LARGE_BITS;\n    quantize_xrpow(xr, ix, qupvt.IPOW20(gi.global_gain), gi, prev_noise);\n\n    if ((gfc.substep_shaping & 2) != 0) {\n      var j = 0;\n      /* 0.634521682242439 = 0.5946*2**(.5*0.1875) */\n\n      var gain = gi.global_gain + gi.scalefac_scale;\n      var roundfac = 0.634521682242439 / qupvt.IPOW20(gain);\n\n      for (var sfb = 0; sfb < gi.sfbmax; sfb++) {\n        var width = gi.width[sfb];\n        assert(width >= 0);\n\n        if (0 == gfc.pseudohalf[sfb]) {\n          j += width;\n        } else {\n          var k;\n\n          for (k = j, j += width; k < j; ++k) {\n            ix[k] = xr[k] >= roundfac ? ix[k] : 0;\n          }\n        }\n      }\n    }\n\n    return this.noquant_count_bits(gfc, gi, prev_noise);\n  };\n  /**\n   * re-calculate the best scalefac_compress using scfsi the saved bits are\n   * kept in the bit reservoir.\n   */\n\n\n  function recalc_divide_init(gfc, cod_info, ix, r01_bits, r01_div, r0_tbl, r1_tbl) {\n    var bigv = cod_info.big_values;\n\n    for (var r0 = 0; r0 <= 7 + 15; r0++) {\n      r01_bits[r0] = QuantizePVT.LARGE_BITS;\n    }\n\n    for (var r0 = 0; r0 < 16; r0++) {\n      var a1 = gfc.scalefac_band.l[r0 + 1];\n      if (a1 >= bigv) break;\n      var r0bits = 0;\n      var bi = new Bits(r0bits);\n      var r0t = choose_table(ix, 0, a1, bi);\n      r0bits = bi.bits;\n\n      for (var r1 = 0; r1 < 8; r1++) {\n        var a2 = gfc.scalefac_band.l[r0 + r1 + 2];\n        if (a2 >= bigv) break;\n        var bits = r0bits;\n        bi = new Bits(bits);\n        var r1t = choose_table(ix, a1, a2, bi);\n        bits = bi.bits;\n\n        if (r01_bits[r0 + r1] > bits) {\n          r01_bits[r0 + r1] = bits;\n          r01_div[r0 + r1] = r0;\n          r0_tbl[r0 + r1] = r0t;\n          r1_tbl[r0 + r1] = r1t;\n        }\n      }\n    }\n  }\n\n  function recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl) {\n    var bigv = cod_info2.big_values;\n\n    for (var r2 = 2; r2 < Encoder.SBMAX_l + 1; r2++) {\n      var a2 = gfc.scalefac_band.l[r2];\n      if (a2 >= bigv) break;\n      var bits = r01_bits[r2 - 2] + cod_info2.count1bits;\n      if (gi.part2_3_length <= bits) break;\n      var bi = new Bits(bits);\n      var r2t = choose_table(ix, a2, bigv, bi);\n      bits = bi.bits;\n      if (gi.part2_3_length <= bits) continue;\n      gi.assign(cod_info2);\n      gi.part2_3_length = bits;\n      gi.region0_count = r01_div[r2 - 2];\n      gi.region1_count = r2 - 2 - r01_div[r2 - 2];\n      gi.table_select[0] = r0_tbl[r2 - 2];\n      gi.table_select[1] = r1_tbl[r2 - 2];\n      gi.table_select[2] = r2t;\n    }\n  }\n\n  this.best_huffman_divide = function (gfc, gi) {\n    var cod_info2 = new GrInfo();\n    var ix = gi.l3_enc;\n    var r01_bits = new_int(7 + 15 + 1);\n    var r01_div = new_int(7 + 15 + 1);\n    var r0_tbl = new_int(7 + 15 + 1);\n    var r1_tbl = new_int(7 + 15 + 1);\n    /* SHORT BLOCK stuff fails for MPEG2 */\n\n    if (gi.block_type == Encoder.SHORT_TYPE && gfc.mode_gr == 1) return;\n    cod_info2.assign(gi);\n\n    if (gi.block_type == Encoder.NORM_TYPE) {\n      recalc_divide_init(gfc, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl);\n      recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl);\n    }\n\n    var i = cod_info2.big_values;\n    if (i == 0 || (ix[i - 2] | ix[i - 1]) > 1) return;\n    i = gi.count1 + 2;\n    if (i > 576) return;\n    /* Determines the number of bits to encode the quadruples. */\n\n    cod_info2.assign(gi);\n    cod_info2.count1 = i;\n    var a1 = 0;\n    var a2 = 0;\n    assert(i <= 576);\n\n    for (; i > cod_info2.big_values; i -= 4) {\n      var p = ((ix[i - 4] * 2 + ix[i - 3]) * 2 + ix[i - 2]) * 2 + ix[i - 1];\n      a1 += Tables.t32l[p];\n      a2 += Tables.t33l[p];\n    }\n\n    cod_info2.big_values = i;\n    cod_info2.count1table_select = 0;\n\n    if (a1 > a2) {\n      a1 = a2;\n      cod_info2.count1table_select = 1;\n    }\n\n    cod_info2.count1bits = a1;\n    if (cod_info2.block_type == Encoder.NORM_TYPE) recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl);else {\n      /* Count the number of bits necessary to code the bigvalues region. */\n      cod_info2.part2_3_length = a1;\n      a1 = gfc.scalefac_band.l[7 + 1];\n\n      if (a1 > i) {\n        a1 = i;\n      }\n\n      if (a1 > 0) {\n        var bi = new Bits(cod_info2.part2_3_length);\n        cod_info2.table_select[0] = choose_table(ix, 0, a1, bi);\n        cod_info2.part2_3_length = bi.bits;\n      }\n\n      if (i > a1) {\n        var bi = new Bits(cod_info2.part2_3_length);\n        cod_info2.table_select[1] = choose_table(ix, a1, i, bi);\n        cod_info2.part2_3_length = bi.bits;\n      }\n\n      if (gi.part2_3_length > cod_info2.part2_3_length) gi.assign(cod_info2);\n    }\n  };\n\n  var slen1_n = [1, 1, 1, 1, 8, 2, 2, 2, 4, 4, 4, 8, 8, 8, 16, 16];\n  var slen2_n = [1, 2, 4, 8, 1, 2, 4, 8, 2, 4, 8, 2, 4, 8, 4, 8];\n  var slen1_tab = [0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4];\n  var slen2_tab = [0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3];\n  Takehiro.slen1_tab = slen1_tab;\n  Takehiro.slen2_tab = slen2_tab;\n\n  function scfsi_calc(ch, l3_side) {\n    var sfb;\n    var gi = l3_side.tt[1][ch];\n    var g0 = l3_side.tt[0][ch];\n\n    for (var i = 0; i < Tables.scfsi_band.length - 1; i++) {\n      for (sfb = Tables.scfsi_band[i]; sfb < Tables.scfsi_band[i + 1]; sfb++) {\n        if (g0.scalefac[sfb] != gi.scalefac[sfb] && gi.scalefac[sfb] >= 0) break;\n      }\n\n      if (sfb == Tables.scfsi_band[i + 1]) {\n        for (sfb = Tables.scfsi_band[i]; sfb < Tables.scfsi_band[i + 1]; sfb++) {\n          gi.scalefac[sfb] = -1;\n        }\n\n        l3_side.scfsi[ch][i] = 1;\n      }\n    }\n\n    var s1 = 0;\n    var c1 = 0;\n\n    for (sfb = 0; sfb < 11; sfb++) {\n      if (gi.scalefac[sfb] == -1) continue;\n      c1++;\n      if (s1 < gi.scalefac[sfb]) s1 = gi.scalefac[sfb];\n    }\n\n    var s2 = 0;\n    var c2 = 0;\n\n    for (; sfb < Encoder.SBPSY_l; sfb++) {\n      if (gi.scalefac[sfb] == -1) continue;\n      c2++;\n      if (s2 < gi.scalefac[sfb]) s2 = gi.scalefac[sfb];\n    }\n\n    for (var i = 0; i < 16; i++) {\n      if (s1 < slen1_n[i] && s2 < slen2_n[i]) {\n        var c = slen1_tab[i] * c1 + slen2_tab[i] * c2;\n\n        if (gi.part2_length > c) {\n          gi.part2_length = c;\n          gi.scalefac_compress = i;\n        }\n      }\n    }\n  }\n  /**\n   * Find the optimal way to store the scalefactors. Only call this routine\n   * after final scalefactors have been chosen and the channel/granule will\n   * not be re-encoded.\n   */\n\n\n  this.best_scalefac_store = function (gfc, gr, ch, l3_side) {\n    /* use scalefac_scale if we can */\n    var gi = l3_side.tt[gr][ch];\n    var sfb, i, j, l;\n    var recalc = 0;\n    /*\n     * remove scalefacs from bands with ix=0. This idea comes from the AAC\n     * ISO docs. added mt 3/00\n     */\n\n    /* check if l3_enc=0 */\n\n    j = 0;\n\n    for (sfb = 0; sfb < gi.sfbmax; sfb++) {\n      var width = gi.width[sfb];\n      assert(width >= 0);\n      j += width;\n\n      for (l = -width; l < 0; l++) {\n        if (gi.l3_enc[l + j] != 0) break;\n      }\n\n      if (l == 0) gi.scalefac[sfb] = recalc = -2;\n      /* anything goes. */\n\n      /*\n       * only best_scalefac_store and calc_scfsi know--and only they\n       * should know--about the magic number -2.\n       */\n    }\n\n    if (0 == gi.scalefac_scale && 0 == gi.preflag) {\n      var s = 0;\n\n      for (sfb = 0; sfb < gi.sfbmax; sfb++) if (gi.scalefac[sfb] > 0) s |= gi.scalefac[sfb];\n\n      if (0 == (s & 1) && s != 0) {\n        for (sfb = 0; sfb < gi.sfbmax; sfb++) if (gi.scalefac[sfb] > 0) gi.scalefac[sfb] >>= 1;\n\n        gi.scalefac_scale = recalc = 1;\n      }\n    }\n\n    if (0 == gi.preflag && gi.block_type != Encoder.SHORT_TYPE && gfc.mode_gr == 2) {\n      for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++) if (gi.scalefac[sfb] < qupvt.pretab[sfb] && gi.scalefac[sfb] != -2) break;\n\n      if (sfb == Encoder.SBPSY_l) {\n        for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++) if (gi.scalefac[sfb] > 0) gi.scalefac[sfb] -= qupvt.pretab[sfb];\n\n        gi.preflag = recalc = 1;\n      }\n    }\n\n    for (i = 0; i < 4; i++) l3_side.scfsi[ch][i] = 0;\n\n    if (gfc.mode_gr == 2 && gr == 1 && l3_side.tt[0][ch].block_type != Encoder.SHORT_TYPE && l3_side.tt[1][ch].block_type != Encoder.SHORT_TYPE) {\n      scfsi_calc(ch, l3_side);\n      recalc = 0;\n    }\n\n    for (sfb = 0; sfb < gi.sfbmax; sfb++) {\n      if (gi.scalefac[sfb] == -2) {\n        gi.scalefac[sfb] = 0;\n        /* if anything goes, then 0 is a good choice */\n      }\n    }\n\n    if (recalc != 0) {\n      if (gfc.mode_gr == 2) {\n        this.scale_bitcount(gi);\n      } else {\n        this.scale_bitcount_lsf(gfc, gi);\n      }\n    }\n  };\n\n  function all_scalefactors_not_negative(scalefac, n) {\n    for (var i = 0; i < n; ++i) {\n      if (scalefac[i] < 0) return false;\n    }\n\n    return true;\n  }\n  /**\n   * number of bits used to encode scalefacs.\n   *\n   * 18*slen1_tab[i] + 18*slen2_tab[i]\n   */\n\n\n  var scale_short = [0, 18, 36, 54, 54, 36, 54, 72, 54, 72, 90, 72, 90, 108, 108, 126];\n  /**\n   * number of bits used to encode scalefacs.\n   *\n   * 17*slen1_tab[i] + 18*slen2_tab[i]\n   */\n\n  var scale_mixed = [0, 18, 36, 54, 51, 35, 53, 71, 52, 70, 88, 69, 87, 105, 104, 122];\n  /**\n   * number of bits used to encode scalefacs.\n   *\n   * 11*slen1_tab[i] + 10*slen2_tab[i]\n   */\n\n  var scale_long = [0, 10, 20, 30, 33, 21, 31, 41, 32, 42, 52, 43, 53, 63, 64, 74];\n  /**\n   * Also calculates the number of bits necessary to code the scalefactors.\n   */\n\n  this.scale_bitcount = function (cod_info) {\n    var k,\n        sfb,\n        max_slen1 = 0,\n        max_slen2 = 0;\n    /* maximum values */\n\n    var tab;\n    var scalefac = cod_info.scalefac;\n    assert(all_scalefactors_not_negative(scalefac, cod_info.sfbmax));\n\n    if (cod_info.block_type == Encoder.SHORT_TYPE) {\n      tab = scale_short;\n      if (cod_info.mixed_block_flag != 0) tab = scale_mixed;\n    } else {\n      /* block_type == 1,2,or 3 */\n      tab = scale_long;\n\n      if (0 == cod_info.preflag) {\n        for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++) if (scalefac[sfb] < qupvt.pretab[sfb]) break;\n\n        if (sfb == Encoder.SBPSY_l) {\n          cod_info.preflag = 1;\n\n          for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++) scalefac[sfb] -= qupvt.pretab[sfb];\n        }\n      }\n    }\n\n    for (sfb = 0; sfb < cod_info.sfbdivide; sfb++) if (max_slen1 < scalefac[sfb]) max_slen1 = scalefac[sfb];\n\n    for (; sfb < cod_info.sfbmax; sfb++) if (max_slen2 < scalefac[sfb]) max_slen2 = scalefac[sfb];\n    /*\n     * from Takehiro TOMINAGA <tominaga@isoternet.org> 10/99 loop over *all*\n     * posible values of scalefac_compress to find the one which uses the\n     * smallest number of bits. ISO would stop at first valid index\n     */\n\n\n    cod_info.part2_length = QuantizePVT.LARGE_BITS;\n\n    for (k = 0; k < 16; k++) {\n      if (max_slen1 < slen1_n[k] && max_slen2 < slen2_n[k] && cod_info.part2_length > tab[k]) {\n        cod_info.part2_length = tab[k];\n        cod_info.scalefac_compress = k;\n      }\n    }\n\n    return cod_info.part2_length == QuantizePVT.LARGE_BITS;\n  };\n  /**\n   * table of largest scalefactor values for MPEG2\n   */\n\n\n  var max_range_sfac_tab = [[15, 15, 7, 7], [15, 15, 7, 0], [7, 3, 0, 0], [15, 31, 31, 0], [7, 7, 7, 0], [3, 3, 0, 0]];\n  /**\n   * Also counts the number of bits to encode the scalefacs but for MPEG 2\n   * Lower sampling frequencies (24, 22.05 and 16 kHz.)\n   *\n   * This is reverse-engineered from section 2.4.3.2 of the MPEG2 IS,\n   * \"Audio Decoding Layer III\"\n   */\n\n  this.scale_bitcount_lsf = function (gfc, cod_info) {\n    var table_number, row_in_table, partition, nr_sfb, window;\n    var over;\n    var i, sfb;\n    var max_sfac = new_int(4); //var partition_table;\n\n    var scalefac = cod_info.scalefac;\n    /*\n     * Set partition table. Note that should try to use table one, but do\n     * not yet...\n     */\n\n    if (cod_info.preflag != 0) table_number = 2;else table_number = 0;\n\n    for (i = 0; i < 4; i++) max_sfac[i] = 0;\n\n    if (cod_info.block_type == Encoder.SHORT_TYPE) {\n      row_in_table = 1;\n      var partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];\n\n      for (sfb = 0, partition = 0; partition < 4; partition++) {\n        nr_sfb = partition_table[partition] / 3;\n\n        for (i = 0; i < nr_sfb; i++, sfb++) for (window = 0; window < 3; window++) if (scalefac[sfb * 3 + window] > max_sfac[partition]) max_sfac[partition] = scalefac[sfb * 3 + window];\n      }\n    } else {\n      row_in_table = 0;\n      var partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];\n\n      for (sfb = 0, partition = 0; partition < 4; partition++) {\n        nr_sfb = partition_table[partition];\n\n        for (i = 0; i < nr_sfb; i++, sfb++) if (scalefac[sfb] > max_sfac[partition]) max_sfac[partition] = scalefac[sfb];\n      }\n    }\n\n    for (over = false, partition = 0; partition < 4; partition++) {\n      if (max_sfac[partition] > max_range_sfac_tab[table_number][partition]) over = true;\n    }\n\n    if (!over) {\n      var slen1, slen2, slen3, slen4;\n      cod_info.sfb_partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];\n\n      for (partition = 0; partition < 4; partition++) cod_info.slen[partition] = log2tab[max_sfac[partition]];\n      /* set scalefac_compress */\n\n\n      slen1 = cod_info.slen[0];\n      slen2 = cod_info.slen[1];\n      slen3 = cod_info.slen[2];\n      slen4 = cod_info.slen[3];\n\n      switch (table_number) {\n        case 0:\n          cod_info.scalefac_compress = (slen1 * 5 + slen2 << 4) + (slen3 << 2) + slen4;\n          break;\n\n        case 1:\n          cod_info.scalefac_compress = 400 + (slen1 * 5 + slen2 << 2) + slen3;\n          break;\n\n        case 2:\n          cod_info.scalefac_compress = 500 + slen1 * 3 + slen2;\n          break;\n\n        default:\n          System.err.printf(\"intensity stereo not implemented yet\\n\");\n          break;\n      }\n    }\n\n    if (!over) {\n      assert(cod_info.sfb_partition_table != null);\n      cod_info.part2_length = 0;\n\n      for (partition = 0; partition < 4; partition++) cod_info.part2_length += cod_info.slen[partition] * cod_info.sfb_partition_table[partition];\n    }\n\n    return over;\n  };\n  /*\n   * Since no bands have been over-amplified, we can set scalefac_compress and\n   * slen[] for the formatter\n   */\n\n\n  var log2tab = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4];\n\n  this.huffman_init = function (gfc) {\n    for (var i = 2; i <= 576; i += 2) {\n      var scfb_anz = 0,\n          bv_index;\n\n      while (gfc.scalefac_band.l[++scfb_anz] < i);\n\n      bv_index = subdv_table[scfb_anz][0]; // .region0_count\n\n      while (gfc.scalefac_band.l[bv_index + 1] > i) bv_index--;\n\n      if (bv_index < 0) {\n        /*\n         * this is an indication that everything is going to be encoded\n         * as region0: bigvalues < region0 < region1 so lets set\n         * region0, region1 to some value larger than bigvalues\n         */\n        bv_index = subdv_table[scfb_anz][0]; // .region0_count\n      }\n\n      gfc.bv_scf[i - 2] = bv_index;\n      bv_index = subdv_table[scfb_anz][1]; // .region1_count\n\n      while (gfc.scalefac_band.l[bv_index + gfc.bv_scf[i - 2] + 2] > i) bv_index--;\n\n      if (bv_index < 0) {\n        bv_index = subdv_table[scfb_anz][1]; // .region1_count\n      }\n\n      gfc.bv_scf[i - 1] = bv_index;\n    }\n  };\n}\n\nmodule.exports = Takehiro;","map":null,"metadata":{},"sourceType":"script"}