{"ast":null,"code":"function new_byte(count) {\n  return new Int8Array(count);\n}\n\nfunction new_short(count) {\n  return new Int16Array(count);\n}\n\nfunction new_int(count) {\n  return new Int32Array(count);\n}\n\nfunction new_float(count) {\n  return new Float32Array(count);\n}\n\nfunction new_double(count) {\n  return new Float64Array(count);\n}\n\nfunction new_float_n(args) {\n  if (args.length == 1) {\n    return new_float(args[0]);\n  }\n\n  var sz = args[0];\n  args = args.slice(1);\n  var A = [];\n\n  for (var i = 0; i < sz; i++) {\n    A.push(new_float_n(args));\n  }\n\n  return A;\n}\n\nfunction new_int_n(args) {\n  if (args.length == 1) {\n    return new_int(args[0]);\n  }\n\n  var sz = args[0];\n  args = args.slice(1);\n  var A = [];\n\n  for (var i = 0; i < sz; i++) {\n    A.push(new_int_n(args));\n  }\n\n  return A;\n}\n\nfunction new_short_n(args) {\n  if (args.length == 1) {\n    return new_short(args[0]);\n  }\n\n  var sz = args[0];\n  args = args.slice(1);\n  var A = [];\n\n  for (var i = 0; i < sz; i++) {\n    A.push(new_short_n(args));\n  }\n\n  return A;\n}\n\nfunction new_array_n(args) {\n  if (args.length == 1) {\n    return new Array(args[0]);\n  }\n\n  var sz = args[0];\n  args = args.slice(1);\n  var A = [];\n\n  for (var i = 0; i < sz; i++) {\n    A.push(new_array_n(args));\n  }\n\n  return A;\n}\n\nvar Arrays = {};\n\nArrays.fill = function (a, fromIndex, toIndex, val) {\n  if (arguments.length == 2) {\n    for (var i = 0; i < a.length; i++) {\n      a[i] = arguments[1];\n    }\n  } else {\n    for (var i = fromIndex; i < toIndex; i++) {\n      a[i] = val;\n    }\n  }\n};\n\nvar System = {};\n\nSystem.arraycopy = function (src, srcPos, dest, destPos, length) {\n  var srcEnd = srcPos + length;\n\n  while (srcPos < srcEnd) dest[destPos++] = src[srcPos++];\n};\n\nvar Util = {};\nUtil.SQRT2 = 1.41421356237309504880;\n\nUtil.FAST_LOG10 = function (x) {\n  return Math.log10(x);\n};\n\nUtil.FAST_LOG10_X = function (x, y) {\n  return Math.log10(x) * y;\n};\n\nfunction ShortBlock(ordinal) {\n  this.ordinal = ordinal;\n}\n/**\n * LAME may use them, even different block types for L/R.\n */\n\n\nShortBlock.short_block_allowed = new ShortBlock(0);\n/**\n * LAME may use them, but always same block types in L/R.\n */\n\nShortBlock.short_block_coupled = new ShortBlock(1);\n/**\n * LAME will not use short blocks, long blocks only.\n */\n\nShortBlock.short_block_dispensed = new ShortBlock(2);\n/**\n * LAME will not use long blocks, short blocks only.\n */\n\nShortBlock.short_block_forced = new ShortBlock(3);\nvar Float = {};\nFloat.MAX_VALUE = 3.4028235e+38;\n\nfunction VbrMode(ordinal) {\n  this.ordinal = ordinal;\n}\n\nVbrMode.vbr_off = new VbrMode(0);\nVbrMode.vbr_mt = new VbrMode(1);\nVbrMode.vbr_rh = new VbrMode(2);\nVbrMode.vbr_abr = new VbrMode(3);\nVbrMode.vbr_mtrh = new VbrMode(4);\nVbrMode.vbr_default = VbrMode.vbr_mtrh;\n\nvar assert = function (x) {//console.assert(x);\n};\n\nmodule.exports = {\n  \"System\": System,\n  \"VbrMode\": VbrMode,\n  \"Float\": Float,\n  \"ShortBlock\": ShortBlock,\n  \"Util\": Util,\n  \"Arrays\": Arrays,\n  \"new_array_n\": new_array_n,\n  \"new_byte\": new_byte,\n  \"new_double\": new_double,\n  \"new_float\": new_float,\n  \"new_float_n\": new_float_n,\n  \"new_int\": new_int,\n  \"new_int_n\": new_int_n,\n  \"new_short\": new_short,\n  \"new_short_n\": new_short_n,\n  \"assert\": assert\n};","map":null,"metadata":{},"sourceType":"script"}