{"ast":null,"code":"var common = require('./common.js');\n\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n/**\n * A Vbr header may be present in the ancillary data field of the first frame of\n * an mp3 bitstream<BR>\n * The Vbr header (optionally) contains\n * <UL>\n * <LI>frames total number of audio frames in the bitstream\n * <LI>bytes total number of bytes in the bitstream\n * <LI>toc table of contents\n * </UL>\n *\n * toc (table of contents) gives seek points for random access.<BR>\n * The ith entry determines the seek point for i-percent duration.<BR>\n * seek point in bytes = (toc[i]/256.0) * total_bitstream_bytes<BR>\n * e.g. half duration seek point = (toc[50]/256.0) * total_bitstream_bytes\n */\n\nVBRTag.NUMTOCENTRIES = 100;\nVBRTag.MAXFRAMESIZE = 2880;\n\nfunction VBRTag() {\n  var lame;\n  var bs;\n  var v;\n\n  this.setModules = function (_lame, _bs, _v) {\n    lame = _lame;\n    bs = _bs;\n    v = _v;\n  };\n\n  var FRAMES_FLAG = 0x0001;\n  var BYTES_FLAG = 0x0002;\n  var TOC_FLAG = 0x0004;\n  var VBR_SCALE_FLAG = 0x0008;\n  var NUMTOCENTRIES = VBRTag.NUMTOCENTRIES;\n  /**\n   * (0xB40) the max freeformat 640 32kHz framesize.\n   */\n\n  var MAXFRAMESIZE = VBRTag.MAXFRAMESIZE;\n  /**\n   * <PRE>\n   *    4 bytes for Header Tag\n   *    4 bytes for Header Flags\n   *  100 bytes for entry (toc)\n   *    4 bytes for frame size\n   *    4 bytes for stream size\n   *    4 bytes for VBR scale. a VBR quality indicator: 0=best 100=worst\n   *   20 bytes for LAME tag.  for example, \"LAME3.12 (beta 6)\"\n   * ___________\n   *  140 bytes\n   * </PRE>\n   */\n\n  var VBRHEADERSIZE = NUMTOCENTRIES + 4 + 4 + 4 + 4 + 4;\n  var LAMEHEADERSIZE = VBRHEADERSIZE + 9 + 1 + 1 + 8 + 1 + 1 + 3 + 1 + 1 + 2 + 4 + 2 + 2;\n  /**\n   * The size of the Xing header MPEG-1, bit rate in kbps.\n   */\n\n  var XING_BITRATE1 = 128;\n  /**\n   * The size of the Xing header MPEG-2, bit rate in kbps.\n   */\n\n  var XING_BITRATE2 = 64;\n  /**\n   * The size of the Xing header MPEG-2.5, bit rate in kbps.\n   */\n\n  var XING_BITRATE25 = 32;\n  /**\n   * ISO-8859-1 charset for byte to string operations.\n   */\n\n  var ISO_8859_1 = null; //Charset.forName(\"ISO-8859-1\");\n\n  /**\n   * VBR header magic string.\n   */\n\n  var VBRTag0 = \"Xing\";\n  /**\n   * VBR header magic string (VBR == VBRMode.vbr_off).\n   */\n\n  var VBRTag1 = \"Info\";\n  /**\n   * Lookup table for fast CRC-16 computation. Uses the polynomial\n   * x^16+x^15+x^2+1\n   */\n\n  var crc16Lookup = [0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440, 0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841, 0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040, 0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441, 0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40, 0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041, 0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441, 0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440, 0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841, 0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41, 0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040];\n  /***********************************************************************\n   * Robert Hegemann 2001-01-17\n   ***********************************************************************/\n\n  function addVbr(v, bitrate) {\n    v.nVbrNumFrames++;\n    v.sum += bitrate;\n    v.seen++;\n\n    if (v.seen < v.want) {\n      return;\n    }\n\n    if (v.pos < v.size) {\n      v.bag[v.pos] = v.sum;\n      v.pos++;\n      v.seen = 0;\n    }\n\n    if (v.pos == v.size) {\n      for (var i = 1; i < v.size; i += 2) {\n        v.bag[i / 2] = v.bag[i];\n      }\n\n      v.want *= 2;\n      v.pos /= 2;\n    }\n  }\n\n  function xingSeekTable(v, t) {\n    if (v.pos <= 0) return;\n\n    for (var i = 1; i < NUMTOCENTRIES; ++i) {\n      var j = i / NUMTOCENTRIES,\n          act,\n          sum;\n      var indx = 0 | Math.floor(j * v.pos);\n      if (indx > v.pos - 1) indx = v.pos - 1;\n      act = v.bag[indx];\n      sum = v.sum;\n      var seek_point = 0 | 256. * act / sum;\n      if (seek_point > 255) seek_point = 255;\n      t[i] = 0xff & seek_point;\n    }\n  }\n  /**\n   * Add VBR entry, used to fill the VBR TOC entries.\n   *\n   * @param gfp\n   *            global flags\n   */\n\n\n  this.addVbrFrame = function (gfp) {\n    var gfc = gfp.internal_flags;\n    var kbps = Tables.bitrate_table[gfp.version][gfc.bitrate_index];\n    assert(gfc.VBR_seek_table.bag != null);\n    addVbr(gfc.VBR_seek_table, kbps);\n  };\n  /**\n   * Read big endian integer (4-bytes) from header.\n   *\n   * @param buf\n   *            header containing the integer\n   * @param bufPos\n   *            offset into the header\n   * @return extracted integer\n   */\n\n\n  function extractInteger(buf, bufPos) {\n    var x = buf[bufPos + 0] & 0xff;\n    x <<= 8;\n    x |= buf[bufPos + 1] & 0xff;\n    x <<= 8;\n    x |= buf[bufPos + 2] & 0xff;\n    x <<= 8;\n    x |= buf[bufPos + 3] & 0xff;\n    return x;\n  }\n  /**\n   * Write big endian integer (4-bytes) in the header.\n   *\n   * @param buf\n   *            header to write the integer into\n   * @param bufPos\n   *            offset into the header\n   * @param value\n   *            integer value to write\n   */\n\n\n  function createInteger(buf, bufPos, value) {\n    buf[bufPos + 0] = 0xff & (value >> 24 & 0xff);\n    buf[bufPos + 1] = 0xff & (value >> 16 & 0xff);\n    buf[bufPos + 2] = 0xff & (value >> 8 & 0xff);\n    buf[bufPos + 3] = 0xff & (value & 0xff);\n  }\n  /**\n   * Write big endian short (2-bytes) in the header.\n   *\n   * @param buf\n   *            header to write the integer into\n   * @param bufPos\n   *            offset into the header\n   * @param value\n   *            integer value to write\n   */\n\n\n  function createShort(buf, bufPos, value) {\n    buf[bufPos + 0] = 0xff & (value >> 8 & 0xff);\n    buf[bufPos + 1] = 0xff & (value & 0xff);\n  }\n  /**\n   * Check for magic strings (Xing/Info).\n   *\n   * @param buf\n   *            header to check\n   * @param bufPos\n   *            header offset to check\n   * @return magic string found\n   */\n\n\n  function isVbrTag(buf, bufPos) {\n    return new String(buf, bufPos, VBRTag0.length(), ISO_8859_1).equals(VBRTag0) || new String(buf, bufPos, VBRTag1.length(), ISO_8859_1).equals(VBRTag1);\n  }\n\n  function shiftInBitsValue(x, n, v) {\n    return 0xff & (x << n | v & ~(-1 << n));\n  }\n  /**\n   * Construct the MP3 header using the settings of the global flags.\n   *\n   * <img src=\"1000px-Mp3filestructure.svg.png\">\n   *\n   * @param gfp\n   *            global flags\n   * @param buffer\n   *            header\n   */\n\n\n  function setLameTagFrameHeader(gfp, buffer) {\n    var gfc = gfp.internal_flags; // MP3 Sync Word\n\n    buffer[0] = shiftInBitsValue(buffer[0], 8, 0xff);\n    buffer[1] = shiftInBitsValue(buffer[1], 3, 7);\n    buffer[1] = shiftInBitsValue(buffer[1], 1, gfp.out_samplerate < 16000 ? 0 : 1); // Version\n\n    buffer[1] = shiftInBitsValue(buffer[1], 1, gfp.version); // 01 == Layer 3\n\n    buffer[1] = shiftInBitsValue(buffer[1], 2, 4 - 3); // Error protection\n\n    buffer[1] = shiftInBitsValue(buffer[1], 1, !gfp.error_protection ? 1 : 0); // Bit rate\n\n    buffer[2] = shiftInBitsValue(buffer[2], 4, gfc.bitrate_index); // Frequency\n\n    buffer[2] = shiftInBitsValue(buffer[2], 2, gfc.samplerate_index); // Pad. Bit\n\n    buffer[2] = shiftInBitsValue(buffer[2], 1, 0); // Priv. Bit\n\n    buffer[2] = shiftInBitsValue(buffer[2], 1, gfp.extension); // Mode\n\n    buffer[3] = shiftInBitsValue(buffer[3], 2, gfp.mode.ordinal()); // Mode extension (Used with Joint Stereo)\n\n    buffer[3] = shiftInBitsValue(buffer[3], 2, gfc.mode_ext); // Copy\n\n    buffer[3] = shiftInBitsValue(buffer[3], 1, gfp.copyright); // Original\n\n    buffer[3] = shiftInBitsValue(buffer[3], 1, gfp.original); // Emphasis\n\n    buffer[3] = shiftInBitsValue(buffer[3], 2, gfp.emphasis);\n    /* the default VBR header. 48 kbps layer III, no padding, no crc */\n\n    /* but sampling freq, mode and copyright/copy protection taken */\n\n    /* from first valid frame */\n\n    buffer[0] = 0xff;\n    var abyte = 0xff & (buffer[1] & 0xf1);\n    var bitrate;\n\n    if (1 == gfp.version) {\n      bitrate = XING_BITRATE1;\n    } else {\n      if (gfp.out_samplerate < 16000) bitrate = XING_BITRATE25;else bitrate = XING_BITRATE2;\n    }\n\n    if (gfp.VBR == VbrMode.vbr_off) bitrate = gfp.brate;\n    var bbyte;\n    if (gfp.free_format) bbyte = 0x00;else bbyte = 0xff & 16 * lame.BitrateIndex(bitrate, gfp.version, gfp.out_samplerate);\n    /*\n     * Use as much of the info from the real frames in the Xing header:\n     * samplerate, channels, crc, etc...\n     */\n\n    if (gfp.version == 1) {\n      /* MPEG1 */\n      buffer[1] = 0xff & (abyte | 0x0a);\n      /* was 0x0b; */\n\n      abyte = 0xff & (buffer[2] & 0x0d);\n      /* AF keep also private bit */\n\n      buffer[2] = 0xff & (bbyte | abyte);\n      /* 64kbs MPEG1 frame */\n    } else {\n      /* MPEG2 */\n      buffer[1] = 0xff & (abyte | 0x02);\n      /* was 0x03; */\n\n      abyte = 0xff & (buffer[2] & 0x0d);\n      /* AF keep also private bit */\n\n      buffer[2] = 0xff & (bbyte | abyte);\n      /* 64kbs MPEG2 frame */\n    }\n  }\n  /**\n   * Get VBR tag information\n   *\n   * @param buf\n   *            header to analyze\n   * @param bufPos\n   *            offset into the header\n   * @return VBR tag data\n   */\n\n\n  this.getVbrTag = function (buf) {\n    var pTagData = new VBRTagData();\n    var bufPos = 0;\n    /* get Vbr header data */\n\n    pTagData.flags = 0;\n    /* get selected MPEG header data */\n\n    var hId = buf[bufPos + 1] >> 3 & 1;\n    var hSrIndex = buf[bufPos + 2] >> 2 & 3;\n    var hMode = buf[bufPos + 3] >> 6 & 3;\n    var hBitrate = buf[bufPos + 2] >> 4 & 0xf;\n    hBitrate = Tables.bitrate_table[hId][hBitrate];\n    /* check for FFE syncword */\n\n    if (buf[bufPos + 1] >> 4 == 0xE) pTagData.samprate = Tables.samplerate_table[2][hSrIndex];else pTagData.samprate = Tables.samplerate_table[hId][hSrIndex];\n    /* determine offset of header */\n\n    if (hId != 0) {\n      /* mpeg1 */\n      if (hMode != 3) bufPos += 32 + 4;else bufPos += 17 + 4;\n    } else {\n      /* mpeg2 */\n      if (hMode != 3) bufPos += 17 + 4;else bufPos += 9 + 4;\n    }\n\n    if (!isVbrTag(buf, bufPos)) return null;\n    bufPos += 4;\n    pTagData.hId = hId;\n    /* get flags */\n\n    var head_flags = pTagData.flags = extractInteger(buf, bufPos);\n    bufPos += 4;\n\n    if ((head_flags & FRAMES_FLAG) != 0) {\n      pTagData.frames = extractInteger(buf, bufPos);\n      bufPos += 4;\n    }\n\n    if ((head_flags & BYTES_FLAG) != 0) {\n      pTagData.bytes = extractInteger(buf, bufPos);\n      bufPos += 4;\n    }\n\n    if ((head_flags & TOC_FLAG) != 0) {\n      if (pTagData.toc != null) {\n        for (var i = 0; i < NUMTOCENTRIES; i++) pTagData.toc[i] = buf[bufPos + i];\n      }\n\n      bufPos += NUMTOCENTRIES;\n    }\n\n    pTagData.vbrScale = -1;\n\n    if ((head_flags & VBR_SCALE_FLAG) != 0) {\n      pTagData.vbrScale = extractInteger(buf, bufPos);\n      bufPos += 4;\n    }\n\n    pTagData.headersize = (hId + 1) * 72000 * hBitrate / pTagData.samprate;\n    bufPos += 21;\n    var encDelay = buf[bufPos + 0] << 4;\n    encDelay += buf[bufPos + 1] >> 4;\n    var encPadding = (buf[bufPos + 1] & 0x0F) << 8;\n    encPadding += buf[bufPos + 2] & 0xff;\n    /* check for reasonable values (this may be an old Xing header, */\n\n    /* not a INFO tag) */\n\n    if (encDelay < 0 || encDelay > 3000) encDelay = -1;\n    if (encPadding < 0 || encPadding > 3000) encPadding = -1;\n    pTagData.encDelay = encDelay;\n    pTagData.encPadding = encPadding;\n    /* success */\n\n    return pTagData;\n  };\n  /**\n   * Initializes the header\n   *\n   * @param gfp\n   *            global flags\n   */\n\n\n  this.InitVbrTag = function (gfp) {\n    var gfc = gfp.internal_flags;\n    /**\n     * <PRE>\n     * Xing VBR pretends to be a 48kbs layer III frame.  (at 44.1kHz).\n     * (at 48kHz they use 56kbs since 48kbs frame not big enough for\n     * table of contents)\n     * let's always embed Xing header inside a 64kbs layer III frame.\n     * this gives us enough room for a LAME version string too.\n     * size determined by sampling frequency (MPEG1)\n     * 32kHz:    216 bytes@48kbs    288bytes@ 64kbs\n     * 44.1kHz:  156 bytes          208bytes@64kbs     (+1 if padding = 1)\n     * 48kHz:    144 bytes          192\n     *\n     * MPEG 2 values are the same since the framesize and samplerate\n     * are each reduced by a factor of 2.\n     * </PRE>\n     */\n\n    var kbps_header;\n\n    if (1 == gfp.version) {\n      kbps_header = XING_BITRATE1;\n    } else {\n      if (gfp.out_samplerate < 16000) kbps_header = XING_BITRATE25;else kbps_header = XING_BITRATE2;\n    }\n\n    if (gfp.VBR == VbrMode.vbr_off) kbps_header = gfp.brate; // make sure LAME Header fits into Frame\n\n    var totalFrameSize = (gfp.version + 1) * 72000 * kbps_header / gfp.out_samplerate;\n    var headerSize = gfc.sideinfo_len + LAMEHEADERSIZE;\n    gfc.VBR_seek_table.TotalFrameSize = totalFrameSize;\n\n    if (totalFrameSize < headerSize || totalFrameSize > MAXFRAMESIZE) {\n      /* disable tag, it wont fit */\n      gfp.bWriteVbrTag = false;\n      return;\n    }\n\n    gfc.VBR_seek_table.nVbrNumFrames = 0;\n    gfc.VBR_seek_table.nBytesWritten = 0;\n    gfc.VBR_seek_table.sum = 0;\n    gfc.VBR_seek_table.seen = 0;\n    gfc.VBR_seek_table.want = 1;\n    gfc.VBR_seek_table.pos = 0;\n\n    if (gfc.VBR_seek_table.bag == null) {\n      gfc.VBR_seek_table.bag = new int[400]();\n      gfc.VBR_seek_table.size = 400;\n    } // write dummy VBR tag of all 0's into bitstream\n\n\n    var buffer = new_byte(MAXFRAMESIZE);\n    setLameTagFrameHeader(gfp, buffer);\n    var n = gfc.VBR_seek_table.TotalFrameSize;\n\n    for (var i = 0; i < n; ++i) {\n      bs.add_dummy_byte(gfp, buffer[i] & 0xff, 1);\n    }\n  };\n  /**\n   * Fast CRC-16 computation (uses table crc16Lookup).\n   *\n   * @param value\n   * @param crc\n   * @return\n   */\n\n\n  function crcUpdateLookup(value, crc) {\n    var tmp = crc ^ value;\n    crc = crc >> 8 ^ crc16Lookup[tmp & 0xff];\n    return crc;\n  }\n\n  this.updateMusicCRC = function (crc, buffer, bufferPos, size) {\n    for (var i = 0; i < size; ++i) crc[0] = crcUpdateLookup(buffer[bufferPos + i], crc[0]);\n  };\n  /**\n   * Write LAME info: mini version + info on various switches used (Jonathan\n   * Dee 2001/08/31).\n   *\n   * @param gfp\n   *            global flags\n   * @param musicLength\n   *            music length\n   * @param streamBuffer\n   *            pointer to output buffer\n   * @param streamBufferPos\n   *            offset into the output buffer\n   * @param crc\n   *            computation of CRC-16 of Lame Tag so far (starting at frame\n   *            sync)\n   * @return number of bytes written to the stream\n   */\n\n\n  function putLameVBR(gfp, musicLength, streamBuffer, streamBufferPos, crc) {\n    var gfc = gfp.internal_flags;\n    var bytesWritten = 0;\n    /* encoder delay */\n\n    var encDelay = gfp.encoder_delay;\n    /* encoder padding */\n\n    var encPadding = gfp.encoder_padding;\n    /* recall: gfp.VBR_q is for example set by the switch -V */\n\n    /* gfp.quality by -q, -h, -f, etc */\n\n    var quality = 100 - 10 * gfp.VBR_q - gfp.quality;\n    var version = v.getLameVeryShortVersion();\n    var vbr;\n    var revision = 0x00;\n    var revMethod; // numbering different in vbr_mode vs. Lame tag\n\n    var vbrTypeTranslator = [1, 5, 3, 2, 4, 0, 3];\n    var lowpass = 0 | (gfp.lowpassfreq / 100.0 + .5 > 255 ? 255 : gfp.lowpassfreq / 100.0 + .5);\n    var peakSignalAmplitude = 0;\n    var radioReplayGain = 0;\n    var audiophileReplayGain = 0;\n    var noiseShaping = gfp.internal_flags.noise_shaping;\n    var stereoMode = 0;\n    var nonOptimal = 0;\n    var sourceFreq = 0;\n    var misc = 0;\n    var musicCRC = 0; // psy model type: Gpsycho or NsPsytune\n\n    var expNPsyTune = (gfp.exp_nspsytune & 1) != 0;\n    var safeJoint = (gfp.exp_nspsytune & 2) != 0;\n    var noGapMore = false;\n    var noGapPrevious = false;\n    var noGapCount = gfp.internal_flags.nogap_total;\n    var noGapCurr = gfp.internal_flags.nogap_current; // 4 bits\n\n    var athType = gfp.ATHtype;\n    var flags = 0; // vbr modes\n\n    var abrBitrate;\n\n    switch (gfp.VBR) {\n      case vbr_abr:\n        abrBitrate = gfp.VBR_mean_bitrate_kbps;\n        break;\n\n      case vbr_off:\n        abrBitrate = gfp.brate;\n        break;\n\n      default:\n        abrBitrate = gfp.VBR_min_bitrate_kbps;\n    } // revision and vbr method\n\n\n    if (gfp.VBR.ordinal() < vbrTypeTranslator.length) vbr = vbrTypeTranslator[gfp.VBR.ordinal()];else vbr = 0x00; // unknown\n\n    revMethod = 0x10 * revision + vbr; // ReplayGain\n\n    if (gfc.findReplayGain) {\n      if (gfc.RadioGain > 0x1FE) gfc.RadioGain = 0x1FE;\n      if (gfc.RadioGain < -0x1FE) gfc.RadioGain = -0x1FE; // set name code\n\n      radioReplayGain = 0x2000; // set originator code to `determined automatically'\n\n      radioReplayGain |= 0xC00;\n\n      if (gfc.RadioGain >= 0) {\n        // set gain adjustment\n        radioReplayGain |= gfc.RadioGain;\n      } else {\n        // set the sign bit\n        radioReplayGain |= 0x200; // set gain adjustment\n\n        radioReplayGain |= -gfc.RadioGain;\n      }\n    } // peak sample\n\n\n    if (gfc.findPeakSample) peakSignalAmplitude = Math.abs(0 | gfc.PeakSample / 32767.0 * Math.pow(2, 23) + .5); // nogap\n\n    if (noGapCount != -1) {\n      if (noGapCurr > 0) noGapPrevious = true;\n      if (noGapCurr < noGapCount - 1) noGapMore = true;\n    } // flags\n\n\n    flags = athType + ((expNPsyTune ? 1 : 0) << 4) + ((safeJoint ? 1 : 0) << 5) + ((noGapMore ? 1 : 0) << 6) + ((noGapPrevious ? 1 : 0) << 7);\n    if (quality < 0) quality = 0; // stereo mode field (Intensity stereo is not implemented)\n\n    switch (gfp.mode) {\n      case MONO:\n        stereoMode = 0;\n        break;\n\n      case STEREO:\n        stereoMode = 1;\n        break;\n\n      case DUAL_CHANNEL:\n        stereoMode = 2;\n        break;\n\n      case JOINT_STEREO:\n        if (gfp.force_ms) stereoMode = 4;else stereoMode = 3;\n        break;\n\n      case NOT_SET: //$FALL-THROUGH$\n\n      default:\n        stereoMode = 7;\n        break;\n    }\n\n    if (gfp.in_samplerate <= 32000) sourceFreq = 0x00;else if (gfp.in_samplerate == 48000) sourceFreq = 0x02;else if (gfp.in_samplerate > 48000) sourceFreq = 0x03;else {\n      // default is 44100Hz\n      sourceFreq = 0x01;\n    } // Check if the user overrided the default LAME behavior with some\n    // nasty options\n\n    if (gfp.short_blocks == ShortBlock.short_block_forced || gfp.short_blocks == ShortBlock.short_block_dispensed || gfp.lowpassfreq == -1 && gfp.highpassfreq == -1 ||\n    /* \"-k\" */\n    gfp.scale_left < gfp.scale_right || gfp.scale_left > gfp.scale_right || gfp.disable_reservoir && gfp.brate < 320 || gfp.noATH || gfp.ATHonly || athType == 0 || gfp.in_samplerate <= 32000) nonOptimal = 1;\n    misc = noiseShaping + (stereoMode << 2) + (nonOptimal << 5) + (sourceFreq << 6);\n    musicCRC = gfc.nMusicCRC; // Write all this information into the stream\n\n    createInteger(streamBuffer, streamBufferPos + bytesWritten, quality);\n    bytesWritten += 4;\n\n    for (var j = 0; j < 9; j++) {\n      streamBuffer[streamBufferPos + bytesWritten + j] = 0xff & version.charAt(j);\n    }\n\n    bytesWritten += 9;\n    streamBuffer[streamBufferPos + bytesWritten] = 0xff & revMethod;\n    bytesWritten++;\n    streamBuffer[streamBufferPos + bytesWritten] = 0xff & lowpass;\n    bytesWritten++;\n    createInteger(streamBuffer, streamBufferPos + bytesWritten, peakSignalAmplitude);\n    bytesWritten += 4;\n    createShort(streamBuffer, streamBufferPos + bytesWritten, radioReplayGain);\n    bytesWritten += 2;\n    createShort(streamBuffer, streamBufferPos + bytesWritten, audiophileReplayGain);\n    bytesWritten += 2;\n    streamBuffer[streamBufferPos + bytesWritten] = 0xff & flags;\n    bytesWritten++;\n    if (abrBitrate >= 255) streamBuffer[streamBufferPos + bytesWritten] = 0xFF;else streamBuffer[streamBufferPos + bytesWritten] = 0xff & abrBitrate;\n    bytesWritten++;\n    streamBuffer[streamBufferPos + bytesWritten] = 0xff & encDelay >> 4;\n    streamBuffer[streamBufferPos + bytesWritten + 1] = 0xff & (encDelay << 4) + (encPadding >> 8);\n    streamBuffer[streamBufferPos + bytesWritten + 2] = 0xff & encPadding;\n    bytesWritten += 3;\n    streamBuffer[streamBufferPos + bytesWritten] = 0xff & misc;\n    bytesWritten++; // unused in rev0\n\n    streamBuffer[streamBufferPos + bytesWritten++] = 0;\n    createShort(streamBuffer, streamBufferPos + bytesWritten, gfp.preset);\n    bytesWritten += 2;\n    createInteger(streamBuffer, streamBufferPos + bytesWritten, musicLength);\n    bytesWritten += 4;\n    createShort(streamBuffer, streamBufferPos + bytesWritten, musicCRC);\n    bytesWritten += 2; // Calculate tag CRC.... must be done here, since it includes previous\n    // information\n\n    for (var i = 0; i < bytesWritten; i++) crc = crcUpdateLookup(streamBuffer[streamBufferPos + i], crc);\n\n    createShort(streamBuffer, streamBufferPos + bytesWritten, crc);\n    bytesWritten += 2;\n    return bytesWritten;\n  }\n\n  function skipId3v2(fpStream) {\n    // seek to the beginning of the stream\n    fpStream.seek(0); // read 10 bytes in case there's an ID3 version 2 header here\n\n    var id3v2Header = new_byte(10);\n    fpStream.readFully(id3v2Header);\n    /* does the stream begin with the ID3 version 2 file identifier? */\n\n    var id3v2TagSize;\n\n    if (!new String(id3v2Header, \"ISO-8859-1\").startsWith(\"ID3\")) {\n      /*\n       * the tag size (minus the 10-byte header) is encoded into four\n       * bytes where the most significant bit is clear in each byte\n       */\n      id3v2TagSize = ((id3v2Header[6] & 0x7f) << 21 | (id3v2Header[7] & 0x7f) << 14 | (id3v2Header[8] & 0x7f) << 7 | id3v2Header[9] & 0x7f) + id3v2Header.length;\n    } else {\n      /* no ID3 version 2 tag in this stream */\n      id3v2TagSize = 0;\n    }\n\n    return id3v2TagSize;\n  }\n\n  this.getLameTagFrame = function (gfp, buffer) {\n    var gfc = gfp.internal_flags;\n\n    if (!gfp.bWriteVbrTag) {\n      return 0;\n    }\n\n    if (gfc.Class_ID != Lame.LAME_ID) {\n      return 0;\n    }\n\n    if (gfc.VBR_seek_table.pos <= 0) {\n      return 0;\n    }\n\n    if (buffer.length < gfc.VBR_seek_table.TotalFrameSize) {\n      return gfc.VBR_seek_table.TotalFrameSize;\n    }\n\n    Arrays.fill(buffer, 0, gfc.VBR_seek_table.TotalFrameSize, 0); // 4 bytes frame header\n\n    setLameTagFrameHeader(gfp, buffer); // Create TOC entries\n\n    var toc = new_byte(NUMTOCENTRIES);\n\n    if (gfp.free_format) {\n      for (var i = 1; i < NUMTOCENTRIES; ++i) toc[i] = 0xff & 255 * i / 100;\n    } else {\n      xingSeekTable(gfc.VBR_seek_table, toc);\n    } // Start writing the tag after the zero frame\n\n\n    var streamIndex = gfc.sideinfo_len;\n    /**\n     * Note: Xing header specifies that Xing data goes in the ancillary data\n     * with NO ERROR PROTECTION. If error protecton in enabled, the Xing\n     * data still starts at the same offset, and now it is in sideinfo data\n     * block, and thus will not decode correctly by non-Xing tag aware\n     * players\n     */\n\n    if (gfp.error_protection) streamIndex -= 2; // Put Vbr tag\n\n    if (gfp.VBR == VbrMode.vbr_off) {\n      buffer[streamIndex++] = 0xff & VBRTag1.charAt(0);\n      buffer[streamIndex++] = 0xff & VBRTag1.charAt(1);\n      buffer[streamIndex++] = 0xff & VBRTag1.charAt(2);\n      buffer[streamIndex++] = 0xff & VBRTag1.charAt(3);\n    } else {\n      buffer[streamIndex++] = 0xff & VBRTag0.charAt(0);\n      buffer[streamIndex++] = 0xff & VBRTag0.charAt(1);\n      buffer[streamIndex++] = 0xff & VBRTag0.charAt(2);\n      buffer[streamIndex++] = 0xff & VBRTag0.charAt(3);\n    } // Put header flags\n\n\n    createInteger(buffer, streamIndex, FRAMES_FLAG + BYTES_FLAG + TOC_FLAG + VBR_SCALE_FLAG);\n    streamIndex += 4; // Put Total Number of frames\n\n    createInteger(buffer, streamIndex, gfc.VBR_seek_table.nVbrNumFrames);\n    streamIndex += 4; // Put total audio stream size, including Xing/LAME Header\n\n    var streamSize = gfc.VBR_seek_table.nBytesWritten + gfc.VBR_seek_table.TotalFrameSize;\n    createInteger(buffer, streamIndex, 0 | streamSize);\n    streamIndex += 4;\n    /* Put TOC */\n\n    System.arraycopy(toc, 0, buffer, streamIndex, toc.length);\n    streamIndex += toc.length;\n\n    if (gfp.error_protection) {\n      // (jo) error_protection: add crc16 information to header\n      bs.CRC_writeheader(gfc, buffer);\n    } // work out CRC so far: initially crc = 0\n\n\n    var crc = 0x00;\n\n    for (var i = 0; i < streamIndex; i++) crc = crcUpdateLookup(buffer[i], crc); // Put LAME VBR info\n\n\n    streamIndex += putLameVBR(gfp, streamSize, buffer, streamIndex, crc);\n    return gfc.VBR_seek_table.TotalFrameSize;\n  };\n  /**\n   * Write final VBR tag to the file.\n   *\n   * @param gfp\n   *            global flags\n   * @param stream\n   *            stream to add the VBR tag to\n   * @return 0 (OK), -1 else\n   * @throws IOException\n   *             I/O error\n   */\n\n\n  this.putVbrTag = function (gfp, stream) {\n    var gfc = gfp.internal_flags;\n    if (gfc.VBR_seek_table.pos <= 0) return -1; // Seek to end of file\n\n    stream.seek(stream.length()); // Get file size, abort if file has zero length.\n\n    if (stream.length() == 0) return -1; // The VBR tag may NOT be located at the beginning of the stream. If an\n    // ID3 version 2 tag was added, then it must be skipped to write the VBR\n    // tag data.\n\n    var id3v2TagSize = skipId3v2(stream); // Seek to the beginning of the stream\n\n    stream.seek(id3v2TagSize);\n    var buffer = new_byte(MAXFRAMESIZE);\n    var bytes = getLameTagFrame(gfp, buffer);\n\n    if (bytes > buffer.length) {\n      return -1;\n    }\n\n    if (bytes < 1) {\n      return 0;\n    } // Put it all to disk again\n\n\n    stream.write(buffer, 0, bytes); // success\n\n    return 0;\n  };\n}\n\nmodule.exports = VBRTag;","map":null,"metadata":{},"sourceType":"script"}