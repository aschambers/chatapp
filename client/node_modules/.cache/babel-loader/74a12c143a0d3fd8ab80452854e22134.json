{"ast":null,"code":"/* global Blob */\nmodule.exports = Peer;\n\nvar debug = require('debug')('simple-peer');\n\nvar getBrowserRTC = require('get-browser-rtc');\n\nvar hat = require('hat');\n\nvar inherits = require('inherits');\n\nvar isTypedArray = require('is-typedarray');\n\nvar once = require('once');\n\nvar stream = require('stream');\n\ninherits(Peer, stream.Duplex);\n/**\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\n * Duplex stream.\n * @param {Object} opts\n */\n\nfunction Peer(opts) {\n  var self = this;\n  if (!(self instanceof Peer)) return new Peer(opts);\n\n  self._debug('new peer %o', opts);\n\n  if (!opts) opts = {};\n  opts.allowHalfOpen = false;\n  if (opts.highWaterMark == null) opts.highWaterMark = 1024 * 1024;\n  stream.Duplex.call(self, opts);\n  self.initiator = opts.initiator || false;\n  self.channelConfig = opts.channelConfig || Peer.channelConfig;\n  self.channelName = opts.initiator ? opts.channelName || hat(160) : null;\n  self.config = opts.config || Peer.config;\n  self.constraints = opts.constraints || Peer.constraints;\n  self.offerConstraints = opts.offerConstraints;\n  self.answerConstraints = opts.answerConstraints;\n  self.reconnectTimer = opts.reconnectTimer || false;\n\n  self.sdpTransform = opts.sdpTransform || function (sdp) {\n    return sdp;\n  };\n\n  self.stream = opts.stream || false;\n  self.trickle = opts.trickle !== undefined ? opts.trickle : true;\n  self.destroyed = false;\n  self.connected = false; // so Peer object always has same shape (V8 optimization)\n\n  self.remoteAddress = undefined;\n  self.remoteFamily = undefined;\n  self.remotePort = undefined;\n  self.localAddress = undefined;\n  self.localPort = undefined;\n  self._isWrtc = !!opts.wrtc; // HACK: to fix `wrtc` bug. See issue: #60\n\n  self._wrtc = opts.wrtc || getBrowserRTC();\n\n  if (!self._wrtc) {\n    if (typeof window === 'undefined') {\n      throw new Error('No WebRTC support: Specify `opts.wrtc` option in this environment');\n    } else {\n      throw new Error('No WebRTC support: Not a supported browser');\n    }\n  }\n\n  self._maxBufferedAmount = opts.highWaterMark;\n  self._pcReady = false;\n  self._channelReady = false;\n  self._iceComplete = false; // ice candidate trickle done (got null candidate)\n\n  self._channel = null;\n  self._pendingCandidates = [];\n  self._chunk = null;\n  self._cb = null;\n  self._interval = null;\n  self._reconnectTimeout = null;\n  self._pc = new self._wrtc.RTCPeerConnection(self.config, self.constraints);\n  self._pc.oniceconnectionstatechange = self._onIceConnectionStateChange.bind(self);\n  self._pc.onsignalingstatechange = self._onSignalingStateChange.bind(self);\n  self._pc.onicecandidate = self._onIceCandidate.bind(self);\n  if (self.stream) self._pc.addStream(self.stream);\n  self._pc.onaddstream = self._onAddStream.bind(self);\n\n  if (self.initiator) {\n    self._setupData({\n      channel: self._pc.createDataChannel(self.channelName, self.channelConfig)\n    });\n\n    self._pc.onnegotiationneeded = once(self._createOffer.bind(self)); // Only Chrome triggers \"negotiationneeded\"; this is a workaround for other\n    // implementations\n\n    if (typeof window === 'undefined' || !window.webkitRTCPeerConnection) {\n      self._pc.onnegotiationneeded();\n    }\n  } else {\n    self._pc.ondatachannel = self._setupData.bind(self);\n  }\n\n  self.on('finish', function () {\n    if (self.connected) {\n      // When local peer is finished writing, close connection to remote peer.\n      // Half open connections are currently not supported.\n      // Wait a bit before destroying so the datachannel flushes.\n      // TODO: is there a more reliable way to accomplish this?\n      setTimeout(function () {\n        self._destroy();\n      }, 100);\n    } else {\n      // If data channel is not connected when local peer is finished writing, wait until\n      // data is flushed to network at \"connect\" event.\n      // TODO: is there a more reliable way to accomplish this?\n      self.once('connect', function () {\n        setTimeout(function () {\n          self._destroy();\n        }, 100);\n      });\n    }\n  });\n}\n\nPeer.WEBRTC_SUPPORT = !!getBrowserRTC();\n/**\n * Expose config, constraints, and data channel config for overriding all Peer\n * instances. Otherwise, just set opts.config, opts.constraints, or opts.channelConfig\n * when constructing a Peer.\n */\n\nPeer.config = {\n  iceServers: [{\n    url: 'stun:23.21.150.121',\n    // deprecated, replaced by `urls`\n    urls: 'stun:23.21.150.121'\n  }]\n};\nPeer.constraints = {};\nPeer.channelConfig = {};\nObject.defineProperty(Peer.prototype, 'bufferSize', {\n  get: function () {\n    var self = this;\n    return self._channel && self._channel.bufferedAmount || 0;\n  }\n});\n\nPeer.prototype.address = function () {\n  var self = this;\n  return {\n    port: self.localPort,\n    family: 'IPv4',\n    address: self.localAddress\n  };\n};\n\nPeer.prototype.signal = function (data) {\n  var self = this;\n  if (self.destroyed) throw new Error('cannot signal after peer is destroyed');\n\n  if (typeof data === 'string') {\n    try {\n      data = JSON.parse(data);\n    } catch (err) {\n      data = {};\n    }\n  }\n\n  self._debug('signal()');\n\n  function addIceCandidate(candidate) {\n    try {\n      self._pc.addIceCandidate(new self._wrtc.RTCIceCandidate(candidate), noop, self._onError.bind(self));\n    } catch (err) {\n      self._destroy(new Error('error adding candidate: ' + err.message));\n    }\n  }\n\n  if (data.sdp) {\n    self._pc.setRemoteDescription(new self._wrtc.RTCSessionDescription(data), function () {\n      if (self.destroyed) return;\n      if (self._pc.remoteDescription.type === 'offer') self._createAnswer();\n\n      self._pendingCandidates.forEach(addIceCandidate);\n\n      self._pendingCandidates = [];\n    }, self._onError.bind(self));\n  }\n\n  if (data.candidate) {\n    if (self._pc.remoteDescription) addIceCandidate(data.candidate);else self._pendingCandidates.push(data.candidate);\n  }\n\n  if (!data.sdp && !data.candidate) {\n    self._destroy(new Error('signal() called with invalid signal data'));\n  }\n};\n/**\n * Send text/binary data to the remote peer.\n * @param {TypedArrayView|ArrayBuffer|Buffer|string|Blob|Object} chunk\n */\n\n\nPeer.prototype.send = function (chunk) {\n  var self = this;\n\n  if (!isTypedArray.strict(chunk) && !(chunk instanceof ArrayBuffer) && !Buffer.isBuffer(chunk) && typeof chunk !== 'string' && (typeof Blob === 'undefined' || !(chunk instanceof Blob))) {\n    chunk = JSON.stringify(chunk);\n  } // HACK: `wrtc` module doesn't accept node.js buffer. See issue: #60\n\n\n  if (Buffer.isBuffer(chunk) && self._isWrtc) {\n    chunk = new Uint8Array(chunk);\n  }\n\n  var len = chunk.length || chunk.byteLength || chunk.size;\n\n  self._channel.send(chunk);\n\n  self._debug('write: %d bytes', len);\n};\n\nPeer.prototype.destroy = function (onclose) {\n  var self = this;\n\n  self._destroy(null, onclose);\n};\n\nPeer.prototype._destroy = function (err, onclose) {\n  var self = this;\n  if (self.destroyed) return;\n  if (onclose) self.once('close', onclose);\n\n  self._debug('destroy (error: %s)', err && err.message);\n\n  self.readable = self.writable = false;\n  if (!self._readableState.ended) self.push(null);\n  if (!self._writableState.finished) self.end();\n  self.destroyed = true;\n  self.connected = false;\n  self._pcReady = false;\n  self._channelReady = false;\n  self._chunk = null;\n  self._cb = null;\n  clearInterval(self._interval);\n  clearTimeout(self._reconnectTimeout);\n\n  if (self._pc) {\n    try {\n      self._pc.close();\n    } catch (err) {}\n\n    self._pc.oniceconnectionstatechange = null;\n    self._pc.onsignalingstatechange = null;\n    self._pc.onicecandidate = null;\n  }\n\n  if (self._channel) {\n    try {\n      self._channel.close();\n    } catch (err) {}\n\n    self._channel.onmessage = null;\n    self._channel.onopen = null;\n    self._channel.onclose = null;\n  }\n\n  self._pc = null;\n  self._channel = null;\n  if (err) self.emit('error', err);\n  self.emit('close');\n};\n\nPeer.prototype._setupData = function (event) {\n  var self = this;\n  self._channel = event.channel;\n  self.channelName = self._channel.label;\n  self._channel.binaryType = 'arraybuffer';\n  self._channel.onmessage = self._onChannelMessage.bind(self);\n  self._channel.onopen = self._onChannelOpen.bind(self);\n  self._channel.onclose = self._onChannelClose.bind(self);\n};\n\nPeer.prototype._read = function () {};\n\nPeer.prototype._write = function (chunk, encoding, cb) {\n  var self = this;\n  if (self.destroyed) return cb(new Error('cannot write after peer is destroyed'));\n\n  if (self.connected) {\n    try {\n      self.send(chunk);\n    } catch (err) {\n      return self._onError(err);\n    }\n\n    if (self._channel.bufferedAmount > self._maxBufferedAmount) {\n      self._debug('start backpressure: bufferedAmount %d', self._channel.bufferedAmount);\n\n      self._cb = cb;\n    } else {\n      cb(null);\n    }\n  } else {\n    self._debug('write before connect');\n\n    self._chunk = chunk;\n    self._cb = cb;\n  }\n};\n\nPeer.prototype._createOffer = function () {\n  var self = this;\n  if (self.destroyed) return;\n\n  self._pc.createOffer(function (offer) {\n    if (self.destroyed) return;\n    offer.sdp = self.sdpTransform(offer.sdp);\n\n    self._pc.setLocalDescription(offer, noop, self._onError.bind(self));\n\n    var sendOffer = function () {\n      var signal = self._pc.localDescription || offer;\n\n      self._debug('signal');\n\n      self.emit('signal', {\n        type: signal.type,\n        sdp: signal.sdp\n      });\n    };\n\n    if (self.trickle || self._iceComplete) sendOffer();else self.once('_iceComplete', sendOffer); // wait for candidates\n  }, self._onError.bind(self), self.offerConstraints);\n};\n\nPeer.prototype._createAnswer = function () {\n  var self = this;\n  if (self.destroyed) return;\n\n  self._pc.createAnswer(function (answer) {\n    if (self.destroyed) return;\n    answer.sdp = self.sdpTransform(answer.sdp);\n\n    self._pc.setLocalDescription(answer, noop, self._onError.bind(self));\n\n    var sendAnswer = function () {\n      var signal = self._pc.localDescription || answer;\n\n      self._debug('signal');\n\n      self.emit('signal', {\n        type: signal.type,\n        sdp: signal.sdp\n      });\n    };\n\n    if (self.trickle || self._iceComplete) sendAnswer();else self.once('_iceComplete', sendAnswer);\n  }, self._onError.bind(self), self.answerConstraints);\n};\n\nPeer.prototype._onIceConnectionStateChange = function () {\n  var self = this;\n  if (self.destroyed) return;\n  var iceGatheringState = self._pc.iceGatheringState;\n  var iceConnectionState = self._pc.iceConnectionState;\n\n  self._debug('iceConnectionStateChange %s %s', iceGatheringState, iceConnectionState);\n\n  self.emit('iceConnectionStateChange', iceGatheringState, iceConnectionState);\n\n  if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\n    clearTimeout(self._reconnectTimeout);\n    self._pcReady = true;\n\n    self._maybeReady();\n  }\n\n  if (iceConnectionState === 'disconnected') {\n    if (self.reconnectTimer) {\n      // If user has set `opt.reconnectTimer`, allow time for ICE to attempt a reconnect\n      clearTimeout(self._reconnectTimeout);\n      self._reconnectTimeout = setTimeout(function () {\n        self._destroy();\n      }, self.reconnectTimer);\n    } else {\n      self._destroy();\n    }\n  }\n\n  if (iceConnectionState === 'failed') {\n    self._destroy();\n  }\n\n  if (iceConnectionState === 'closed') {\n    self._destroy();\n  }\n};\n\nPeer.prototype._maybeReady = function () {\n  var self = this;\n\n  self._debug('maybeReady pc %s channel %s', self._pcReady, self._channelReady);\n\n  if (self.connected || self._connecting || !self._pcReady || !self._channelReady) return;\n  self._connecting = true;\n\n  if (!self._pc.getStats) {\n    onStats([]);\n  } else if (typeof window !== 'undefined' && !!window.mozRTCPeerConnection) {\n    self._pc.getStats(null, function (res) {\n      var items = [];\n      res.forEach(function (item) {\n        items.push(item);\n      });\n      onStats(items);\n    }, self._onError.bind(self));\n  } else {\n    self._pc.getStats(function (res) {\n      var items = [];\n      res.result().forEach(function (result) {\n        var item = {};\n        result.names().forEach(function (name) {\n          item[name] = result.stat(name);\n        });\n        item.id = result.id;\n        item.type = result.type;\n        item.timestamp = result.timestamp;\n        items.push(item);\n      });\n      onStats(items);\n    });\n  }\n\n  function onStats(items) {\n    items.forEach(function (item) {\n      if (item.type === 'remotecandidate' && item.candidateType === 'host') {\n        self.remoteAddress = item.ipAddress;\n        self.remotePort = Number(item.portNumber);\n        self.remoteFamily = 'IPv4';\n\n        self._debug('connect remote: %s:%s (%s)', self.remoteAddress, self.remotePort, self.remoteFamily);\n      } else if (item.type === 'localcandidate' && item.candidateType === 'host') {\n        self.localAddress = item.ipAddress;\n        self.localPort = Number(item.portNumber);\n\n        self._debug('connect local: %s:%s', self.localAddress, self.localPort);\n      }\n    });\n    self._connecting = false;\n    self.connected = true;\n\n    if (self._chunk) {\n      try {\n        self.send(self._chunk);\n      } catch (err) {\n        return self._onError(err);\n      }\n\n      self._chunk = null;\n\n      self._debug('sent chunk from \"write before connect\"');\n\n      var cb = self._cb;\n      self._cb = null;\n      cb(null);\n    }\n\n    self._interval = setInterval(function () {\n      if (!self._cb || !self._channel || self._channel.bufferedAmount > self._maxBufferedAmount) return;\n\n      self._debug('ending backpressure: bufferedAmount %d', self._channel.bufferedAmount);\n\n      var cb = self._cb;\n      self._cb = null;\n      cb(null);\n    }, 150);\n    if (self._interval.unref) self._interval.unref();\n\n    self._debug('connect');\n\n    self.emit('connect');\n  }\n};\n\nPeer.prototype._onSignalingStateChange = function () {\n  var self = this;\n  if (self.destroyed) return;\n\n  self._debug('signalingStateChange %s', self._pc.signalingState);\n\n  self.emit('signalingStateChange', self._pc.signalingState);\n};\n\nPeer.prototype._onIceCandidate = function (event) {\n  var self = this;\n  if (self.destroyed) return;\n\n  if (event.candidate && self.trickle) {\n    self.emit('signal', {\n      candidate: {\n        candidate: event.candidate.candidate,\n        sdpMLineIndex: event.candidate.sdpMLineIndex,\n        sdpMid: event.candidate.sdpMid\n      }\n    });\n  } else if (!event.candidate) {\n    self._iceComplete = true;\n    self.emit('_iceComplete');\n  }\n};\n\nPeer.prototype._onChannelMessage = function (event) {\n  var self = this;\n  if (self.destroyed) return;\n  var data = event.data;\n\n  self._debug('read: %d bytes', data.byteLength || data.length);\n\n  if (data instanceof ArrayBuffer) {\n    data = new Buffer(data);\n    self.push(data);\n  } else {\n    try {\n      data = JSON.parse(data);\n    } catch (err) {}\n\n    self.emit('data', data);\n  }\n};\n\nPeer.prototype._onChannelOpen = function () {\n  var self = this;\n  if (self.connected || self.destroyed) return;\n\n  self._debug('on channel open');\n\n  self._channelReady = true;\n\n  self._maybeReady();\n};\n\nPeer.prototype._onChannelClose = function () {\n  var self = this;\n  if (self.destroyed) return;\n\n  self._debug('on channel close');\n\n  self._destroy();\n};\n\nPeer.prototype._onAddStream = function (event) {\n  var self = this;\n  if (self.destroyed) return;\n\n  self._debug('on add stream');\n\n  self.emit('stream', event.stream);\n};\n\nPeer.prototype._onError = function (err) {\n  var self = this;\n  if (self.destroyed) return;\n\n  self._debug('error %s', err.message || err);\n\n  self._destroy(err);\n};\n\nPeer.prototype._debug = function () {\n  var self = this;\n  var args = [].slice.call(arguments);\n  var id = self.channelName && self.channelName.substring(0, 7);\n  args[0] = '[' + id + '] ' + args[0];\n  debug.apply(null, args);\n};\n\nfunction noop() {}","map":null,"metadata":{},"sourceType":"script"}