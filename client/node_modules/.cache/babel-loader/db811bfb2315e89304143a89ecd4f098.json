{"ast":null,"code":"/* jshint node: true */\n'use strict';\n\nvar mbus = require('mbus');\n\nvar queue = require('rtc-taskqueue');\n\nvar cleanup = require('./cleanup');\n\nvar monitor = require('./monitor');\n\nvar throttle = require('cog/throttle');\n\nvar pluck = require('whisk/pluck');\n\nvar pluckCandidate = pluck('candidate', 'sdpMid', 'sdpMLineIndex');\nvar CLOSED_STATES = ['closed', 'failed'];\nvar CHECKING_STATES = ['checking'];\n/**\n  ### rtc-tools/couple\n\n  #### couple(pc, targetId, signaller, opts?)\n\n  Couple a WebRTC connection with another webrtc connection identified by\n  `targetId` via the signaller.\n\n  The following options can be provided in the `opts` argument:\n\n  - `sdpfilter` (default: null)\n\n    A simple function for filtering SDP as part of the peer\n    connection handshake (see the Using Filters details below).\n\n  ##### Example Usage\n\n  ```js\n  var couple = require('rtc/couple');\n\n  couple(pc, '54879965-ce43-426e-a8ef-09ac1e39a16d', signaller);\n  ```\n\n  ##### Using Filters\n\n  In certain instances you may wish to modify the raw SDP that is provided\n  by the `createOffer` and `createAnswer` calls.  This can be done by passing\n  a `sdpfilter` function (or array) in the options.  For example:\n\n  ```js\n  // run the sdp from through a local tweakSdp function.\n  couple(pc, '54879965-ce43-426e-a8ef-09ac1e39a16d', signaller, {\n    sdpfilter: tweakSdp\n  });\n  ```\n\n**/\n\nfunction couple(pc, targetId, signaller, opts) {\n  var debugLabel = (opts || {}).debugLabel || 'rtc';\n\n  var debug = require('cog/logger')(debugLabel + '/couple'); // create a monitor for the connection\n\n\n  var mon = monitor(pc, targetId, signaller, (opts || {}).logger);\n  var emit = mbus('', mon);\n  var reactive = (opts || {}).reactive;\n  var endOfCandidates = true; // configure the time to wait between receiving a 'disconnect'\n  // iceConnectionState and determining that we are closed\n\n  var disconnectTimeout = (opts || {}).disconnectTimeout || 10000;\n  var disconnectTimer; // Target ready indicates that the target peer has indicated it is\n  // ready to begin coupling\n\n  var targetReady = false;\n  var targetInfo = undefined;\n  var readyInterval = (opts || {}).readyInterval || 100;\n  var readyTimer; // Failure timeout\n\n  var failTimeout = (opts || {}).failTimeout || 30000;\n  var failTimer; // Request offer timer\n\n  var requestOfferTimer; // Interoperability flags\n\n  var allowReactiveInterop = (opts || {}).allowReactiveInterop; // initilaise the negotiation helpers\n\n  var isMaster = signaller.isMaster(targetId); // initialise the processing queue (one at a time please)\n\n  var q = queue(pc, opts);\n  var coupling = false;\n  var negotiationRequired = false;\n  var renegotiateRequired = false;\n  var creatingOffer = false;\n  var awaitingAnswer = false;\n  var interoperating = false;\n  /**\n    Indicates whether this peer connection is in a state where it is able to have new offers created\n   **/\n\n  function isReadyForOffer() {\n    return !coupling && pc.signalingState === 'stable';\n  }\n\n  function createOffer() {\n    // If coupling is already in progress, return\n    if (!isReadyForOffer()) return;\n    debug('[' + signaller.id + '] ' + 'Creating new offer for connection to ' + targetId); // Otherwise, create the offer\n\n    coupling = true;\n    creatingOffer = true;\n    awaitingAnswer = true;\n    negotiationRequired = false;\n    q.createOffer().then(function () {\n      creatingOffer = false;\n    }).catch(function () {\n      creatingOffer = false;\n      awaitingAnswer = true;\n    });\n  }\n\n  var createOrRequestOffer = throttle(function () {\n    if (awaitingAnswer) {\n      debug('[' + signaller.id + '] awaiting answer from ' + targetId + ' before sending new offer');\n      return;\n    }\n\n    if (!targetReady) {\n      debug('[' + signaller.id + '] ' + targetId + ' not yet ready for offer');\n      return emit.once('target.ready', createOrRequestOffer);\n    } // If this is not the master, always send the negotiate request\n    // Redundant requests are eliminated on the master side\n\n\n    if (!isMaster) {\n      debug('[' + signaller.id + '] ' + 'Requesting negotiation from ' + targetId + ' (requesting offerer? ' + renegotiateRequired + ')'); // Due to https://bugs.chromium.org/p/webrtc/issues/detail?id=2782 which involves incompatibilities between\n      // Chrome and Firefox created offers by default client offers are disabled to ensure that all offers are coming\n      // from the same source. By passing `allowReactiveInterop` you can reallow this, then use the `filtersdp` option\n      // to provide a munged SDP that might be able to work\n\n      return signaller.to(targetId).send('/negotiate', {\n        requestOfferer: (allowReactiveInterop || !interoperating) && renegotiateRequired\n      });\n    }\n\n    debug('[' + signaller.id + '] Creating new offer for ' + targetId);\n    return createOffer();\n  }, 100, {\n    leading: false\n  });\n\n  function decouple() {\n    debug('decoupling ' + signaller.id + ' from ' + targetId); // Reset values\n\n    coupling = false;\n    creatingOffer = false;\n    awaitingAnswer = false; // Clear any outstanding timers\n\n    clearTimeout(readyTimer);\n    clearTimeout(disconnectTimer);\n    clearTimeout(requestOfferTimer);\n    clearTimeout(failTimer); // stop the monitor\n    //     mon.removeAllListeners();\n\n    mon.close(); // cleanup the peerconnection\n\n    cleanup(pc); // remove listeners\n\n    signaller.removeListener('sdp', handleSdp);\n    signaller.removeListener('candidate', handleCandidate);\n    signaller.removeListener('endofcandidates', handleLastCandidate);\n    signaller.removeListener('negotiate', handleNegotiateRequest);\n    signaller.removeListener('ready', handleReady);\n    signaller.removeListener('requestoffer', handleRequestOffer); // remove listeners (version >= 5)\n\n    signaller.removeListener('message:sdp', handleSdp);\n    signaller.removeListener('message:candidate', handleCandidate);\n    signaller.removeListener('message:endofcandidates', handleLastCandidate);\n    signaller.removeListener('message:negotiate', handleNegotiateRequest);\n    signaller.removeListener('message:ready', handleReady);\n    signaller.removeListener('message:requestoffer', handleRequestOffer);\n  }\n\n  function handleCandidate(data, src) {\n    // if the source is unknown or not a match, then don't process\n    if (!src || src.id !== targetId) {\n      return;\n    }\n\n    q.addIceCandidate(data);\n  } // No op\n\n\n  function handleLastCandidate() {}\n\n  function handleSdp(sdp, src) {\n    // if the source is unknown or not a match, then don't process\n    if (!src || src.id !== targetId) {\n      return;\n    }\n\n    emit('sdp.remote', sdp); // To speed up things on the renegotiation side of things, determine whether we have\n    // finished the coupling (offer -> answer) cycle, and whether it is safe to start\n    // renegotiating prior to the iceConnectionState \"completed\" state\n\n    q.setRemoteDescription(sdp).then(function () {\n      // If this is the peer that is coupling, and we have received the answer so we can\n      // and assume that coupling (offer -> answer) process is complete, so we can clear the coupling flag\n      if (coupling && sdp.type === 'answer') {\n        awaitingAnswer = false; // Check if the coupling is complete\n\n        checkIfCouplingComplete();\n        debug('coupling complete, can now trigger any pending renegotiations');\n        if (negotiationRequired) createOrRequestOffer();\n      }\n    });\n  }\n\n  function handleReady(src) {\n    if (targetReady || !src || src.id !== targetId) {\n      return;\n    }\n\n    debug('[' + signaller.id + '] ' + targetId + ' is ready for coupling');\n    targetReady = true;\n    targetInfo = src.data;\n    interoperating = targetInfo.browser !== signaller.attributes.browser;\n    emit('target.ready');\n  }\n\n  function handleConnectionClose() {\n    debug('captured pc close, iceConnectionState = ' + pc.iceConnectionState);\n    decouple();\n  }\n\n  function handleDisconnect() {\n    debug('captured pc disconnect, monitoring connection status'); // start the disconnect timer\n\n    disconnectTimer = setTimeout(function () {\n      debug('manually closing connection after disconnect timeout');\n      mon('failed');\n      cleanup(pc);\n    }, disconnectTimeout);\n    mon.on('statechange', handleDisconnectAbort);\n    mon('failing');\n  }\n\n  function handleDisconnectAbort() {\n    debug('connection state changed to: ' + pc.iceConnectionState); // if the state is checking, then do not reset the disconnect timer as\n    // we are doing our own checking\n\n    if (CHECKING_STATES.indexOf(pc.iceConnectionState) >= 0) {\n      return;\n    }\n\n    resetDisconnectTimer(); // if we have a closed or failed status, then close the connection\n\n    if (CLOSED_STATES.indexOf(pc.iceConnectionState) >= 0) {\n      return mon('closed');\n    }\n\n    mon.once('disconnect', handleDisconnect);\n  }\n\n  function handleLocalCandidate(evt) {\n    var data = evt.candidate && pluckCandidate(evt.candidate);\n\n    if (evt.candidate) {\n      resetDisconnectTimer();\n      emit('ice.local', data);\n      signaller.to(targetId).send('/candidate', data);\n      endOfCandidates = false;\n    } else if (!endOfCandidates) {\n      endOfCandidates = true;\n      emit('ice.gathercomplete');\n      signaller.to(targetId).send('/endofcandidates', {});\n    }\n  }\n\n  function requestNegotiation() {\n    // This is a redundant request if not reactive\n    if (coupling && !reactive) return; // If no coupling is occurring, regardless of reactive, start the offer process\n\n    if (!coupling) return createOrRequestOffer(); // If we are already coupling, we are reactive and renegotiation has not been indicated\n    // defer a negotiation request\n\n    if (coupling && reactive && !negotiationRequired) {\n      debug('renegotiation is required, but deferring until existing connection is established');\n      negotiationRequired = true; // NOTE: This is commented out, as the functionality after the setRemoteDescription\n      // should adequately take care of this. But should it not, re-enable this\n      // mon.once('connectionstate:completed', function() {\n      //   createOrRequestOffer();\n      // });\n    }\n  }\n  /**\n    This allows the master to request the client to send an offer\n   **/\n\n\n  function requestOfferFromClient() {\n    if (requestOfferTimer) clearTimeout(requestOfferTimer);\n    if (pc.signalingState === 'closed') return; // Check if we are ready for a new offer, otherwise delay\n\n    if (!isReadyForOffer()) {\n      debug('[' + signaller.id + '] negotiation request denied, not in a state to accept new offers [coupling = ' + coupling + ', creatingOffer = ' + creatingOffer + ', awaitingAnswer = ' + awaitingAnswer + ', ' + pc.signalingState + ']'); // Do a check to see if the coupling is complete\n\n      checkIfCouplingComplete(); // Do a recheck of the request\n\n      requestOfferTimer = setTimeout(requestOfferFromClient, 500);\n    } else {\n      // Flag as coupling and request the client send the offer\n      debug('[' + signaller.id + '] ' + targetId + ' has requested the ability to create the offer');\n      coupling = true;\n      return signaller.to(targetId).send('/requestoffer');\n    }\n  }\n\n  function handleNegotiateRequest(data, src) {\n    debug('[' + signaller.id + '] ' + src.id + ' has requested a negotiation'); // Sanity check that this is for the target\n\n    if (!src || src.id !== targetId) return;\n    emit('negotiate.request', src.id, data); // Check if the client is requesting the ability to create the offer themselves\n\n    if (data && data.requestOfferer) {\n      return requestOfferFromClient();\n    } // Otherwise, begin the traditional master driven negotiation process\n\n\n    requestNegotiation();\n  }\n\n  function handleRenegotiateRequest() {\n    if (!reactive) return;\n    emit('negotiate.renegotiate');\n    renegotiateRequired = true;\n    requestNegotiation();\n  }\n\n  function resetDisconnectTimer() {\n    var recovered = !!disconnectTimer && CLOSED_STATES.indexOf(pc.iceConnectionState) === -1;\n    mon.off('statechange', handleDisconnectAbort); // clear the disconnect timer\n\n    debug('reset disconnect timer, state: ' + pc.iceConnectionState);\n    clearTimeout(disconnectTimer);\n    disconnectTimer = undefined; // Trigger the recovered event if this is a recovery\n\n    if (recovered) {\n      mon('recovered');\n    }\n  }\n  /**\n    Allow clients to send offers\n   **/\n\n\n  function handleRequestOffer(src) {\n    if (!src || src.id !== targetId) return;\n    debug('[' + signaller.id + '] ' + targetId + ' has requested that the offer be sent [' + src.id + ']');\n    return createOffer();\n  }\n\n  function checkIfCouplingComplete() {\n    // Check if the coupling process is over\n    // The coupling process should be check whenever the signaling state is stable\n    // or when a remote answer has been received\n    // A coupling is considered over when the offer is no longer being created, and\n    // there is no answer being waited for\n    if (!coupling || creatingOffer || awaitingAnswer) return;\n    debug('[' + signaller.id + '] coupling completed to ' + targetId);\n    coupling = false;\n  } // when regotiation is needed look for the peer\n\n\n  if (reactive) {\n    pc.onnegotiationneeded = handleRenegotiateRequest;\n  }\n\n  pc.onicecandidate = handleLocalCandidate; // when the task queue tells us we have sdp available, send that over the wire\n\n  q.on('sdp.local', function (desc) {\n    signaller.to(targetId).send('/sdp', desc);\n  }); // when we receive sdp, then\n\n  signaller.on('sdp', handleSdp);\n  signaller.on('candidate', handleCandidate);\n  signaller.on('endofcandidates', handleLastCandidate);\n  signaller.on('ready', handleReady); // listeners (signaller >= 5)\n\n  signaller.on('message:sdp', handleSdp);\n  signaller.on('message:candidate', handleCandidate);\n  signaller.on('message:endofcandidates', handleLastCandidate);\n  signaller.on('message:ready', handleReady); // if this is a master connection, listen for negotiate events\n\n  if (isMaster) {\n    signaller.on('negotiate', handleNegotiateRequest);\n    signaller.on('message:negotiate', handleNegotiateRequest); // signaller >= 5\n  } else {\n    signaller.on('requestoffer', handleRequestOffer);\n    signaller.on('message:requestoffer', handleRequestOffer);\n  } // when the connection closes, remove event handlers\n\n\n  mon.once('closed', handleConnectionClose);\n  mon.once('disconnected', handleDisconnect); // patch in the create offer functions\n\n  mon.createOffer = createOrRequestOffer; // A heavy handed approach to ensuring readiness across the coupling\n  // peers. Will periodically send the `ready` message to the target peer\n  // until the target peer has acknowledged that it also is ready - at which\n  // point the offer can be sent\n\n  function checkReady() {\n    clearTimeout(readyTimer);\n    signaller.to(targetId).send('/ready'); // If we are ready, they've told us they are ready, and we've told\n    // them we're ready, then exit\n\n    if (targetReady) return; // Otherwise, keep telling them we're ready\n\n    readyTimer = setTimeout(checkReady, readyInterval);\n  }\n\n  checkReady();\n  debug('[' + signaller.id + '] ready for coupling to ' + targetId); // If we fail to connect within the given timeframe, trigger a failure\n\n  failTimer = setTimeout(function () {\n    debug('[' + signaller.id + '] failed to connect to ' + targetId + ' within allocated time');\n    mon('failed');\n    decouple();\n  }, failTimeout);\n  mon.once('connected', function () {\n    clearTimeout(failTimer);\n  });\n  mon.on('signalingchange', function (pc, state) {\n    debug('[' + signaller.id + '] signaling state ' + state + ' to ' + targetId);\n  });\n  mon.on('signaling:stable', function () {\n    // Check if the coupling if complete\n    checkIfCouplingComplete(); // Check if we have any pending negotiations\n\n    if (negotiationRequired) {\n      debug('signalling stable and a negotiation is required, so creating one');\n      createOrRequestOffer();\n    }\n  });\n  mon.stop = decouple;\n  /**\n    Allows for manually triggering a renegotiation\n   */\n\n  mon.requestRenegotiation = handleRenegotiateRequest;\n  /**\n    Aborts the coupling process\n   **/\n\n  mon.abort = function () {\n    if (failTimer) {\n      clearTimeout(failTimer);\n    }\n\n    decouple();\n    mon('aborted');\n  }; // Override destroy to clear the task queue as well\n\n\n  mon.destroy = function () {\n    mon.clear();\n    q.clear();\n  };\n\n  return mon;\n}\n\nmodule.exports = couple;","map":null,"metadata":{},"sourceType":"script"}