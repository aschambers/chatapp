{"ast":null,"code":"var extend = require('cog/extend');\n\nmodule.exports = function (signaller) {\n  function dataAllowed(data) {\n    var cloned = extend({\n      allow: true\n    }, data);\n    signaller('peer:filter', data.id, cloned);\n    return cloned.allow;\n  }\n\n  return function (args, messageType, srcData, srcState, isDM) {\n    var data = args[0];\n    var peer; // if we have valid data then process\n\n    if (data && data.id && data.id !== signaller.id) {\n      if (!dataAllowed(data)) {\n        return;\n      } // check to see if this is a known peer\n\n\n      peer = signaller.peers.get(data.id); // trigger the peer connected event to flag that we know about a\n      // peer connection. The peer has passed the \"filter\" check but may\n      // be announced / updated depending on previous connection status\n\n      signaller('peer:connected', data.id, data); // if the peer is existing, then update the data\n\n      if (peer) {\n        // update the data\n        extend(peer.data, data); // trigger the peer update event\n\n        return signaller('peer:update', data, srcData);\n      } // create a new peer\n\n\n      peer = {\n        id: data.id,\n        // initialise the local role index\n        roleIdx: [data.id, signaller.id].sort().indexOf(data.id),\n        // initialise the peer data\n        data: {}\n      }; // initialise the peer data\n\n      extend(peer.data, data); // set the peer data\n\n      signaller.peers.set(data.id, peer); // if this is an initial announce message (no vector clock attached)\n      // then send a announce reply\n\n      if (signaller.autoreply && !isDM) {\n        signaller.to(data.id).send('/announce', signaller.attributes);\n      } // emit a new peer announce event\n\n\n      return signaller('peer:announce', data, peer);\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}