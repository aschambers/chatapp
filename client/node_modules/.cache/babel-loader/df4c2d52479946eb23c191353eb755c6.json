{"ast":null,"code":"var detect = require('rtc-core/detect');\n\nvar extend = require('cog/extend');\n\nvar getable = require('cog/getable');\n\nvar cuid = require('cuid');\n\nvar mbus = require('mbus');\n\nvar prepare = require('./prepare');\n/**\n  ## `signaller(opts, bufferMessage) => mbus`\n\n  Create a base level signaller which is capable of processing\n  messages from an incoming source.  The signaller is capable of\n  sending messages outbound using the `bufferMessage` function\n  that is supplied to the signaller.\n\n**/\n\n\nmodule.exports = function (opts, bufferMessage) {\n  // get the autoreply setting\n  var autoreply = (opts || {}).autoreply; // create the signaller mbus\n\n  var signaller = mbus('', (opts || {}).logger); // initialise the peers\n\n  var peers = signaller.peers = getable({}); // initialise the signaller attributes\n\n  var attributes = signaller.attributes = {\n    browser: detect.browser,\n    browserVersion: detect.browserVersion,\n    agent: 'unknown'\n  };\n\n  function createToMessage(header) {\n    return function () {\n      var args = header.concat([].slice.call(arguments)); // inject the signaller.id\n\n      args.splice(3, 0, signaller.id);\n      bufferMessage(prepare(args));\n    };\n  } // initialise the signaller id\n\n\n  signaller.id = (opts || {}).id || cuid();\n  /**\n    #### `isMaster(targetId) => Boolean`\n     A simple function that indicates whether the local signaller is the master\n    for it's relationship with peer signaller indicated by `targetId`.  Roles\n    are determined at the point at which signalling peers discover each other,\n    and are simply worked out by whichever peer has the lowest signaller id\n    when lexigraphically sorted.\n     For example, if we have two signaller peers that have discovered each\n    others with the following ids:\n     - `b11f4fd0-feb5-447c-80c8-c51d8c3cced2`\n    - `8a07f82e-49a5-4b9b-a02e-43d911382be6`\n     They would be assigned roles:\n     - `b11f4fd0-feb5-447c-80c8-c51d8c3cced2`\n    - `8a07f82e-49a5-4b9b-a02e-43d911382be6` (master)\n   **/\n\n  signaller.isMaster = function (targetId) {\n    var peer = peers.get(targetId);\n    return peer && peer.roleIdx !== 0;\n  };\n  /**\n    #### `send(args*)`\n     Prepare a message for sending, e.g.:\n     ```js\n    signaller.send('/foo', 'bar');\n    ```\n   **/\n\n\n  signaller.send = function () {\n    var args = [].slice.call(arguments); // inject the metadata\n\n    args.splice(1, 0, signaller.id); // send the message\n\n    bufferMessage(prepare(args));\n  };\n  /**\n    #### `to(targetId)`\n     Use the `to` function to send a message to the specified target peer.\n    A large parge of negotiating a WebRTC peer connection involves direct\n    communication between two parties which must be done by the signalling\n    server.  The `to` function provides a simple way to provide a logical\n    communication channel between the two parties:\n     ```js\n    var send = signaller.to('e95fa05b-9062-45c6-bfa2-5055bf6625f4').send;\n     // create an offer on a local peer connection\n    pc.createOffer(\n      function(desc) {\n        // set the local description using the offer sdp\n        // if this occurs successfully send this to our peer\n        pc.setLocalDescription(\n          desc,\n          function() {\n            send('/sdp', desc);\n          },\n          handleFail\n        );\n      },\n      handleFail\n    );\n    ```\n   **/\n\n\n  signaller.to = function (targetId) {\n    return {\n      send: createToMessage(['/to', targetId])\n    };\n  };\n  /**\n    ### Signaller Internals\n     The following functions are designed for use by signallers that are built\n    on top of this base signaller.\n  **/\n\n  /**\n    #### `_announce()`\n     The internal function that constructs the `/announce` message and triggers\n    the `local:announce` event.\n   **/\n\n\n  signaller._announce = function () {\n    signaller.send('/announce', attributes);\n    signaller('local:announce', attributes);\n  };\n  /**\n    #### `_leave()`\n     The internal function that should be called when a peer gracefully leaves\n    the call. This will send a `/leave` message to the other peer indicating that\n    this peer connection should be closed\n   **/\n\n\n  signaller._leave = function () {\n    signaller.send('/leave', {\n      id: signaller.id\n    });\n  };\n  /**\n    #### `_process(data)`\n    **/\n\n\n  signaller._process = require('./process')(signaller);\n  /**\n    #### `_update`\n     Internal function that updates core announce attributes with\n    updated data.\n  **/\n\n  signaller._update = function (data) {\n    extend(attributes, data, {\n      id: signaller.id\n    });\n  }; // set the autoreply flag\n\n\n  signaller.autoreply = autoreply === undefined || autoreply;\n  return signaller;\n};","map":null,"metadata":{},"sourceType":"script"}