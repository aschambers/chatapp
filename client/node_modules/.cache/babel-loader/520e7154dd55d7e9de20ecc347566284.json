{"ast":null,"code":"/* jshint node: true */\n'use strict';\n\nvar detect = require('rtc-core/detect');\n\nvar extend = require('cog/extend');\n\nvar mbus = require('mbus');\n\nvar getable = require('cog/getable');\n\nvar uuid = require('cuid');\n\nvar pull = require('pull-stream');\n\nvar pushable = require('pull-pushable');\n\nvar prepare = require('rtc-signal/prepare');\n\nvar createQueue = require('pull-pushable'); // ready state constants\n\n\nvar RS_DISCONNECTED = 0;\nvar RS_CONNECTING = 1;\nvar RS_CONNECTED = 2; // initialise signaller metadata so we don't have to include the package.json\n// TODO: make this checkable with some kind of prepublish script\n\nvar metadata = {\n  version: '6.3.0'\n};\n/**\n  # rtc-signaller\n\n  The `rtc-signaller` module provides a transportless signalling\n  mechanism for WebRTC.\n\n  ## Purpose\n\n  <<< docs/purpose.md\n\n  ## Getting Started\n\n  While the signaller is capable of communicating by a number of different\n  messengers (i.e. anything that can send and receive messages over a wire)\n  it comes with support for understanding how to connect to an\n  [rtc-switchboard](https://github.com/rtc-io/rtc-switchboard) out of the box.\n\n  The following code sample demonstrates how:\n\n  <<< examples/getting-started.js\n\n  <<< docs/events.md\n\n  <<< docs/signalflow-diagrams.md\n\n  <<< docs/identifying-participants.md\n\n  ## Reference\n\n  The `rtc-signaller` module is designed to be used primarily in a functional\n  way and when called it creates a new signaller that will enable\n  you to communicate with other peers via your messaging network.\n\n  ```js\n  // create a signaller from something that knows how to send messages\n  var signaller = require('rtc-signaller')(messenger);\n  ```\n\n  As demonstrated in the getting started guide, you can also pass through\n  a string value instead of a messenger instance if you simply want to\n  connect to an existing `rtc-switchboard` instance.\n\n**/\n\nmodule.exports = function (messenger, opts) {\n  var autoconnect = (opts || {}).autoconnect;\n  var reconnect = (opts || {}).reconnect;\n  var queue = createQueue();\n  var connectionCount = 0; // create the signaller\n\n  var signaller = require('rtc-signal/signaller')(opts, bufferMessage);\n\n  var announced = false;\n  var announceTimer = 0;\n  var readyState = RS_DISCONNECTED;\n\n  function bufferMessage(message) {\n    queue.push(message); // if we are not connected (and should autoconnect), then attempt connection\n\n    if (readyState === RS_DISCONNECTED && (autoconnect === undefined || autoconnect)) {\n      connect();\n    }\n  }\n\n  function handleDisconnect() {\n    if (reconnect === undefined || reconnect) {\n      setTimeout(connect, 50);\n    }\n  }\n  /**\n    ### `signaller.connect()`\n     Manually connect the signaller using the supplied messenger.\n     __NOTE:__ This should never have to be called if the default setting\n    for `autoconnect` is used.\n  **/\n\n\n  var connect = signaller.connect = function () {\n    // if we are already connecting then do nothing\n    if (readyState === RS_CONNECTING) {\n      return;\n    } // initiate the messenger\n\n\n    readyState = RS_CONNECTING;\n    messenger(function (err, source, sink) {\n      if (err) {\n        readyState = RS_DISCONNECTED;\n        return signaller('error', err);\n      } // increment the connection count\n\n\n      connectionCount += 1; // flag as connected\n\n      readyState = RS_CONNECTED; // pass messages to the processor\n\n      pull(source, // monitor disconnection\n      pull.through(null, function () {\n        queue = createQueue();\n        readyState = RS_DISCONNECTED;\n        signaller('disconnected');\n      }), pull.drain(signaller._process)); // pass the queue to the sink\n\n      pull(queue, sink); // handle disconnection\n\n      signaller.removeListener('disconnected', handleDisconnect);\n      signaller.on('disconnected', handleDisconnect); // trigger the connected event\n\n      signaller('connected'); // if this is a reconnection, then reannounce\n\n      if (announced && connectionCount > 1) {\n        signaller._announce();\n      }\n    });\n  };\n  /**\n    ### announce(data?)\n     The `announce` function of the signaller will pass an `/announce` message\n    through the messenger network.  When no additional data is supplied to\n    this function then only the id of the signaller is sent to all active\n    members of the messenging network.\n     #### Joining Rooms\n     To join a room using an announce call you simply provide the name of the\n    room you wish to join as part of the data block that you annouce, for\n    example:\n     ```js\n    signaller.announce({ room: 'testroom' });\n    ```\n     Signalling servers (such as\n    [rtc-switchboard](https://github.com/rtc-io/rtc-switchboard)) will then\n    place your peer connection into a room with other peers that have also\n    announced in this room.\n     Once you have joined a room, the server will only deliver messages that\n    you `send` to other peers within that room.\n     #### Providing Additional Announce Data\n     There may be instances where you wish to send additional data as part of\n    your announce message in your application.  For instance, maybe you want\n    to send an alias or nick as part of your announce message rather than just\n    use the signaller's generated id.\n     If for instance you were writing a simple chat application you could join\n    the `webrtc` room and tell everyone your name with the following announce\n    call:\n     ```js\n    signaller.announce({\n      room: 'webrtc',\n      nick: 'Damon'\n    });\n    ```\n     #### Announcing Updates\n     The signaller is written to distinguish between initial peer announcements\n    and peer data updates (see the docs on the announce handler below). As\n    such it is ok to provide any data updates using the announce method also.\n     For instance, I could send a status update as an announce message to flag\n    that I am going offline:\n     ```js\n    signaller.announce({ status: 'offline' });\n    ```\n   **/\n\n\n  signaller.announce = function (data) {\n    announced = true;\n\n    signaller._update(data);\n\n    clearTimeout(announceTimer); // send the attributes over the network\n\n    return announceTimer = setTimeout(signaller._announce, (opts || {}).announceDelay || 10);\n  };\n  /**\n    ### leave()\n     Tell the signalling server we are leaving.  Calling this function is\n    usually not required though as the signalling server should issue correct\n    `/leave` messages when it detects a disconnect event.\n   **/\n\n\n  signaller.leave = signaller.close = function () {\n    // send the leave signal\n    signaller.send('/leave', {\n      id: signaller.id\n    }); // stop announcing on reconnect\n\n    signaller.removeListener('disconnected', handleDisconnect);\n    signaller.removeListener('connected', signaller._announce); // end our current queue\n\n    queue.end(); // set connected to false\n\n    readyState = RS_DISCONNECTED;\n  }; // update the signaller agent\n\n\n  signaller._update({\n    agent: 'signaller@' + metadata.version\n  }); // autoconnect\n\n\n  if (autoconnect === undefined || autoconnect) {\n    connect();\n  }\n\n  return signaller;\n};","map":null,"metadata":{},"sourceType":"script"}