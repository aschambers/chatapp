{"ast":null,"code":"var common = require('./common.js');\n\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\nLame = require('./Lame.js');\nPresets = require('./Presets.js');\nGainAnalysis = require('./GainAnalysis.js');\nQuantizePVT = require('./QuantizePVT.js');\nQuantize = require('./Quantize.js');\nTakehiro = require('./Takehiro.js');\nReservoir = require('./Reservoir.js');\nMPEGMode = require('./MPEGMode.js');\nBitStream = require('./BitStream.js');\n\nvar Encoder = require('./Encoder.js');\n\nvar Version = require('./Version.js');\n\nvar VBRTag = require('./VBRTag.js');\n\nfunction GetAudio() {\n  var parse;\n  var mpg;\n\n  this.setModules = function (parse2, mpg2) {\n    parse = parse2;\n    mpg = mpg2;\n  };\n}\n\nfunction Parse() {\n  var ver;\n  var id3;\n  var pre;\n\n  this.setModules = function (ver2, id32, pre2) {\n    ver = ver2;\n    id3 = id32;\n    pre = pre2;\n  };\n}\n\nfunction MPGLib() {}\n\nfunction ID3Tag() {\n  var bits;\n  var ver;\n\n  this.setModules = function (_bits, _ver) {\n    bits = _bits;\n    ver = _ver;\n  };\n}\n\nfunction Mp3Encoder(channels, samplerate, kbps) {\n  if (arguments.length != 3) {\n    console.error('WARN: Mp3Encoder(channels, samplerate, kbps) not specified');\n    channels = 1;\n    samplerate = 44100;\n    kbps = 128;\n  }\n\n  var lame = new Lame();\n  var gaud = new GetAudio();\n  var ga = new GainAnalysis();\n  var bs = new BitStream();\n  var p = new Presets();\n  var qupvt = new QuantizePVT();\n  var qu = new Quantize();\n  var vbr = new VBRTag();\n  var ver = new Version();\n  var id3 = new ID3Tag();\n  var rv = new Reservoir();\n  var tak = new Takehiro();\n  var parse = new Parse();\n  var mpg = new MPGLib();\n  lame.setModules(ga, bs, p, qupvt, qu, vbr, ver, id3, mpg);\n  bs.setModules(ga, mpg, ver, vbr);\n  id3.setModules(bs, ver);\n  p.setModules(lame);\n  qu.setModules(bs, rv, qupvt, tak);\n  qupvt.setModules(tak, rv, lame.enc.psy);\n  rv.setModules(bs);\n  tak.setModules(qupvt);\n  vbr.setModules(lame, bs, ver);\n  gaud.setModules(parse, mpg);\n  parse.setModules(ver, id3, p);\n  var gfp = lame.lame_init();\n  gfp.num_channels = channels;\n  gfp.in_samplerate = samplerate;\n  gfp.brate = kbps;\n  gfp.mode = MPEGMode.STEREO;\n  gfp.quality = 3;\n  gfp.bWriteVbrTag = false;\n  gfp.disable_reservoir = true;\n  gfp.write_id3tag_automatic = false;\n  var retcode = lame.lame_init_params(gfp);\n  assert(0 == retcode);\n  var maxSamples = 1152;\n  var mp3buf_size = 0 | 1.25 * maxSamples + 7200;\n  var mp3buf = new_byte(mp3buf_size);\n\n  this.encodeBuffer = function (left, right) {\n    if (channels == 1) {\n      right = left;\n    }\n\n    assert(left.length == right.length);\n\n    if (left.length > maxSamples) {\n      maxSamples = left.length;\n      mp3buf_size = 0 | 1.25 * maxSamples + 7200;\n      mp3buf = new_byte(mp3buf_size);\n    }\n\n    var _sz = lame.lame_encode_buffer(gfp, left, right, left.length, mp3buf, 0, mp3buf_size);\n\n    return new Int8Array(mp3buf.subarray(0, _sz));\n  };\n\n  this.flush = function () {\n    var _sz = lame.lame_encode_flush(gfp, mp3buf, 0, mp3buf_size);\n\n    return new Int8Array(mp3buf.subarray(0, _sz));\n  };\n}\n\nfunction WavHeader() {\n  this.dataOffset = 0;\n  this.dataLen = 0;\n  this.channels = 0;\n  this.sampleRate = 0;\n}\n\nfunction fourccToInt(fourcc) {\n  return fourcc.charCodeAt(0) << 24 | fourcc.charCodeAt(1) << 16 | fourcc.charCodeAt(2) << 8 | fourcc.charCodeAt(3);\n}\n\nWavHeader.RIFF = fourccToInt(\"RIFF\");\nWavHeader.WAVE = fourccToInt(\"WAVE\");\nWavHeader.fmt_ = fourccToInt(\"fmt \");\nWavHeader.data = fourccToInt(\"data\");\n\nWavHeader.readHeader = function (dataView) {\n  var w = new WavHeader();\n  var header = dataView.getUint32(0, false);\n\n  if (WavHeader.RIFF != header) {\n    return;\n  }\n\n  var fileLen = dataView.getUint32(4, true);\n\n  if (WavHeader.WAVE != dataView.getUint32(8, false)) {\n    return;\n  }\n\n  if (WavHeader.fmt_ != dataView.getUint32(12, false)) {\n    return;\n  }\n\n  var fmtLen = dataView.getUint32(16, true);\n  var pos = 16 + 4;\n\n  switch (fmtLen) {\n    case 16:\n    case 18:\n      w.channels = dataView.getUint16(pos + 2, true);\n      w.sampleRate = dataView.getUint32(pos + 4, true);\n      break;\n\n    default:\n      throw 'extended fmt chunk not implemented';\n  }\n\n  pos += fmtLen;\n  var data = WavHeader.data;\n  var len = 0;\n\n  while (data != header) {\n    header = dataView.getUint32(pos, false);\n    len = dataView.getUint32(pos + 4, true);\n\n    if (data == header) {\n      break;\n    }\n\n    pos += len + 8;\n  }\n\n  w.dataLen = len;\n  w.dataOffset = pos + 8;\n  return w;\n};\n\nmodule.exports.Mp3Encoder = Mp3Encoder;\nmodule.exports.WavHeader = WavHeader;","map":null,"metadata":{},"sourceType":"script"}