{"ast":null,"code":"/*\n *      bit reservoir source file\n *\n *      Copyright (c) 1999-2000 Mark Taylor\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: Reservoir.java,v 1.9 2011/05/24 20:48:06 kenchis Exp $ */\n//package mp3;\n\n/**\n * ResvFrameBegin:<BR>\n * Called (repeatedly) at the beginning of a frame. Updates the maximum size of\n * the reservoir, and checks to make sure main_data_begin was set properly by\n * the formatter<BR>\n * Background information:\n * \n * This is the original text from the ISO standard. Because of sooo many bugs\n * and irritations correcting comments are added in brackets []. A '^W' means\n * you should remove the last word.\n * \n * <PRE>\n *  1. The following rule can be used to calculate the maximum\n *     number of bits used for one granule [^W frame]:<BR>\n *     At the highest possible bitrate of Layer III (320 kbps\n *     per stereo signal [^W^W^W], 48 kHz) the frames must be of\n *     [^W^W^W are designed to have] constant length, i.e.\n *     one buffer [^W^W the frame] length is:<BR>\n * \n *         320 kbps * 1152/48 kHz = 7680 bit = 960 byte\n * \n *     This value is used as the maximum buffer per channel [^W^W] at\n *     lower bitrates [than 320 kbps]. At 64 kbps mono or 128 kbps\n *     stereo the main granule length is 64 kbps * 576/48 kHz = 768 bit\n *     [per granule and channel] at 48 kHz sampling frequency.\n *     This means that there is a maximum deviation (short time buffer\n *     [= reservoir]) of 7680 - 2*2*768 = 4608 bits is allowed at 64 kbps.\n *     The actual deviation is equal to the number of bytes [with the\n *     meaning of octets] denoted by the main_data_end offset pointer.\n *     The actual maximum deviation is (2^9-1)*8 bit = 4088 bits\n *     [for MPEG-1 and (2^8-1)*8 bit for MPEG-2, both are hard limits].\n *     ... The xchange of buffer bits between the left and right channel\n *     is allowed without restrictions [exception: dual channel].\n *     Because of the [constructed] constraint on the buffer size\n *     main_data_end is always set to 0 in the case of bit_rate_index==14,\n *     i.e. data rate 320 kbps per stereo signal [^W^W^W]. In this case\n *     all data are allocated between adjacent header [^W sync] words\n *     [, i.e. there is no buffering at all].\n * </PRE>\n */\nvar common = require('./common.js');\n\nvar assert = common.assert;\n\nfunction Reservoir() {\n  var bs;\n\n  this.setModules = function (_bs) {\n    bs = _bs;\n  };\n\n  this.ResvFrameBegin = function (gfp, mean_bits) {\n    var gfc = gfp.internal_flags;\n    var maxmp3buf;\n    var l3_side = gfc.l3_side;\n    var frameLength = bs.getframebits(gfp);\n    mean_bits.bits = (frameLength - gfc.sideinfo_len * 8) / gfc.mode_gr;\n    /**\n     * <PRE>\n     *  Meaning of the variables:\n     *      resvLimit: (0, 8, ..., 8*255 (MPEG-2), 8*511 (MPEG-1))\n     *          Number of bits can be stored in previous frame(s) due to\n     *          counter size constaints\n     *      maxmp3buf: ( ??? ... 8*1951 (MPEG-1 and 2), 8*2047 (MPEG-2.5))\n     *          Number of bits allowed to encode one frame (you can take 8*511 bit\n     *          from the bit reservoir and at most 8*1440 bit from the current\n     *          frame (320 kbps, 32 kHz), so 8*1951 bit is the largest possible\n     *          value for MPEG-1 and -2)\n     * \n     *          maximum allowed granule/channel size times 4 = 8*2047 bits.,\n     *          so this is the absolute maximum supported by the format.\n     * \n     * \n     *      fullFrameBits:  maximum number of bits available for encoding\n     *                      the current frame.\n     * \n     *      mean_bits:      target number of bits per granule.\n     * \n     *      frameLength:\n     * \n     *      gfc.ResvMax:   maximum allowed reservoir\n     * \n     *      gfc.ResvSize:  current reservoir size\n     * \n     *      l3_side.resvDrain_pre:\n     *         ancillary data to be added to previous frame:\n     *         (only usefull in VBR modes if it is possible to have\n     *         maxmp3buf < fullFrameBits)).  Currently disabled,\n     *         see #define NEW_DRAIN\n     *         2010-02-13: RH now enabled, it seems to be needed for CBR too,\n     *                     as there exists one example, where the FhG decoder\n     *                     can't decode a -b320 CBR file anymore.\n     * \n     *      l3_side.resvDrain_post:\n     *         ancillary data to be added to this frame:\n     * \n     * </PRE>\n     */\n\n    /* main_data_begin has 9 bits in MPEG-1, 8 bits MPEG-2 */\n\n    var resvLimit = 8 * 256 * gfc.mode_gr - 8;\n    /*\n     * maximum allowed frame size. dont use more than this number of bits,\n     * even if the frame has the space for them:\n     */\n\n    if (gfp.brate > 320) {\n      /* in freeformat the buffer is constant */\n      maxmp3buf = 8 * int(gfp.brate * 1000 / (gfp.out_samplerate / 1152) / 8 + .5);\n    } else {\n      /*\n       * all mp3 decoders should have enough buffer to handle this value:\n       * size of a 320kbps 32kHz frame\n       */\n      maxmp3buf = 8 * 1440;\n      /*\n       * Bouvigne suggests this more lax interpretation of the ISO doc\n       * instead of using 8*960.\n       */\n\n      if (gfp.strict_ISO) {\n        maxmp3buf = 8 * int(320000 / (gfp.out_samplerate / 1152) / 8 + .5);\n      }\n    }\n\n    gfc.ResvMax = maxmp3buf - frameLength;\n    if (gfc.ResvMax > resvLimit) gfc.ResvMax = resvLimit;\n    if (gfc.ResvMax < 0 || gfp.disable_reservoir) gfc.ResvMax = 0;\n    var fullFrameBits = mean_bits.bits * gfc.mode_gr + Math.min(gfc.ResvSize, gfc.ResvMax);\n    if (fullFrameBits > maxmp3buf) fullFrameBits = maxmp3buf;\n    assert(0 == gfc.ResvMax % 8);\n    assert(gfc.ResvMax >= 0);\n    l3_side.resvDrain_pre = 0; // frame analyzer code\n\n    if (gfc.pinfo != null) {\n      /*\n       * expected bits per channel per granule [is this also right for\n       * mono/stereo, MPEG-1/2 ?]\n       */\n      gfc.pinfo.mean_bits = mean_bits.bits / 2;\n      gfc.pinfo.resvsize = gfc.ResvSize;\n    }\n\n    return fullFrameBits;\n  };\n  /**\n   * returns targ_bits: target number of bits to use for 1 granule<BR>\n   * extra_bits: amount extra available from reservoir<BR>\n   * Mark Taylor 4/99\n   */\n\n\n  this.ResvMaxBits = function (gfp, mean_bits, targ_bits, cbr) {\n    var gfc = gfp.internal_flags;\n    var add_bits;\n    var ResvSize = gfc.ResvSize,\n        ResvMax = gfc.ResvMax;\n    /* compensate the saved bits used in the 1st granule */\n\n    if (cbr != 0) ResvSize += mean_bits;\n    if ((gfc.substep_shaping & 1) != 0) ResvMax *= 0.9;\n    targ_bits.bits = mean_bits;\n    /* extra bits if the reservoir is almost full */\n\n    if (ResvSize * 10 > ResvMax * 9) {\n      add_bits = ResvSize - ResvMax * 9 / 10;\n      targ_bits.bits += add_bits;\n      gfc.substep_shaping |= 0x80;\n    } else {\n      add_bits = 0;\n      gfc.substep_shaping &= 0x7f;\n      /*\n       * build up reservoir. this builds the reservoir a little slower\n       * than FhG. It could simple be mean_bits/15, but this was rigged to\n       * always produce 100 (the old value) at 128kbs\n       */\n\n      if (!gfp.disable_reservoir && 0 == (gfc.substep_shaping & 1)) targ_bits.bits -= .1 * mean_bits;\n    }\n    /* amount from the reservoir we are allowed to use. ISO says 6/10 */\n\n\n    var extra_bits = ResvSize < gfc.ResvMax * 6 / 10 ? ResvSize : gfc.ResvMax * 6 / 10;\n    extra_bits -= add_bits;\n    if (extra_bits < 0) extra_bits = 0;\n    return extra_bits;\n  };\n  /**\n   * Called after a granule's bit allocation. Readjusts the size of the\n   * reservoir to reflect the granule's usage.\n   */\n\n\n  this.ResvAdjust = function (gfc, gi) {\n    gfc.ResvSize -= gi.part2_3_length + gi.part2_length;\n  };\n  /**\n   * Called after all granules in a frame have been allocated. Makes sure that\n   * the reservoir size is within limits, possibly by adding stuffing bits.\n   */\n\n\n  this.ResvFrameEnd = function (gfc, mean_bits) {\n    var over_bits;\n    var l3_side = gfc.l3_side;\n    gfc.ResvSize += mean_bits * gfc.mode_gr;\n    var stuffingBits = 0;\n    l3_side.resvDrain_post = 0;\n    l3_side.resvDrain_pre = 0;\n    /* we must be byte aligned */\n\n    if ((over_bits = gfc.ResvSize % 8) != 0) stuffingBits += over_bits;\n    over_bits = gfc.ResvSize - stuffingBits - gfc.ResvMax;\n\n    if (over_bits > 0) {\n      assert(0 == over_bits % 8);\n      assert(over_bits >= 0);\n      stuffingBits += over_bits;\n    }\n    /*\n     * NOTE: enabling the NEW_DRAIN code fixes some problems with FhG\n     * decoder shipped with MS Windows operating systems. Using this, it is\n     * even possible to use Gabriel's lax buffer consideration again, which\n     * assumes, any decoder should have a buffer large enough for a 320 kbps\n     * frame at 32 kHz sample rate.\n     * \n     * old drain code: lame -b320 BlackBird.wav --. does not play with\n     * GraphEdit.exe using FhG decoder V1.5 Build 50\n     * \n     * new drain code: lame -b320 BlackBird.wav --. plays fine with\n     * GraphEdit.exe using FhG decoder V1.5 Build 50\n     * \n     * Robert Hegemann, 2010-02-13.\n     */\n\n    /*\n     * drain as many bits as possible into previous frame ancillary data In\n     * particular, in VBR mode ResvMax may have changed, and we have to make\n     * sure main_data_begin does not create a reservoir bigger than ResvMax\n     * mt 4/00\n     */\n\n\n    {\n      var mdb_bytes = Math.min(l3_side.main_data_begin * 8, stuffingBits) / 8;\n      l3_side.resvDrain_pre += 8 * mdb_bytes;\n      stuffingBits -= 8 * mdb_bytes;\n      gfc.ResvSize -= 8 * mdb_bytes;\n      l3_side.main_data_begin -= mdb_bytes;\n    }\n    /* drain the rest into this frames ancillary data */\n\n    l3_side.resvDrain_post += stuffingBits;\n    gfc.ResvSize -= stuffingBits;\n  };\n}\n\nmodule.exports = Reservoir;","map":null,"metadata":{},"sourceType":"script"}