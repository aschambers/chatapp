{"ast":null,"code":"window.myDebug = require('debug');\n\nvar Peer = require('simple-peer');\n\nvar Emitter = require('component-emitter');\n\nvar parser = require('socket.io-p2p-parser');\n\nvar toArray = require('to-array');\n\nvar hasBin = require('has-binary');\n\nvar bind = require('component-bind');\n\nvar debug = require('debug')('socket');\n\nvar hat = require('hat');\n\nvar extend = require('extend.js');\n\nvar rtcSupport = require('webrtcsupport');\n\nvar emitfn = Emitter.prototype.emit;\n\nfunction Socketiop2p(socket, opts, cb) {\n  var self = this;\n  self.useSockets = true;\n  self.usePeerConnection = false;\n  self.decoder = new parser.Decoder(this);\n  self.decoder.on('decoded', bind(this, this.ondecoded));\n  self.socket = socket;\n  self.cb = cb;\n  self._peers = {};\n  self.readyPeers = 0;\n  self.ready = false;\n  self._peerEvents = {\n    upgrade: 1,\n    error: 1,\n    peer_signal: 1,\n    peer_ready: 1,\n    stream: 1\n  };\n  var defaultOpts = {\n    autoUpgrade: true,\n    numClients: 5\n  };\n  self.opts = extend(defaultOpts, opts || {});\n  self.peerOpts = self.opts.peerOpts || {};\n  self.numConnectedClients;\n  socket.on('numClients', function (numClients) {\n    self.peerId = socket.io.engine.id;\n    self.numConnectedClients = numClients;\n\n    if (rtcSupport.supportDataChannel) {\n      generateOffers(function (offers) {\n        var offerObj = {\n          offers: offers,\n          fromPeerId: self.peerId\n        };\n        socket.emit('offers', offerObj);\n      });\n    }\n\n    function generateOffers(cb) {\n      var offers = [];\n\n      for (var i = 0; i < self.opts.numClients; ++i) {\n        generateOffer();\n      }\n\n      function generateOffer() {\n        var offerId = hat(160);\n        var peerOpts = extend(self.peerOpts, {\n          initiator: true\n        });\n        var peer = self._peers[offerId] = new Peer(peerOpts);\n        peer.setMaxListeners(50);\n        self.setupPeerEvents(peer);\n        peer.on('signal', function (offer) {\n          offers.push({\n            offer: offer,\n            offerId: offerId\n          });\n          checkDone();\n        });\n        peer.on('error', function (err) {\n          emitfn.call(this, 'peer-error', err);\n          debug('Error in peer %s', err);\n        });\n      }\n\n      function checkDone() {\n        if (offers.length === self.opts.numClients) {\n          debug('generated %s offers', self.opts.numClients);\n          cb(offers);\n        }\n      }\n    }\n  });\n  socket.on('offer', function (data) {\n    var peerOpts = extend(self.peerOpts, {\n      initiator: false\n    });\n    var peer = self._peers[data.fromPeerId] = new Peer(peerOpts);\n    self.numConnectedClients++;\n    peer.setMaxListeners(50);\n    self.setupPeerEvents(peer);\n    peer.on('signal', function (signalData) {\n      var signalObj = {\n        signal: signalData,\n        offerId: data.offerId,\n        fromPeerId: self.peerId,\n        toPeerId: data.fromPeerId\n      };\n      socket.emit('peer-signal', signalObj);\n    });\n    peer.on('error', function (err) {\n      emitfn.call(this, 'peer-error', err);\n      debug('Error in peer %s', err);\n    });\n    peer.signal(data.offer);\n  });\n  socket.on('peer-signal', function (data) {\n    // Select peer from offerId if exists\n    var peer = self._peers[data.offerId] || self._peers[data.fromPeerId];\n    peer.on('signal', function signal(signalData) {\n      var signalObj = {\n        signal: signalData,\n        offerId: data.offerId,\n        fromPeerId: self.peerId,\n        toPeerId: data.fromPeerId\n      };\n      socket.emit('peer-signal', signalObj);\n    });\n    peer.signal(data.signal);\n  });\n  self.on('peer_ready', function (peer) {\n    self.readyPeers++;\n\n    if (self.readyPeers >= self.numConnectedClients && !self.ready) {\n      self.ready = true;\n      if (self.opts.autoUpgrade) self.usePeerConnection = true;\n      if (typeof self.cb === 'function') self.cb();\n      self.emit('upgrade');\n    }\n  });\n}\n\nEmitter(Socketiop2p.prototype);\n\nSocketiop2p.prototype.setupPeerEvents = function (peer) {\n  var self = this;\n  peer.on('connect', function (peer) {\n    self.emit('peer_ready', peer);\n  });\n  peer.on('data', function (data) {\n    if (this.destroyed) return;\n    self.decoder.add(data);\n  });\n  peer.on('stream', function (stream) {\n    self.emit('stream', stream);\n  });\n};\n/**\n * Overwride the inheritted 'on' method to add a listener to the socket instance\n * that emits the event on the Socketio event loop\n**/\n\n\nSocketiop2p.prototype.on = function (type, listener) {\n  var self = this;\n  this.socket.addEventListener(type, function (data) {\n    emitfn.call(self, type, data);\n  });\n  this.addEventListener(type, listener);\n};\n\nSocketiop2p.prototype.emit = function (data, cb) {\n  var self = this;\n  var argsObj = cb || {};\n  var encoder = new parser.Encoder();\n\n  if (this._peerEvents.hasOwnProperty(data) || argsObj.fromSocket) {\n    emitfn.apply(this, arguments);\n  } else if (this.usePeerConnection || !this.useSockets) {\n    var args = toArray(arguments);\n    var parserType = parser.EVENT; // default\n\n    if (hasBin(args)) {\n      parserType = parser.BINARY_EVENT;\n    } // binary\n\n\n    var packet = {\n      type: parserType,\n      data: args\n    };\n    encoder.encode(packet, function (encodedPackets) {\n      if (encodedPackets[1] instanceof ArrayBuffer) {\n        self._sendArray(encodedPackets);\n      } else if (encodedPackets) {\n        for (var i = 0; i < encodedPackets.length; i++) {\n          self._send(encodedPackets[i]);\n        }\n      } else {\n        throw new Error('Encoding error');\n      }\n    });\n  } else {\n    this.socket.emit(data, cb);\n  }\n};\n/**\n* If the second packet is a binary attachment,\n* swap out the attachment number for the number of chunks in the array\n* before sending the new packet and chunks\n**/\n\n\nSocketiop2p.prototype._sendArray = function (arr) {\n  var firstPacket = arr[0];\n  var interval = 5000;\n  var arrLength = arr[1].byteLength;\n  var nChunks = Math.ceil(arrLength / interval);\n  var packetData = firstPacket.substr(0, 1) + nChunks + firstPacket.substr(firstPacket.indexOf('-'));\n\n  this._send(packetData);\n\n  this.binarySlice(arr[1], interval, this._send);\n};\n\nSocketiop2p.prototype._send = function (data) {\n  var self = this;\n\n  for (var peerId in self._peers) {\n    var peer = self._peers[peerId];\n\n    if (peer._channelReady) {\n      peer.send(data);\n    }\n  }\n};\n\nSocketiop2p.prototype.binarySlice = function (arr, interval, callback) {\n  for (var start = 0; start < arr.byteLength; start += interval) {\n    var chunk = arr.slice(start, start + interval);\n    callback.call(this, chunk);\n  }\n};\n\nSocketiop2p.prototype.ondecoded = function (packet) {\n  var args = packet.data || [];\n  emitfn.apply(this, args);\n};\n\nSocketiop2p.prototype.disconnect = function () {\n  for (var peerId in this._peers) {\n    var peer = this._peers[peerId];\n    peer.destroy();\n    this.socket.disconnect();\n  }\n};\n/**\n * Use peerConnection instead of socket.io one.\n**/\n\n\nSocketiop2p.prototype.upgrade = function () {\n  this.usePeerConnection = true;\n};\n\nmodule.exports = Socketiop2p;","map":null,"metadata":{},"sourceType":"script"}