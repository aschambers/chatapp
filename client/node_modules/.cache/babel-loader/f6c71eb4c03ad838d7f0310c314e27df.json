{"ast":null,"code":"var u = require('pull-core');\n\nvar sources = require('./sources');\n\nvar sinks = require('./sinks');\n\nvar prop = u.prop;\nvar id = u.id;\nvar tester = u.tester;\n\nvar map = exports.map = function (read, map) {\n  map = prop(map) || id;\n  return function (abort, cb) {\n    read(abort, function (end, data) {\n      try {\n        data = !end ? map(data) : null;\n      } catch (err) {\n        return read(err, function () {\n          return cb(err);\n        });\n      }\n\n      cb(end, data);\n    });\n  };\n};\n\nvar asyncMap = exports.asyncMap = function (read, map) {\n  if (!map) return read;\n  return function (end, cb) {\n    if (end) return read(end, cb); //abort\n\n    read(null, function (end, data) {\n      if (end) return cb(end, data);\n      map(data, cb);\n    });\n  };\n};\n\nvar paraMap = exports.paraMap = function (read, map, width) {\n  if (!map) return read;\n\n  var ended = false,\n      queue = [],\n      _cb;\n\n  function drain() {\n    if (!_cb) return;\n    var cb = _cb;\n    _cb = null;\n    if (queue.length) return cb(null, queue.shift());else if (ended && !n) return cb(ended);\n    _cb = cb;\n  }\n\n  function pull() {\n    read(null, function (end, data) {\n      if (end) {\n        ended = end;\n        return drain();\n      }\n\n      n++;\n      map(data, function (err, data) {\n        n--;\n        queue.push(data);\n        drain();\n      });\n      if (n < width && !ended) pull();\n    });\n  }\n\n  var n = 0;\n  return function (end, cb) {\n    if (end) return read(end, cb); //abort\n    //continue to read while there are less than 3 maps in flight\n\n    _cb = cb;\n    if (queue.length || ended) pull(), drain();else pull();\n  };\n  return highWaterMark(asyncMap(read, map), width);\n};\n\nvar filter = exports.filter = function (read, test) {\n  //regexp\n  test = tester(test);\n  return function next(end, cb) {\n    var sync,\n        loop = true;\n\n    while (loop) {\n      loop = false;\n      sync = true;\n      read(end, function (end, data) {\n        if (!end && !test(data)) return sync ? loop = true : next(end, cb);\n        cb(end, data);\n      });\n      sync = false;\n    }\n  };\n};\n\nvar filterNot = exports.filterNot = function (read, test) {\n  test = tester(test);\n  return filter(read, function (e) {\n    return !test(e);\n  });\n};\n\nvar through = exports.through = function (read, op, onEnd) {\n  var a = false;\n\n  function once(abort) {\n    if (a || !onEnd) return;\n    a = true;\n    onEnd(abort === true ? null : abort);\n  }\n\n  return function (end, cb) {\n    if (end) once(end);\n    return read(end, function (end, data) {\n      if (!end) op && op(data);else once(end);\n      cb(end, data);\n    });\n  };\n};\n\nvar take = exports.take = function (read, test, opts) {\n  opts = opts || {};\n  var last = opts.last || false; // whether the first item for which !test(item) should still pass\n\n  var ended = false;\n\n  if ('number' === typeof test) {\n    last = true;\n    var n = test;\n\n    test = function () {\n      return --n;\n    };\n  }\n\n  function terminate(cb) {\n    read(true, function (err) {\n      last = false;\n      cb(err || true);\n    });\n  }\n\n  return function (end, cb) {\n    if (ended) last ? terminate(cb) : cb(ended);else if (ended = end) read(ended, cb);else read(null, function (end, data) {\n      if (ended = ended || end) {\n        //last ? terminate(cb) :\n        cb(ended);\n      } else if (!test(data)) {\n        ended = true;\n        last ? cb(null, data) : terminate(cb);\n      } else cb(null, data);\n    });\n  };\n};\n\nvar unique = exports.unique = function (read, field, invert) {\n  field = prop(field) || id;\n  var seen = {};\n  return filter(read, function (data) {\n    var key = field(data);\n    if (seen[key]) return !!invert; //false, by default\n    else seen[key] = true;\n    return !invert; //true by default\n  });\n};\n\nvar nonUnique = exports.nonUnique = function (read, field) {\n  return unique(read, field, true);\n};\n\nvar group = exports.group = function (read, size) {\n  var ended;\n  size = size || 5;\n  var queue = [];\n  return function (end, cb) {\n    //this means that the upstream is sending an error.\n    if (end) return read(ended = end, cb); //this means that we read an end before.\n\n    if (ended) return cb(ended);\n    read(null, function next(end, data) {\n      if (ended = ended || end) {\n        if (!queue.length) return cb(ended);\n        var _queue = queue;\n        queue = [];\n        return cb(null, _queue);\n      }\n\n      queue.push(data);\n      if (queue.length < size) return read(null, next);\n      var _queue = queue;\n      queue = [];\n      cb(null, _queue);\n    });\n  };\n};\n\nvar flatten = exports.flatten = function (read) {\n  var _read;\n\n  return function (abort, cb) {\n    if (abort) {\n      _read ? _read(abort, function (err) {\n        read(err || abort, cb);\n      }) : read(abort, cb);\n    } else if (_read) nextChunk();else nextStream();\n\n    function nextChunk() {\n      _read(null, function (err, data) {\n        if (err === true) nextStream();else if (err) {\n          read(true, function (abortErr) {\n            // TODO: what do we do with the abortErr?\n            cb(err);\n          });\n        } else cb(null, data);\n      });\n    }\n\n    function nextStream() {\n      read(null, function (end, stream) {\n        if (end) return cb(end);\n        if (Array.isArray(stream) || stream && 'object' === typeof stream) stream = sources.values(stream);else if ('function' != typeof stream) throw new Error('expected stream of streams');\n        _read = stream;\n        nextChunk();\n      });\n    }\n  };\n};\n\nvar prepend = exports.prepend = function (read, head) {\n  return function (abort, cb) {\n    if (head !== null) {\n      if (abort) return read(abort, cb);\n      var _head = head;\n      head = null;\n      cb(null, _head);\n    } else {\n      read(abort, cb);\n    }\n  };\n}; //var drainIf = exports.drainIf = function (op, done) {\n//  sinks.drain(\n//}\n\n\nvar _reduce = exports._reduce = function (read, reduce, initial) {\n  return function (close, cb) {\n    if (close) return read(close, cb);\n    if (ended) return cb(ended);\n    sinks.drain(function (item) {\n      initial = reduce(initial, item);\n    }, function (err, data) {\n      ended = err || true;\n      if (!err) cb(null, initial);else cb(ended);\n    })(read);\n  };\n};\n\nvar nextTick = process.nextTick;\n\nvar highWaterMark = exports.highWaterMark = function (read, highWaterMark) {\n  var buffer = [],\n      waiting = [],\n      ended,\n      ending,\n      reading = false;\n  highWaterMark = highWaterMark || 10;\n\n  function readAhead() {\n    while (waiting.length && (buffer.length || ended)) waiting.shift()(ended, ended ? null : buffer.shift());\n\n    if (!buffer.length && ending) ended = ending;\n  }\n\n  function next() {\n    if (ended || ending || reading || buffer.length >= highWaterMark) return;\n    reading = true;\n    return read(ended || ending, function (end, data) {\n      reading = false;\n      ending = ending || end;\n      if (data != null) buffer.push(data);\n      next();\n      readAhead();\n    });\n  }\n\n  process.nextTick(next);\n  return function (end, cb) {\n    ended = ended || end;\n    waiting.push(cb);\n    next();\n    readAhead();\n  };\n};\n\nvar flatMap = exports.flatMap = function (read, mapper) {\n  mapper = mapper || id;\n  var queue = [],\n      ended;\n  return function (abort, cb) {\n    if (queue.length) return cb(null, queue.shift());else if (ended) return cb(ended);\n    read(abort, function next(end, data) {\n      if (end) ended = end;else {\n        var add = mapper(data);\n\n        while (add && add.length) queue.push(add.shift());\n      }\n      if (queue.length) cb(null, queue.shift());else if (ended) cb(ended);else read(null, next);\n    });\n  };\n};","map":null,"metadata":{},"sourceType":"script"}