{"ast":null,"code":"var common = require('./common.js');\n\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n/**\n * ENCDELAY The encoder delay.\n *\n * Minimum allowed is MDCTDELAY (see below)\n *\n * The first 96 samples will be attenuated, so using a value less than 96\n * will result in corrupt data for the first 96-ENCDELAY samples.\n *\n * suggested: 576 set to 1160 to sync with FhG.\n */\n\nEncoder.ENCDELAY = 576;\n/**\n * make sure there is at least one complete frame after the last frame\n * containing real data\n *\n * Using a value of 288 would be sufficient for a a very sophisticated\n * decoder that can decode granule-by-granule instead of frame by frame. But\n * lets not assume this, and assume the decoder will not decode frame N\n * unless it also has data for frame N+1\n */\n\nEncoder.POSTDELAY = 1152;\n/**\n * delay of the MDCT used in mdct.c original ISO routines had a delay of\n * 528! Takehiro's routines:\n */\n\nEncoder.MDCTDELAY = 48;\nEncoder.FFTOFFSET = 224 + Encoder.MDCTDELAY;\n/**\n * Most decoders, including the one we use, have a delay of 528 samples.\n */\n\nEncoder.DECDELAY = 528;\n/**\n * number of subbands\n */\n\nEncoder.SBLIMIT = 32;\n/**\n * parition bands bands\n */\n\nEncoder.CBANDS = 64;\n/**\n * number of critical bands/scale factor bands where masking is computed\n */\n\nEncoder.SBPSY_l = 21;\nEncoder.SBPSY_s = 12;\n/**\n * total number of scalefactor bands encoded\n */\n\nEncoder.SBMAX_l = 22;\nEncoder.SBMAX_s = 13;\nEncoder.PSFB21 = 6;\nEncoder.PSFB12 = 6;\n/**\n * FFT sizes\n */\n\nEncoder.BLKSIZE = 1024;\nEncoder.HBLKSIZE = Encoder.BLKSIZE / 2 + 1;\nEncoder.BLKSIZE_s = 256;\nEncoder.HBLKSIZE_s = Encoder.BLKSIZE_s / 2 + 1;\nEncoder.NORM_TYPE = 0;\nEncoder.START_TYPE = 1;\nEncoder.SHORT_TYPE = 2;\nEncoder.STOP_TYPE = 3;\n/**\n * <PRE>\n * Mode Extention:\n * When we are in stereo mode, there are 4 possible methods to store these\n * two channels. The stereo modes -m? are using a subset of them.\n *\n *  -ms: MPG_MD_LR_LR\n *  -mj: MPG_MD_LR_LR and MPG_MD_MS_LR\n *  -mf: MPG_MD_MS_LR\n *  -mi: all\n * </PRE>\n */\n\nEncoder.MPG_MD_LR_LR = 0;\nEncoder.MPG_MD_LR_I = 1;\nEncoder.MPG_MD_MS_LR = 2;\nEncoder.MPG_MD_MS_I = 3;\nEncoder.fircoef = [-0.0207887 * 5, -0.0378413 * 5, -0.0432472 * 5, -0.031183 * 5, 7.79609e-18 * 5, 0.0467745 * 5, 0.10091 * 5, 0.151365 * 5, 0.187098 * 5];\n\nfunction Encoder() {\n  var NewMDCT = require('./NewMDCT.js');\n\n  var III_psy_ratio = require('./III_psy_ratio.js');\n\n  var FFTOFFSET = Encoder.FFTOFFSET;\n  var MPG_MD_MS_LR = Encoder.MPG_MD_MS_LR; //BitStream bs;\n  //PsyModel psy;\n  //VBRTag vbr;\n  //QuantizePVT qupvt;\n\n  var bs = null;\n  this.psy = null;\n  var psy = null;\n  var vbr = null;\n  var qupvt = null; //public final void setModules(BitStream bs, PsyModel psy, QuantizePVT qupvt,\n  //    VBRTag vbr) {\n\n  this.setModules = function (_bs, _psy, _qupvt, _vbr) {\n    bs = _bs;\n    this.psy = _psy;\n    psy = _psy;\n    vbr = _vbr;\n    qupvt = _qupvt;\n  };\n\n  var newMDCT = new NewMDCT();\n  /***********************************************************************\n   *\n   * encoder and decoder delays\n   *\n   ***********************************************************************/\n\n  /**\n   * <PRE>\n   * layer III enc->dec delay:  1056 (1057?)   (observed)\n   * layer  II enc->dec delay:   480  (481?)   (observed)\n   *\n   * polyphase 256-16             (dec or enc)        = 240\n   * mdct      256+32  (9*32)     (dec or enc)        = 288\n   * total:    512+16\n   *\n   * My guess is that delay of polyphase filterbank is actualy 240.5\n   * (there are technical reasons for this, see postings in mp3encoder).\n   * So total Encode+Decode delay = ENCDELAY + 528 + 1\n   * </PRE>\n   */\n\n  /**\n   * auto-adjust of ATH, useful for low volume Gabriel Bouvigne 3 feb 2001\n   *\n   * modifies some values in gfp.internal_flags.ATH (gfc.ATH)\n   */\n  //private void adjust_ATH(final LameInternalFlags gfc) {\n\n  function adjust_ATH(gfc) {\n    var gr2_max, max_pow;\n\n    if (gfc.ATH.useAdjust == 0) {\n      gfc.ATH.adjust = 1.0;\n      /* no adjustment */\n\n      return;\n    }\n    /* jd - 2001 mar 12, 27, jun 30 */\n\n    /* loudness based on equal loudness curve; */\n\n    /* use granule with maximum combined loudness */\n\n\n    max_pow = gfc.loudness_sq[0][0];\n    gr2_max = gfc.loudness_sq[1][0];\n\n    if (gfc.channels_out == 2) {\n      max_pow += gfc.loudness_sq[0][1];\n      gr2_max += gfc.loudness_sq[1][1];\n    } else {\n      max_pow += max_pow;\n      gr2_max += gr2_max;\n    }\n\n    if (gfc.mode_gr == 2) {\n      max_pow = Math.max(max_pow, gr2_max);\n    }\n\n    max_pow *= 0.5;\n    /* max_pow approaches 1.0 for full band noise */\n\n    /* jd - 2001 mar 31, jun 30 */\n\n    /* user tuning of ATH adjustment region */\n\n    max_pow *= gfc.ATH.aaSensitivityP;\n    /*\n     * adjust ATH depending on range of maximum value\n     */\n\n    /* jd - 2001 feb27, mar12,20, jun30, jul22 */\n\n    /* continuous curves based on approximation */\n\n    /* to GB's original values. */\n\n    /* For an increase in approximate loudness, */\n\n    /* set ATH adjust to adjust_limit immediately */\n\n    /* after a delay of one frame. */\n\n    /* For a loudness decrease, reduce ATH adjust */\n\n    /* towards adjust_limit gradually. */\n\n    /* max_pow is a loudness squared or a power. */\n\n    if (max_pow > 0.03125) {\n      /* ((1 - 0.000625)/ 31.98) from curve below */\n      if (gfc.ATH.adjust >= 1.0) {\n        gfc.ATH.adjust = 1.0;\n      } else {\n        /* preceding frame has lower ATH adjust; */\n\n        /* ascend only to the preceding adjust_limit */\n\n        /* in case there is leading low volume */\n        if (gfc.ATH.adjust < gfc.ATH.adjustLimit) {\n          gfc.ATH.adjust = gfc.ATH.adjustLimit;\n        }\n      }\n\n      gfc.ATH.adjustLimit = 1.0;\n    } else {\n      /* adjustment curve */\n\n      /* about 32 dB maximum adjust (0.000625) */\n      var adj_lim_new = 31.98 * max_pow + 0.000625;\n\n      if (gfc.ATH.adjust >= adj_lim_new) {\n        /* descend gradually */\n        gfc.ATH.adjust *= adj_lim_new * 0.075 + 0.925;\n\n        if (gfc.ATH.adjust < adj_lim_new) {\n          /* stop descent */\n          gfc.ATH.adjust = adj_lim_new;\n        }\n      } else {\n        /* ascend */\n        if (gfc.ATH.adjustLimit >= adj_lim_new) {\n          gfc.ATH.adjust = adj_lim_new;\n        } else {\n          /* preceding frame has lower ATH adjust; */\n\n          /* ascend only to the preceding adjust_limit */\n          if (gfc.ATH.adjust < gfc.ATH.adjustLimit) {\n            gfc.ATH.adjust = gfc.ATH.adjustLimit;\n          }\n        }\n      }\n\n      gfc.ATH.adjustLimit = adj_lim_new;\n    }\n  }\n  /**\n   * <PRE>\n   *  some simple statistics\n   *\n   *  bitrate index 0: free bitrate . not allowed in VBR mode\n   *  : bitrates, kbps depending on MPEG version\n   *  bitrate index 15: forbidden\n   *\n   *  mode_ext:\n   *  0:  LR\n   *  1:  LR-i\n   *  2:  MS\n   *  3:  MS-i\n   * </PRE>\n   */\n\n\n  function updateStats(gfc) {\n    var gr, ch;\n    assert(0 <= gfc.bitrate_index && gfc.bitrate_index < 16);\n    assert(0 <= gfc.mode_ext && gfc.mode_ext < 4);\n    /* count bitrate indices */\n\n    gfc.bitrate_stereoMode_Hist[gfc.bitrate_index][4]++;\n    gfc.bitrate_stereoMode_Hist[15][4]++;\n    /* count 'em for every mode extension in case of 2 channel encoding */\n\n    if (gfc.channels_out == 2) {\n      gfc.bitrate_stereoMode_Hist[gfc.bitrate_index][gfc.mode_ext]++;\n      gfc.bitrate_stereoMode_Hist[15][gfc.mode_ext]++;\n    }\n\n    for (gr = 0; gr < gfc.mode_gr; ++gr) {\n      for (ch = 0; ch < gfc.channels_out; ++ch) {\n        var bt = gfc.l3_side.tt[gr][ch].block_type | 0;\n        if (gfc.l3_side.tt[gr][ch].mixed_block_flag != 0) bt = 4;\n        gfc.bitrate_blockType_Hist[gfc.bitrate_index][bt]++;\n        gfc.bitrate_blockType_Hist[gfc.bitrate_index][5]++;\n        gfc.bitrate_blockType_Hist[15][bt]++;\n        gfc.bitrate_blockType_Hist[15][5]++;\n      }\n    }\n  }\n\n  function lame_encode_frame_init(gfp, inbuf) {\n    var gfc = gfp.internal_flags;\n    var ch, gr;\n\n    if (gfc.lame_encode_frame_init == 0) {\n      /* prime the MDCT/polyphase filterbank with a short block */\n      var i, j;\n      var primebuff0 = new_float(286 + 1152 + 576);\n      var primebuff1 = new_float(286 + 1152 + 576);\n      gfc.lame_encode_frame_init = 1;\n\n      for (i = 0, j = 0; i < 286 + 576 * (1 + gfc.mode_gr); ++i) {\n        if (i < 576 * gfc.mode_gr) {\n          primebuff0[i] = 0;\n          if (gfc.channels_out == 2) primebuff1[i] = 0;\n        } else {\n          primebuff0[i] = inbuf[0][j];\n          if (gfc.channels_out == 2) primebuff1[i] = inbuf[1][j];\n          ++j;\n        }\n      }\n      /* polyphase filtering / mdct */\n\n\n      for (gr = 0; gr < gfc.mode_gr; gr++) {\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          gfc.l3_side.tt[gr][ch].block_type = Encoder.SHORT_TYPE;\n        }\n      }\n\n      newMDCT.mdct_sub48(gfc, primebuff0, primebuff1);\n      /* check FFT will not use a negative starting offset */\n\n      assert(576 >= Encoder.FFTOFFSET);\n      /* check if we have enough data for FFT */\n\n      assert(gfc.mf_size >= Encoder.BLKSIZE + gfp.framesize - Encoder.FFTOFFSET);\n      /* check if we have enough data for polyphase filterbank */\n\n      assert(gfc.mf_size >= 512 + gfp.framesize - 32);\n    }\n  }\n  /**\n   * <PRE>\n   * encodeframe()           Layer 3\n   *\n   * encode a single frame\n   *\n   *\n   *    lame_encode_frame()\n   *\n   *\n   *                           gr 0            gr 1\n   *    inbuf:           |--------------|--------------|--------------|\n   *\n   *\n   *    Polyphase (18 windows, each shifted 32)\n   *    gr 0:\n   *    window1          <----512---.\n   *    window18                 <----512---.\n   *\n   *    gr 1:\n   *    window1                         <----512---.\n   *    window18                                <----512---.\n   *\n   *\n   *\n   *    MDCT output:  |--------------|--------------|--------------|\n   *\n   *    FFT's                    <---------1024---------.\n   *                                             <---------1024-------.\n   *\n   *\n   *\n   *        inbuf = buffer of PCM data size=MP3 framesize\n   *        encoder acts on inbuf[ch][0], but output is delayed by MDCTDELAY\n   *        so the MDCT coefficints are from inbuf[ch][-MDCTDELAY]\n   *\n   *        psy-model FFT has a 1 granule delay, so we feed it data for the\n   *        next granule.\n   *        FFT is centered over granule:  224+576+224\n   *        So FFT starts at:   576-224-MDCTDELAY\n   *\n   *        MPEG2:  FFT ends at:  BLKSIZE+576-224-MDCTDELAY      (1328)\n   *        MPEG1:  FFT ends at:  BLKSIZE+2*576-224-MDCTDELAY    (1904)\n   *\n   *        MPEG2:  polyphase first window:  [0..511]\n   *                          18th window:   [544..1055]          (1056)\n   *        MPEG1:            36th window:   [1120..1631]         (1632)\n   *                data needed:  512+framesize-32\n   *\n   *        A close look newmdct.c shows that the polyphase filterbank\n   *        only uses data from [0..510] for each window.  Perhaps because the window\n   *        used by the filterbank is zero for the last point, so Takehiro's\n   *        code doesn't bother to compute with it.\n   *\n   *        FFT starts at 576-224-MDCTDELAY (304)  = 576-FFTOFFSET\n   *\n   * </PRE>\n   */\n\n\n  this.lame_encode_mp3_frame = function (gfp, inbuf_l, inbuf_r, mp3buf, mp3bufPos, mp3buf_size) {\n    var mp3count;\n    var masking_LR = new_array_n([2, 2]);\n    /*\n     * LR masking &\n     * energy\n     */\n\n    masking_LR[0][0] = new III_psy_ratio();\n    masking_LR[0][1] = new III_psy_ratio();\n    masking_LR[1][0] = new III_psy_ratio();\n    masking_LR[1][1] = new III_psy_ratio();\n    var masking_MS = new_array_n([2, 2]);\n    /* MS masking & energy */\n\n    masking_MS[0][0] = new III_psy_ratio();\n    masking_MS[0][1] = new III_psy_ratio();\n    masking_MS[1][0] = new III_psy_ratio();\n    masking_MS[1][1] = new III_psy_ratio(); //III_psy_ratio masking[][];\n\n    var masking;\n    /* pointer to selected maskings */\n\n    var inbuf = [null, null];\n    var gfc = gfp.internal_flags;\n    var tot_ener = new_float_n([2, 4]);\n    var ms_ener_ratio = [.5, .5];\n    var pe = [[0., 0.], [0., 0.]];\n    var pe_MS = [[0., 0.], [0., 0.]]; //float[][] pe_use;\n\n    var pe_use;\n    var ch, gr;\n    inbuf[0] = inbuf_l;\n    inbuf[1] = inbuf_r;\n\n    if (gfc.lame_encode_frame_init == 0) {\n      /* first run? */\n      lame_encode_frame_init(gfp, inbuf);\n    }\n    /********************** padding *****************************/\n\n    /**\n     * <PRE>\n     * padding method as described in\n     * \"MPEG-Layer3 / Bitstream Syntax and Decoding\"\n     * by Martin Sieler, Ralph Sperschneider\n     *\n     * note: there is no padding for the very first frame\n     *\n     * Robert Hegemann 2000-06-22\n     * </PRE>\n     */\n\n\n    gfc.padding = 0;\n\n    if ((gfc.slot_lag -= gfc.frac_SpF) < 0) {\n      gfc.slot_lag += gfp.out_samplerate;\n      gfc.padding = 1;\n    }\n    /****************************************\n     * Stage 1: psychoacoustic model *\n     ****************************************/\n\n\n    if (gfc.psymodel != 0) {\n      /*\n       * psychoacoustic model psy model has a 1 granule (576) delay that\n       * we must compensate for (mt 6/99).\n       */\n      var ret;\n      var bufp = [null, null];\n      /* address of beginning of left & right granule */\n\n      var bufpPos = 0;\n      /* address of beginning of left & right granule */\n\n      var blocktype = new_int(2);\n\n      for (gr = 0; gr < gfc.mode_gr; gr++) {\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          bufp[ch] = inbuf[ch];\n          bufpPos = 576 + gr * 576 - Encoder.FFTOFFSET;\n        }\n\n        if (gfp.VBR == VbrMode.vbr_mtrh || gfp.VBR == VbrMode.vbr_mt) {\n          ret = psy.L3psycho_anal_vbr(gfp, bufp, bufpPos, gr, masking_LR, masking_MS, pe[gr], pe_MS[gr], tot_ener[gr], blocktype);\n        } else {\n          ret = psy.L3psycho_anal_ns(gfp, bufp, bufpPos, gr, masking_LR, masking_MS, pe[gr], pe_MS[gr], tot_ener[gr], blocktype);\n        }\n\n        if (ret != 0) return -4;\n\n        if (gfp.mode == MPEGMode.JOINT_STEREO) {\n          ms_ener_ratio[gr] = tot_ener[gr][2] + tot_ener[gr][3];\n          if (ms_ener_ratio[gr] > 0) ms_ener_ratio[gr] = tot_ener[gr][3] / ms_ener_ratio[gr];\n        }\n        /* block type flags */\n\n\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          var cod_info = gfc.l3_side.tt[gr][ch];\n          cod_info.block_type = blocktype[ch];\n          cod_info.mixed_block_flag = 0;\n        }\n      }\n    } else {\n      /* no psy model */\n      for (gr = 0; gr < gfc.mode_gr; gr++) for (ch = 0; ch < gfc.channels_out; ch++) {\n        gfc.l3_side.tt[gr][ch].block_type = Encoder.NORM_TYPE;\n        gfc.l3_side.tt[gr][ch].mixed_block_flag = 0;\n        pe_MS[gr][ch] = pe[gr][ch] = 700;\n      }\n    }\n    /* auto-adjust of ATH, useful for low volume */\n\n\n    adjust_ATH(gfc);\n    /****************************************\n     * Stage 2: MDCT *\n     ****************************************/\n\n    /* polyphase filtering / mdct */\n\n    newMDCT.mdct_sub48(gfc, inbuf[0], inbuf[1]);\n    /****************************************\n     * Stage 3: MS/LR decision *\n     ****************************************/\n\n    /* Here will be selected MS or LR coding of the 2 stereo channels */\n\n    gfc.mode_ext = Encoder.MPG_MD_LR_LR;\n\n    if (gfp.force_ms) {\n      gfc.mode_ext = Encoder.MPG_MD_MS_LR;\n    } else if (gfp.mode == MPEGMode.JOINT_STEREO) {\n      /*\n       * ms_ratio = is scaled, for historical reasons, to look like a\n       * ratio of side_channel / total. 0 = signal is 100% mono .5 = L & R\n       * uncorrelated\n       */\n\n      /**\n       * <PRE>\n       * [0] and [1] are the results for the two granules in MPEG-1,\n       * in MPEG-2 it's only a faked averaging of the same value\n       * _prev is the value of the last granule of the previous frame\n       * _next is the value of the first granule of the next frame\n       * </PRE>\n       */\n      var sum_pe_MS = 0.;\n      var sum_pe_LR = 0.;\n\n      for (gr = 0; gr < gfc.mode_gr; gr++) {\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          sum_pe_MS += pe_MS[gr][ch];\n          sum_pe_LR += pe[gr][ch];\n        }\n      }\n      /* based on PE: M/S coding would not use much more bits than L/R */\n\n\n      if (sum_pe_MS <= 1.00 * sum_pe_LR) {\n        var gi0 = gfc.l3_side.tt[0];\n        var gi1 = gfc.l3_side.tt[gfc.mode_gr - 1];\n\n        if (gi0[0].block_type == gi0[1].block_type && gi1[0].block_type == gi1[1].block_type) {\n          gfc.mode_ext = Encoder.MPG_MD_MS_LR;\n        }\n      }\n    }\n    /* bit and noise allocation */\n\n\n    if (gfc.mode_ext == MPG_MD_MS_LR) {\n      masking = masking_MS;\n      /* use MS masking */\n\n      pe_use = pe_MS;\n    } else {\n      masking = masking_LR;\n      /* use LR masking */\n\n      pe_use = pe;\n    }\n    /* copy data for MP3 frame analyzer */\n\n\n    if (gfp.analysis && gfc.pinfo != null) {\n      for (gr = 0; gr < gfc.mode_gr; gr++) {\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          gfc.pinfo.ms_ratio[gr] = gfc.ms_ratio[gr];\n          gfc.pinfo.ms_ener_ratio[gr] = ms_ener_ratio[gr];\n          gfc.pinfo.blocktype[gr][ch] = gfc.l3_side.tt[gr][ch].block_type;\n          gfc.pinfo.pe[gr][ch] = pe_use[gr][ch];\n          System.arraycopy(gfc.l3_side.tt[gr][ch].xr, 0, gfc.pinfo.xr[gr][ch], 0, 576);\n          /*\n           * in psymodel, LR and MS data was stored in pinfo. switch\n           * to MS data:\n           */\n\n          if (gfc.mode_ext == MPG_MD_MS_LR) {\n            gfc.pinfo.ers[gr][ch] = gfc.pinfo.ers[gr][ch + 2];\n            System.arraycopy(gfc.pinfo.energy[gr][ch + 2], 0, gfc.pinfo.energy[gr][ch], 0, gfc.pinfo.energy[gr][ch].length);\n          }\n        }\n      }\n    }\n    /****************************************\n     * Stage 4: quantization loop *\n     ****************************************/\n\n\n    if (gfp.VBR == VbrMode.vbr_off || gfp.VBR == VbrMode.vbr_abr) {\n      var i;\n      var f;\n\n      for (i = 0; i < 18; i++) gfc.nsPsy.pefirbuf[i] = gfc.nsPsy.pefirbuf[i + 1];\n\n      f = 0.0;\n\n      for (gr = 0; gr < gfc.mode_gr; gr++) for (ch = 0; ch < gfc.channels_out; ch++) f += pe_use[gr][ch];\n\n      gfc.nsPsy.pefirbuf[18] = f;\n      f = gfc.nsPsy.pefirbuf[9];\n\n      for (i = 0; i < 9; i++) f += (gfc.nsPsy.pefirbuf[i] + gfc.nsPsy.pefirbuf[18 - i]) * Encoder.fircoef[i];\n\n      f = 670 * 5 * gfc.mode_gr * gfc.channels_out / f;\n\n      for (gr = 0; gr < gfc.mode_gr; gr++) {\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          pe_use[gr][ch] *= f;\n        }\n      }\n    }\n\n    gfc.iteration_loop.iteration_loop(gfp, pe_use, ms_ener_ratio, masking);\n    /****************************************\n     * Stage 5: bitstream formatting *\n     ****************************************/\n\n    /* write the frame to the bitstream */\n\n    bs.format_bitstream(gfp);\n    /* copy mp3 bit buffer into array */\n\n    mp3count = bs.copy_buffer(gfc, mp3buf, mp3bufPos, mp3buf_size, 1);\n    if (gfp.bWriteVbrTag) vbr.addVbrFrame(gfp);\n\n    if (gfp.analysis && gfc.pinfo != null) {\n      for (ch = 0; ch < gfc.channels_out; ch++) {\n        var j;\n\n        for (j = 0; j < FFTOFFSET; j++) gfc.pinfo.pcmdata[ch][j] = gfc.pinfo.pcmdata[ch][j + gfp.framesize];\n\n        for (j = FFTOFFSET; j < 1600; j++) {\n          gfc.pinfo.pcmdata[ch][j] = inbuf[ch][j - FFTOFFSET];\n        }\n      }\n\n      qupvt.set_frame_pinfo(gfp, masking);\n    }\n\n    updateStats(gfc);\n    return mp3count;\n  };\n}\n\nmodule.exports = Encoder;","map":null,"metadata":{},"sourceType":"script"}