{"ast":null,"code":"var detect = require('rtc-core/detect');\n\nvar findPlugin = require('rtc-core/plugin');\n\nvar PriorityQueue = require('priorityqueuejs');\n\nvar Promise = require('es6-promise').Promise;\n\nvar pluck = require('whisk/pluck');\n\nvar pluckSessionDesc = pluck('sdp', 'type'); // some validation routines\n\nvar checkCandidate = require('rtc-validator/candidate'); // the sdp cleaner\n\n\nvar sdpclean = require('rtc-sdpclean');\n\nvar parseSdp = require('rtc-sdp');\n\nvar PRIORITY_LOW = 100;\nvar PRIORITY_WAIT = 1000; // priority order (lower is better)\n\nvar DEFAULT_PRIORITIES = ['createOffer', 'setLocalDescription', 'createAnswer', 'setRemoteDescription', 'addIceCandidate']; // define event mappings\n\nvar METHOD_EVENTS = {\n  setLocalDescription: 'setlocaldesc',\n  setRemoteDescription: 'setremotedesc',\n  createOffer: 'offer',\n  createAnswer: 'answer'\n};\nvar MEDIA_MAPPINGS = {\n  data: 'application'\n}; // define states in which we will attempt to finalize a connection on receiving a remote offer\n\nvar VALID_RESPONSE_STATES = ['have-remote-offer', 'have-local-pranswer'];\n/**\n  Allows overriding of a function\n **/\n\nfunction pluggable(pluginFn, defaultFn) {\n  return pluginFn && typeof pluginFn == 'function' ? pluginFn : defaultFn;\n}\n/**\n  # rtc-taskqueue\n\n  This is a package that assists with applying actions to an `RTCPeerConnection`\n  in as reliable order as possible. It is primarily used by the coupling logic\n  of the [`rtc-tools`](https://github.com/rtc-io/rtc-tools).\n\n  ## Example Usage\n\n  For the moment, refer to the simple coupling test as an example of how to use\n  this package (see below):\n\n  <<< test/couple.js\n\n**/\n\n\nmodule.exports = function (pc, opts) {\n  opts = opts || {}; // create the task queue\n\n  var queue = new PriorityQueue(orderTasks);\n\n  var tq = require('mbus')('', (opts || {}).logger); // initialise task importance\n\n\n  var priorities = (opts || {}).priorities || DEFAULT_PRIORITIES;\n  var queueInterval = (opts || {}).interval || 10; // check for plugin usage\n\n  var plugin = findPlugin((opts || {}).plugins); // initialise state tracking\n\n  var checkQueueTimer = 0;\n  var defaultFail = tq.bind(tq, 'fail'); // look for an sdpfilter function (allow slight mis-spellings)\n\n  var sdpFilter = (opts || {}).sdpfilter || (opts || {}).sdpFilter;\n  var alwaysParse = opts.sdpParseMode === 'always'; // initialise session description and icecandidate objects\n\n  var RTCSessionDescription = (opts || {}).RTCSessionDescription || detect('RTCSessionDescription');\n  var RTCIceCandidate = (opts || {}).RTCIceCandidate || detect('RTCIceCandidate'); // Determine plugin overridable methods\n\n  var createIceCandidate = pluggable(plugin && plugin.createIceCandidate, function (data) {\n    return new RTCIceCandidate(data);\n  });\n  var createSessionDescription = pluggable(plugin && plugin.createSessionDescription, function (data) {\n    return new RTCSessionDescription(data);\n  });\n  var qid = tq._qid = Math.floor(Math.random() * 100000);\n\n  function abortQueue(err) {\n    console.error(err);\n  }\n\n  function applyCandidate(task, next) {\n    var data = task.args[0]; // Allow selective filtering of ICE candidates\n\n    if (opts && opts.filterCandidate && !opts.filterCandidate(data)) {\n      tq('ice.remote.filtered', candidate);\n      return next();\n    }\n\n    var candidate = data && data.candidate && createIceCandidate(data);\n\n    function handleOk() {\n      tq('ice.remote.applied', candidate);\n      next();\n    }\n\n    function handleFail(err) {\n      tq('ice.remote.invalid', candidate);\n      next(err);\n    } // we have a null candidate, we have finished gathering candidates\n\n\n    if (!candidate) {\n      return next();\n    }\n\n    pc.addIceCandidate(candidate, handleOk, handleFail);\n  }\n\n  function checkQueue() {\n    // peek at the next item on the queue\n    var next = !queue.isEmpty() && queue.peek();\n    var ready = next && testReady(next); // reset the queue timer\n\n    checkQueueTimer = 0; // if we don't have a task ready, then abort\n\n    if (!ready) {\n      // if we have a task and it has expired then dequeue it\n      if (next && (aborted(next) || expired(next))) {\n        tq('task.expire', next);\n        queue.deq();\n      }\n\n      return !queue.isEmpty() && isNotClosed(pc) && triggerQueueCheck();\n    } // properly dequeue task\n\n\n    next = queue.deq(); // process the task\n\n    next.fn(next, function (err) {\n      var fail = next.fail || defaultFail;\n      var pass = next.pass;\n      var taskName = next.name; // if errored, fail\n\n      if (err) {\n        console.error(taskName + ' task failed: ', err);\n        return fail(err);\n      }\n\n      if (typeof pass == 'function') {\n        pass.apply(next, [].slice.call(arguments, 1));\n      } // Allow tasks to indicate that processing should continue immediately to the\n      // following task\n\n\n      if (next.immediate) {\n        if (checkQueueTimer) clearTimeout(checkQueueTimer);\n        return checkQueue();\n      } else {\n        triggerQueueCheck();\n      }\n    });\n  }\n\n  function cleansdp(desc) {\n    // ensure we have clean sdp\n    var sdpErrors = [];\n    var sdp = desc && sdpclean(desc.sdp, {\n      collector: sdpErrors\n    }); // if we don't have a match, log some info\n\n    if (desc && sdp !== desc.sdp) {\n      console.info('invalid lines removed from sdp: ', sdpErrors);\n      desc.sdp = sdp;\n    } // if a filter has been specified, then apply the filter\n\n\n    if (typeof sdpFilter == 'function') {\n      desc.sdp = sdpFilter(desc.sdp, pc);\n    }\n\n    return desc;\n  }\n\n  function completeConnection() {\n    // Clean any cached media types now that we have potentially new remote description\n    if (pc.__mediaIDs || pc.__mediaTypes) {\n      // Set defined as opposed to delete, for compatibility purposes\n      pc.__mediaIDs = undefined;\n      pc.__mediaTypes = undefined;\n    }\n\n    if (VALID_RESPONSE_STATES.indexOf(pc.signalingState) >= 0) {\n      return tq.createAnswer();\n    }\n  }\n\n  function emitSdp() {\n    tq('sdp.local', pluckSessionDesc(this.args[0]));\n  }\n\n  function enqueue(name, handler, opts) {\n    return function () {\n      var args = [].slice.call(arguments);\n\n      if (opts && typeof opts.processArgs == 'function') {\n        args = args.map(opts.processArgs);\n      }\n\n      var priority = priorities.indexOf(name);\n      return new Promise(function (resolve, reject) {\n        queue.enq({\n          args: args,\n          name: name,\n          fn: handler,\n          priority: priority >= 0 ? priority : PRIORITY_LOW,\n          immediate: opts.immediate,\n          // If aborted, the task will be removed\n          aborted: false,\n          // record the time at which the task was queued\n          start: Date.now(),\n          // initilaise any checks that need to be done prior\n          // to the task executing\n          checks: [isNotClosed].concat((opts || {}).checks || []),\n          // initialise the pass and fail handlers\n          pass: function () {\n            if (opts && opts.pass) {\n              opts.pass.apply(this, arguments);\n            }\n\n            resolve();\n          },\n          fail: function () {\n            if (opts && opts.fail) {\n              opts.fail.apply(this, arguments);\n            }\n\n            reject();\n          }\n        });\n        triggerQueueCheck();\n      });\n    };\n  }\n\n  function execMethod(task, next) {\n    var fn = pc[task.name];\n    var eventName = METHOD_EVENTS[task.name] || (task.name || '').toLowerCase();\n    var cbArgs = [success, fail];\n    var isOffer = task.name === 'createOffer';\n\n    function fail(err) {\n      tq.apply(tq, ['negotiate.error', task.name, err].concat(task.args));\n      next(err);\n    }\n\n    function success() {\n      tq.apply(tq, [['negotiate', eventName, 'ok'], task.name].concat(task.args));\n      next.apply(null, [null].concat([].slice.call(arguments)));\n    }\n\n    if (!fn) {\n      return next(new Error('cannot call \"' + task.name + '\" on RTCPeerConnection'));\n    } // invoke the function\n\n\n    tq.apply(tq, ['negotiate.' + eventName].concat(task.args));\n    fn.apply(pc, task.args.concat(cbArgs).concat(isOffer ? generateConstraints() : []));\n  }\n\n  function expired(task) {\n    return typeof task.ttl == 'number' && task.start + task.ttl < Date.now();\n  }\n\n  function aborted(task) {\n    return task && task.aborted;\n  }\n\n  function extractCandidateEventData(data) {\n    // extract nested candidate data (like we will see in an event being passed to this function)\n    while (data && data.candidate && data.candidate.candidate) {\n      data = data.candidate;\n    }\n\n    return data;\n  }\n\n  function generateConstraints() {\n    var allowedKeys = {\n      offertoreceivevideo: 'OfferToReceiveVideo',\n      offertoreceiveaudio: 'OfferToReceiveAudio',\n      icerestart: 'IceRestart',\n      voiceactivitydetection: 'VoiceActivityDetection'\n    };\n    var constraints = {\n      OfferToReceiveVideo: true,\n      OfferToReceiveAudio: true\n    }; // Handle mozillas slightly different constraint requirements that are\n    // enforced as of FF43\n\n    if (detect.moz) {\n      allowedKeys = {\n        offertoreceivevideo: 'offerToReceiveVideo',\n        offertoreceiveaudio: 'offerToReceiveAudio',\n        icerestart: 'iceRestart',\n        voiceactivitydetection: 'voiceActivityDetection'\n      };\n      constraints = {\n        offerToReceiveVideo: true,\n        offerToReceiveAudio: true\n      };\n    } // update known keys to match\n\n\n    Object.keys(opts || {}).forEach(function (key) {\n      if (allowedKeys[key.toLowerCase()]) {\n        constraints[allowedKeys[key.toLowerCase()]] = opts[key];\n      }\n    });\n    return detect.moz ? constraints : {\n      mandatory: constraints\n    };\n  }\n\n  function hasLocalOrRemoteDesc(pc, task) {\n    return pc.__hasDesc || (pc.__hasDesc = !!pc.remoteDescription);\n  }\n\n  function isNotNegotiating(pc) {\n    return pc.signalingState !== 'have-local-offer';\n  }\n\n  function isNotClosed(pc) {\n    return pc.signalingState !== 'closed';\n  }\n\n  function isStable(pc) {\n    return pc.signalingState === 'stable';\n  }\n\n  function isValidCandidate(pc, data) {\n    var validCandidate = data.__valid || (data.__valid = checkCandidate(data.args[0]).length === 0); // If the candidate is not valid, abort\n\n    if (!validCandidate) {\n      data.aborted = true;\n    }\n\n    return validCandidate;\n  }\n\n  function isConnReadyForCandidate(pc, data) {\n    var sdpMid = data.args[0] && data.args[0].sdpMid; // remap media types as appropriate\n\n    sdpMid = MEDIA_MAPPINGS[sdpMid] || sdpMid;\n    if (sdpMid === '') return true; // Allow parsing of SDP always if required\n\n    if (alwaysParse || !pc.__mediaTypes) {\n      var sdp = parseSdp(pc.remoteDescription && pc.remoteDescription.sdp); // We only want to cache the SDP media types if we've received them, otherwise\n      // bad things can happen\n\n      var mediaTypes = sdp.getMediaTypes();\n\n      if (mediaTypes && mediaTypes.length > 0) {\n        pc.__mediaTypes = mediaTypes;\n      } // Same for media IDs\n\n\n      var mediaIDs = sdp.getMediaIDs();\n\n      if (mediaIDs && mediaIDs.length > 0) {\n        pc.__mediaIDs = mediaIDs;\n      }\n    } // the candidate is valid if the sdpMid matches either a known media\n    // type, or media ID\n\n\n    var validMediaCandidate = pc.__mediaIDs && pc.__mediaIDs.indexOf(sdpMid) >= 0 || pc.__mediaTypes && pc.__mediaTypes.indexOf(sdpMid) >= 0; // Otherwise we abort the task\n\n    if (!validMediaCandidate) {\n      data.aborted = true;\n    }\n\n    return validMediaCandidate;\n  }\n\n  function orderTasks(a, b) {\n    // apply each of the checks for each task\n    var tasks = [a, b];\n    var readiness = tasks.map(testReady);\n    var taskPriorities = tasks.map(function (task, idx) {\n      var ready = readiness[idx];\n      return ready ? task.priority : PRIORITY_WAIT;\n    });\n    return taskPriorities[1] - taskPriorities[0];\n  } // check whether a task is ready (does it pass all the checks)\n\n\n  function testReady(task) {\n    return (task.checks || []).reduce(function (memo, check) {\n      return memo && check(pc, task);\n    }, true);\n  }\n\n  function triggerQueueCheck() {\n    if (checkQueueTimer) return;\n    checkQueueTimer = setTimeout(checkQueue, queueInterval);\n  } // patch in the queue helper methods\n\n\n  tq.addIceCandidate = enqueue('addIceCandidate', applyCandidate, {\n    processArgs: extractCandidateEventData,\n    checks: [hasLocalOrRemoteDesc, isValidCandidate, isConnReadyForCandidate],\n    // set ttl to 5s\n    ttl: 5000,\n    immediate: true\n  });\n  tq.setLocalDescription = enqueue('setLocalDescription', execMethod, {\n    processArgs: cleansdp,\n    pass: emitSdp\n  });\n  tq.setRemoteDescription = enqueue('setRemoteDescription', execMethod, {\n    processArgs: createSessionDescription,\n    pass: completeConnection\n  });\n  tq.createOffer = enqueue('createOffer', execMethod, {\n    checks: [isNotNegotiating],\n    pass: tq.setLocalDescription\n  });\n  tq.createAnswer = enqueue('createAnswer', execMethod, {\n    pass: tq.setLocalDescription\n  });\n  return tq;\n};","map":null,"metadata":{},"sourceType":"script"}