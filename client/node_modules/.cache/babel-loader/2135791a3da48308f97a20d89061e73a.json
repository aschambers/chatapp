{"ast":null,"code":"var u = require('pull-core');\n\nvar sources = require('./sources');\n\nvar sinks = require('./sinks');\n\nvar prop = u.prop;\nvar id = u.id;\nvar tester = u.tester;\n\nvar map = exports.map = function (read, map) {\n  map = prop(map) || id;\n  return function (end, cb) {\n    read(end, function (end, data) {\n      var data = !end ? map(data) : null;\n      cb(end, data);\n    });\n  };\n};\n\nvar asyncMap = exports.asyncMap = function (read, map) {\n  if (!map) return read;\n  return function (end, cb) {\n    if (end) return read(end, cb); //abort\n\n    read(null, function (end, data) {\n      if (end) return cb(end, data);\n      map(data, cb);\n    });\n  };\n};\n\nvar paraMap = exports.paraMap = function (read, map, width) {\n  if (!map) return read;\n\n  var ended = false,\n      queue = [],\n      _cb;\n\n  function drain() {\n    if (!_cb) return;\n    var cb = _cb;\n    _cb = null;\n    if (queue.length) return cb(null, queue.shift());else if (ended && !n) return cb(ended);\n    _cb = cb;\n  }\n\n  function pull() {\n    read(null, function (end, data) {\n      if (end) {\n        ended = end;\n        return drain();\n      }\n\n      n++;\n      map(data, function (err, data) {\n        n--;\n        queue.push(data);\n        drain();\n      });\n      if (n < width && !ended) pull();\n    });\n  }\n\n  var n = 0;\n  return function (end, cb) {\n    if (end) return read(end, cb); //abort\n    //continue to read while there are less than 3 maps in flight\n\n    _cb = cb;\n    if (queue.length || ended) pull(), drain();else pull();\n  };\n  return highWaterMark(asyncMap(read, map), width);\n};\n\nvar filter = exports.filter = function (read, test) {\n  //regexp\n  test = tester(test);\n  return function next(end, cb) {\n    read(end, function (end, data) {\n      if (!end && !test(data)) return next(end, cb);\n      cb(end, data);\n    });\n  };\n};\n\nvar filterNot = exports.filterNot = function (read, test) {\n  test = tester(test);\n  return filter(read, function (e) {\n    return !test(e);\n  });\n};\n\nvar through = exports.through = function (read, op, onEnd) {\n  var a = false;\n\n  function once(abort) {\n    if (a || !onEnd) return;\n    a = true;\n    onEnd(abort === true ? null : abort);\n  }\n\n  return function (end, cb) {\n    if (end) once(end);\n    return read(end, function (end, data) {\n      if (!end) op && op(data);else once(end);\n      cb(end, data);\n    });\n  };\n};\n\nvar take = exports.take = function (read, test) {\n  var ended = false;\n\n  if ('number' === typeof test) {\n    var n = test;\n\n    test = function () {\n      return n--;\n    };\n  }\n\n  return function (end, cb) {\n    if (ended) return cb(ended);\n    if (ended = end) return read(ended, cb);\n    read(null, function (end, data) {\n      if (ended = ended || end) return cb(ended);\n\n      if (!test(data)) {\n        ended = true;\n        read(true, function (end, data) {\n          cb(ended, data);\n        });\n      } else cb(null, data);\n    });\n  };\n};\n\nvar unique = exports.unique = function (read, field, invert) {\n  field = prop(field) || id;\n  var seen = {};\n  return filter(read, function (data) {\n    var key = field(data);\n    if (seen[key]) return !!invert; //false, by default\n    else seen[key] = true;\n    return !invert; //true by default\n  });\n};\n\nvar nonUnique = exports.nonUnique = function (read, field) {\n  return unique(read, field, true);\n};\n\nvar group = exports.group = function (read, size) {\n  var ended;\n  size = size || 5;\n  var queue = [];\n  return function (end, cb) {\n    //this means that the upstream is sending an error.\n    if (end) return read(ended = end, cb); //this means that we read an end before.\n\n    if (ended) return cb(ended);\n    read(null, function next(end, data) {\n      if (ended = ended || end) {\n        if (!queue.length) return cb(ended);\n        var _queue = queue;\n        queue = [];\n        return cb(null, _queue);\n      }\n\n      queue.push(data);\n      if (queue.length < size) return read(null, next);\n      var _queue = queue;\n      queue = [];\n      cb(null, _queue);\n    });\n  };\n};\n\nvar flatten = exports.flatten = function (read) {\n  var _read;\n\n  return function (abort, cb) {\n    if (_read) nextChunk();else nextStream();\n\n    function nextChunk() {\n      _read(null, function (end, data) {\n        if (end) nextStream();else cb(null, data);\n      });\n    }\n\n    function nextStream() {\n      read(null, function (end, stream) {\n        if (end) return cb(end);\n        if (Array.isArray(stream)) stream = sources.values(stream);else if ('function' != typeof stream) throw new Error('expected stream of streams');\n        _read = stream;\n        nextChunk();\n      });\n    }\n  };\n};\n\nvar prepend = exports.prepend = function (read, head) {\n  return function (abort, cb) {\n    if (head !== null) {\n      if (abort) return read(abort, cb);\n      var _head = head;\n      head = null;\n      cb(null, _head);\n    } else {\n      read(abort, cb);\n    }\n  };\n}; //var drainIf = exports.drainIf = function (op, done) {\n//  sinks.drain(\n//}\n\n\nvar _reduce = exports._reduce = function (read, reduce, initial) {\n  return function (close, cb) {\n    if (close) return read(close, cb);\n    if (ended) return cb(ended);\n    sinks.drain(function (item) {\n      initial = reduce(initial, item);\n    }, function (err, data) {\n      ended = err || true;\n      if (!err) cb(null, initial);else cb(ended);\n    })(read);\n  };\n};\n\nvar nextTick = process.nextTick;\n\nvar highWaterMark = exports.highWaterMark = function (read, highWaterMark) {\n  var buffer = [],\n      waiting = [],\n      ended,\n      reading = false;\n  highWaterMark = highWaterMark || 10;\n\n  function readAhead() {\n    while (waiting.length && (buffer.length || ended)) waiting.shift()(ended, ended ? null : buffer.shift());\n  }\n\n  function next() {\n    if (ended || reading || buffer.length >= highWaterMark) return;\n    reading = true;\n    return read(ended, function (end, data) {\n      reading = false;\n      ended = ended || end;\n      if (data != null) buffer.push(data);\n      next();\n      readAhead();\n    });\n  }\n\n  nextTick(next);\n  return function (end, cb) {\n    ended = ended || end;\n    waiting.push(cb);\n    next();\n    readAhead();\n  };\n};","map":null,"metadata":{},"sourceType":"script"}