{"ast":null,"code":"var common = require('./common.js');\n\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nfunction Presets() {\n  function VBRPresets(qual, comp, compS, y, shThreshold, shThresholdS, adj, adjShort, lower, curve, sens, inter, joint, mod, fix) {\n    this.vbr_q = qual;\n    this.quant_comp = comp;\n    this.quant_comp_s = compS;\n    this.expY = y;\n    this.st_lrm = shThreshold;\n    this.st_s = shThresholdS;\n    this.masking_adj = adj;\n    this.masking_adj_short = adjShort;\n    this.ath_lower = lower;\n    this.ath_curve = curve;\n    this.ath_sensitivity = sens;\n    this.interch = inter;\n    this.safejoint = joint;\n    this.sfb21mod = mod;\n    this.msfix = fix;\n  }\n\n  function ABRPresets(kbps, comp, compS, joint, fix, shThreshold, shThresholdS, bass, sc, mask, lower, curve, interCh, sfScale) {\n    this.quant_comp = comp;\n    this.quant_comp_s = compS;\n    this.safejoint = joint;\n    this.nsmsfix = fix;\n    this.st_lrm = shThreshold;\n    this.st_s = shThresholdS;\n    this.nsbass = bass;\n    this.scale = sc;\n    this.masking_adj = mask;\n    this.ath_lower = lower;\n    this.ath_curve = curve;\n    this.interch = interCh;\n    this.sfscale = sfScale;\n  }\n\n  var lame;\n\n  this.setModules = function (_lame) {\n    lame = _lame;\n  };\n  /**\n   * <PRE>\n   * Switch mappings for VBR mode VBR_RH\n   *             vbr_q  qcomp_l  qcomp_s  expY  st_lrm   st_s  mask adj_l  adj_s  ath_lower  ath_curve  ath_sens  interChR  safejoint sfb21mod  msfix\n   * </PRE>\n   */\n\n\n  var vbr_old_switch_map = [new VBRPresets(0, 9, 9, 0, 5.20, 125.0, -4.2, -6.3, 4.8, 1, 0, 0, 2, 21, 0.97), new VBRPresets(1, 9, 9, 0, 5.30, 125.0, -3.6, -5.6, 4.5, 1.5, 0, 0, 2, 21, 1.35), new VBRPresets(2, 9, 9, 0, 5.60, 125.0, -2.2, -3.5, 2.8, 2, 0, 0, 2, 21, 1.49), new VBRPresets(3, 9, 9, 1, 5.80, 130.0, -1.8, -2.8, 2.6, 3, -4, 0, 2, 20, 1.64), new VBRPresets(4, 9, 9, 1, 6.00, 135.0, -0.7, -1.1, 1.1, 3.5, -8, 0, 2, 0, 1.79), new VBRPresets(5, 9, 9, 1, 6.40, 140.0, 0.5, 0.4, -7.5, 4, -12, 0.0002, 0, 0, 1.95), new VBRPresets(6, 9, 9, 1, 6.60, 145.0, 0.67, 0.65, -14.7, 6.5, -19, 0.0004, 0, 0, 2.30), new VBRPresets(7, 9, 9, 1, 6.60, 145.0, 0.8, 0.75, -19.7, 8, -22, 0.0006, 0, 0, 2.70), new VBRPresets(8, 9, 9, 1, 6.60, 145.0, 1.2, 1.15, -27.5, 10, -23, 0.0007, 0, 0, 0), new VBRPresets(9, 9, 9, 1, 6.60, 145.0, 1.6, 1.6, -36, 11, -25, 0.0008, 0, 0, 0), new VBRPresets(10, 9, 9, 1, 6.60, 145.0, 2.0, 2.0, -36, 12, -25, 0.0008, 0, 0, 0)];\n  /**\n   * <PRE>\n   *                 vbr_q  qcomp_l  qcomp_s  expY  st_lrm   st_s  mask adj_l  adj_s  ath_lower  ath_curve  ath_sens  interChR  safejoint sfb21mod  msfix\n   * </PRE>\n   */\n\n  var vbr_psy_switch_map = [new VBRPresets(0, 9, 9, 0, 4.20, 25.0, -7.0, -4.0, 7.5, 1, 0, 0, 2, 26, 0.97), new VBRPresets(1, 9, 9, 0, 4.20, 25.0, -5.6, -3.6, 4.5, 1.5, 0, 0, 2, 21, 1.35), new VBRPresets(2, 9, 9, 0, 4.20, 25.0, -4.4, -1.8, 2, 2, 0, 0, 2, 18, 1.49), new VBRPresets(3, 9, 9, 1, 4.20, 25.0, -3.4, -1.25, 1.1, 3, -4, 0, 2, 15, 1.64), new VBRPresets(4, 9, 9, 1, 4.20, 25.0, -2.2, 0.1, 0, 3.5, -8, 0, 2, 0, 1.79), new VBRPresets(5, 9, 9, 1, 4.20, 25.0, -1.0, 1.65, -7.7, 4, -12, 0.0002, 0, 0, 1.95), new VBRPresets(6, 9, 9, 1, 4.20, 25.0, -0.0, 2.47, -7.7, 6.5, -19, 0.0004, 0, 0, 2), new VBRPresets(7, 9, 9, 1, 4.20, 25.0, 0.5, 2.0, -14.5, 8, -22, 0.0006, 0, 0, 2), new VBRPresets(8, 9, 9, 1, 4.20, 25.0, 1.0, 2.4, -22.0, 10, -23, 0.0007, 0, 0, 2), new VBRPresets(9, 9, 9, 1, 4.20, 25.0, 1.5, 2.95, -30.0, 11, -25, 0.0008, 0, 0, 2), new VBRPresets(10, 9, 9, 1, 4.20, 25.0, 2.0, 2.95, -36.0, 12, -30, 0.0008, 0, 0, 2)];\n\n  function apply_vbr_preset(gfp, a, enforce) {\n    var vbr_preset = gfp.VBR == VbrMode.vbr_rh ? vbr_old_switch_map : vbr_psy_switch_map;\n    var x = gfp.VBR_q_frac;\n    var p = vbr_preset[a];\n    var q = vbr_preset[a + 1];\n    var set = p; // NOOP(vbr_q);\n    // NOOP(quant_comp);\n    // NOOP(quant_comp_s);\n    // NOOP(expY);\n\n    p.st_lrm = p.st_lrm + x * (q.st_lrm - p.st_lrm); // LERP(st_lrm);\n\n    p.st_s = p.st_s + x * (q.st_s - p.st_s); // LERP(st_s);\n\n    p.masking_adj = p.masking_adj + x * (q.masking_adj - p.masking_adj); // LERP(masking_adj);\n\n    p.masking_adj_short = p.masking_adj_short + x * (q.masking_adj_short - p.masking_adj_short); // LERP(masking_adj_short);\n\n    p.ath_lower = p.ath_lower + x * (q.ath_lower - p.ath_lower); // LERP(ath_lower);\n\n    p.ath_curve = p.ath_curve + x * (q.ath_curve - p.ath_curve); // LERP(ath_curve);\n\n    p.ath_sensitivity = p.ath_sensitivity + x * (q.ath_sensitivity - p.ath_sensitivity); // LERP(ath_sensitivity);\n\n    p.interch = p.interch + x * (q.interch - p.interch); // LERP(interch);\n    // NOOP(safejoint);\n    // NOOP(sfb21mod);\n\n    p.msfix = p.msfix + x * (q.msfix - p.msfix); // LERP(msfix);\n\n    lame_set_VBR_q(gfp, set.vbr_q);\n    if (enforce != 0) gfp.quant_comp = set.quant_comp;else if (!(Math.abs(gfp.quant_comp - -1) > 0)) gfp.quant_comp = set.quant_comp; // SET_OPTION(quant_comp, set.quant_comp, -1);\n\n    if (enforce != 0) gfp.quant_comp_short = set.quant_comp_s;else if (!(Math.abs(gfp.quant_comp_short - -1) > 0)) gfp.quant_comp_short = set.quant_comp_s; // SET_OPTION(quant_comp_short, set.quant_comp_s, -1);\n\n    if (set.expY != 0) {\n      gfp.experimentalY = set.expY != 0;\n    }\n\n    if (enforce != 0) gfp.internal_flags.nsPsy.attackthre = set.st_lrm;else if (!(Math.abs(gfp.internal_flags.nsPsy.attackthre - -1) > 0)) gfp.internal_flags.nsPsy.attackthre = set.st_lrm; // SET_OPTION(short_threshold_lrm, set.st_lrm, -1);\n\n    if (enforce != 0) gfp.internal_flags.nsPsy.attackthre_s = set.st_s;else if (!(Math.abs(gfp.internal_flags.nsPsy.attackthre_s - -1) > 0)) gfp.internal_flags.nsPsy.attackthre_s = set.st_s; // SET_OPTION(short_threshold_s, set.st_s, -1);\n\n    if (enforce != 0) gfp.maskingadjust = set.masking_adj;else if (!(Math.abs(gfp.maskingadjust - 0) > 0)) gfp.maskingadjust = set.masking_adj; // SET_OPTION(maskingadjust, set.masking_adj, 0);\n\n    if (enforce != 0) gfp.maskingadjust_short = set.masking_adj_short;else if (!(Math.abs(gfp.maskingadjust_short - 0) > 0)) gfp.maskingadjust_short = set.masking_adj_short; // SET_OPTION(maskingadjust_short, set.masking_adj_short, 0);\n\n    if (enforce != 0) gfp.ATHlower = -set.ath_lower / 10.0;else if (!(Math.abs(-gfp.ATHlower * 10.0 - 0) > 0)) gfp.ATHlower = -set.ath_lower / 10.0; // SET_OPTION(ATHlower, set.ath_lower, 0);\n\n    if (enforce != 0) gfp.ATHcurve = set.ath_curve;else if (!(Math.abs(gfp.ATHcurve - -1) > 0)) gfp.ATHcurve = set.ath_curve; // SET_OPTION(ATHcurve, set.ath_curve, -1);\n\n    if (enforce != 0) gfp.athaa_sensitivity = set.ath_sensitivity;else if (!(Math.abs(gfp.athaa_sensitivity - -1) > 0)) gfp.athaa_sensitivity = set.ath_sensitivity; // SET_OPTION(athaa_sensitivity, set.ath_sensitivity, 0);\n\n    if (set.interch > 0) {\n      if (enforce != 0) gfp.interChRatio = set.interch;else if (!(Math.abs(gfp.interChRatio - -1) > 0)) gfp.interChRatio = set.interch; // SET_OPTION(interChRatio, set.interch, -1);\n    }\n    /* parameters for which there is no proper set/get interface */\n\n\n    if (set.safejoint > 0) {\n      gfp.exp_nspsytune = gfp.exp_nspsytune | set.safejoint;\n    }\n\n    if (set.sfb21mod > 0) {\n      gfp.exp_nspsytune = gfp.exp_nspsytune | set.sfb21mod << 20;\n    }\n\n    if (enforce != 0) gfp.msfix = set.msfix;else if (!(Math.abs(gfp.msfix - -1) > 0)) gfp.msfix = set.msfix; // SET_OPTION(msfix, set.msfix, -1);\n\n    if (enforce == 0) {\n      gfp.VBR_q = a;\n      gfp.VBR_q_frac = x;\n    }\n  }\n  /**\n   * <PRE>\n   *  Switch mappings for ABR mode\n   *\n   *              kbps  quant q_s safejoint nsmsfix st_lrm  st_s  ns-bass scale   msk ath_lwr ath_curve  interch , sfscale\n   * </PRE>\n   */\n\n\n  var abr_switch_map = [new ABRPresets(8, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -30.0, 11, 0.0012, 1),\n  /*   8, impossible to use in stereo */\n  new ABRPresets(16, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -25.0, 11, 0.0010, 1),\n  /*  16 */\n  new ABRPresets(24, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -20.0, 11, 0.0010, 1),\n  /*  24 */\n  new ABRPresets(32, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -15.0, 11, 0.0010, 1),\n  /*  32 */\n  new ABRPresets(40, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -10.0, 11, 0.0009, 1),\n  /*  40 */\n  new ABRPresets(48, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -10.0, 11, 0.0009, 1),\n  /*  48 */\n  new ABRPresets(56, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -6.0, 11, 0.0008, 1),\n  /*  56 */\n  new ABRPresets(64, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -2.0, 11, 0.0008, 1),\n  /*  64 */\n  new ABRPresets(80, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, .0, 8, 0.0007, 1),\n  /*  80 */\n  new ABRPresets(96, 9, 9, 0, 2.50, 6.60, 145, 0, 0.95, 0, 1.0, 5.5, 0.0006, 1),\n  /*  96 */\n  new ABRPresets(112, 9, 9, 0, 2.25, 6.60, 145, 0, 0.95, 0, 2.0, 4.5, 0.0005, 1),\n  /* 112 */\n  new ABRPresets(128, 9, 9, 0, 1.95, 6.40, 140, 0, 0.95, 0, 3.0, 4, 0.0002, 1),\n  /* 128 */\n  new ABRPresets(160, 9, 9, 1, 1.79, 6.00, 135, 0, 0.95, -2, 5.0, 3.5, 0, 1),\n  /* 160 */\n  new ABRPresets(192, 9, 9, 1, 1.49, 5.60, 125, 0, 0.97, -4, 7.0, 3, 0, 0),\n  /* 192 */\n  new ABRPresets(224, 9, 9, 1, 1.25, 5.20, 125, 0, 0.98, -6, 9.0, 2, 0, 0),\n  /* 224 */\n  new ABRPresets(256, 9, 9, 1, 0.97, 5.20, 125, 0, 1.00, -8, 10.0, 1, 0, 0),\n  /* 256 */\n  new ABRPresets(320, 9, 9, 1, 0.90, 5.20, 125, 0, 1.00, -10, 12.0, 0, 0, 0)\n  /* 320 */\n  ];\n\n  function apply_abr_preset(gfp, preset, enforce) {\n    /* Variables for the ABR stuff */\n    var actual_bitrate = preset;\n    var r = lame.nearestBitrateFullIndex(preset);\n    gfp.VBR = VbrMode.vbr_abr;\n    gfp.VBR_mean_bitrate_kbps = actual_bitrate;\n    gfp.VBR_mean_bitrate_kbps = Math.min(gfp.VBR_mean_bitrate_kbps, 320);\n    gfp.VBR_mean_bitrate_kbps = Math.max(gfp.VBR_mean_bitrate_kbps, 8);\n    gfp.brate = gfp.VBR_mean_bitrate_kbps;\n\n    if (gfp.VBR_mean_bitrate_kbps > 320) {\n      gfp.disable_reservoir = true;\n    }\n    /* parameters for which there is no proper set/get interface */\n\n\n    if (abr_switch_map[r].safejoint > 0) gfp.exp_nspsytune = gfp.exp_nspsytune | 2;\n    /* safejoint */\n\n    if (abr_switch_map[r].sfscale > 0) {\n      gfp.internal_flags.noise_shaping = 2;\n    }\n    /* ns-bass tweaks */\n\n\n    if (Math.abs(abr_switch_map[r].nsbass) > 0) {\n      var k = int(abr_switch_map[r].nsbass * 4);\n      if (k < 0) k += 64;\n      gfp.exp_nspsytune = gfp.exp_nspsytune | k << 2;\n    }\n\n    if (enforce != 0) gfp.quant_comp = abr_switch_map[r].quant_comp;else if (!(Math.abs(gfp.quant_comp - -1) > 0)) gfp.quant_comp = abr_switch_map[r].quant_comp; // SET_OPTION(quant_comp, abr_switch_map[r].quant_comp, -1);\n\n    if (enforce != 0) gfp.quant_comp_short = abr_switch_map[r].quant_comp_s;else if (!(Math.abs(gfp.quant_comp_short - -1) > 0)) gfp.quant_comp_short = abr_switch_map[r].quant_comp_s; // SET_OPTION(quant_comp_short, abr_switch_map[r].quant_comp_s, -1);\n\n    if (enforce != 0) gfp.msfix = abr_switch_map[r].nsmsfix;else if (!(Math.abs(gfp.msfix - -1) > 0)) gfp.msfix = abr_switch_map[r].nsmsfix; // SET_OPTION(msfix, abr_switch_map[r].nsmsfix, -1);\n\n    if (enforce != 0) gfp.internal_flags.nsPsy.attackthre = abr_switch_map[r].st_lrm;else if (!(Math.abs(gfp.internal_flags.nsPsy.attackthre - -1) > 0)) gfp.internal_flags.nsPsy.attackthre = abr_switch_map[r].st_lrm; // SET_OPTION(short_threshold_lrm, abr_switch_map[r].st_lrm, -1);\n\n    if (enforce != 0) gfp.internal_flags.nsPsy.attackthre_s = abr_switch_map[r].st_s;else if (!(Math.abs(gfp.internal_flags.nsPsy.attackthre_s - -1) > 0)) gfp.internal_flags.nsPsy.attackthre_s = abr_switch_map[r].st_s; // SET_OPTION(short_threshold_s, abr_switch_map[r].st_s, -1);\n\n    /*\n     * ABR seems to have big problems with clipping, especially at low\n     * bitrates\n     */\n\n    /*\n     * so we compensate for that here by using a scale value depending on\n     * bitrate\n     */\n\n    if (enforce != 0) gfp.scale = abr_switch_map[r].scale;else if (!(Math.abs(gfp.scale - -1) > 0)) gfp.scale = abr_switch_map[r].scale; // SET_OPTION(scale, abr_switch_map[r].scale, -1);\n\n    if (enforce != 0) gfp.maskingadjust = abr_switch_map[r].masking_adj;else if (!(Math.abs(gfp.maskingadjust - 0) > 0)) gfp.maskingadjust = abr_switch_map[r].masking_adj; // SET_OPTION(maskingadjust, abr_switch_map[r].masking_adj, 0);\n\n    if (abr_switch_map[r].masking_adj > 0) {\n      if (enforce != 0) gfp.maskingadjust_short = abr_switch_map[r].masking_adj * .9;else if (!(Math.abs(gfp.maskingadjust_short - 0) > 0)) gfp.maskingadjust_short = abr_switch_map[r].masking_adj * .9; // SET_OPTION(maskingadjust_short, abr_switch_map[r].masking_adj *\n      // .9, 0);\n    } else {\n      if (enforce != 0) gfp.maskingadjust_short = abr_switch_map[r].masking_adj * 1.1;else if (!(Math.abs(gfp.maskingadjust_short - 0) > 0)) gfp.maskingadjust_short = abr_switch_map[r].masking_adj * 1.1; // SET_OPTION(maskingadjust_short, abr_switch_map[r].masking_adj *\n      // 1.1, 0);\n    }\n\n    if (enforce != 0) gfp.ATHlower = -abr_switch_map[r].ath_lower / 10.;else if (!(Math.abs(-gfp.ATHlower * 10. - 0) > 0)) gfp.ATHlower = -abr_switch_map[r].ath_lower / 10.; // SET_OPTION(ATHlower, abr_switch_map[r].ath_lower, 0);\n\n    if (enforce != 0) gfp.ATHcurve = abr_switch_map[r].ath_curve;else if (!(Math.abs(gfp.ATHcurve - -1) > 0)) gfp.ATHcurve = abr_switch_map[r].ath_curve; // SET_OPTION(ATHcurve, abr_switch_map[r].ath_curve, -1);\n\n    if (enforce != 0) gfp.interChRatio = abr_switch_map[r].interch;else if (!(Math.abs(gfp.interChRatio - -1) > 0)) gfp.interChRatio = abr_switch_map[r].interch; // SET_OPTION(interChRatio, abr_switch_map[r].interch, -1);\n\n    return preset;\n  }\n\n  this.apply_preset = function (gfp, preset, enforce) {\n    /* translate legacy presets */\n    switch (preset) {\n      case Lame.R3MIX:\n        {\n          preset = Lame.V3;\n          gfp.VBR = VbrMode.vbr_mtrh;\n          break;\n        }\n\n      case Lame.MEDIUM:\n        {\n          preset = Lame.V4;\n          gfp.VBR = VbrMode.vbr_rh;\n          break;\n        }\n\n      case Lame.MEDIUM_FAST:\n        {\n          preset = Lame.V4;\n          gfp.VBR = VbrMode.vbr_mtrh;\n          break;\n        }\n\n      case Lame.STANDARD:\n        {\n          preset = Lame.V2;\n          gfp.VBR = VbrMode.vbr_rh;\n          break;\n        }\n\n      case Lame.STANDARD_FAST:\n        {\n          preset = Lame.V2;\n          gfp.VBR = VbrMode.vbr_mtrh;\n          break;\n        }\n\n      case Lame.EXTREME:\n        {\n          preset = Lame.V0;\n          gfp.VBR = VbrMode.vbr_rh;\n          break;\n        }\n\n      case Lame.EXTREME_FAST:\n        {\n          preset = Lame.V0;\n          gfp.VBR = VbrMode.vbr_mtrh;\n          break;\n        }\n\n      case Lame.INSANE:\n        {\n          preset = 320;\n          gfp.preset = preset;\n          apply_abr_preset(gfp, preset, enforce);\n          gfp.VBR = VbrMode.vbr_off;\n          return preset;\n        }\n    }\n\n    gfp.preset = preset;\n    {\n      switch (preset) {\n        case Lame.V9:\n          apply_vbr_preset(gfp, 9, enforce);\n          return preset;\n\n        case Lame.V8:\n          apply_vbr_preset(gfp, 8, enforce);\n          return preset;\n\n        case Lame.V7:\n          apply_vbr_preset(gfp, 7, enforce);\n          return preset;\n\n        case Lame.V6:\n          apply_vbr_preset(gfp, 6, enforce);\n          return preset;\n\n        case Lame.V5:\n          apply_vbr_preset(gfp, 5, enforce);\n          return preset;\n\n        case Lame.V4:\n          apply_vbr_preset(gfp, 4, enforce);\n          return preset;\n\n        case Lame.V3:\n          apply_vbr_preset(gfp, 3, enforce);\n          return preset;\n\n        case Lame.V2:\n          apply_vbr_preset(gfp, 2, enforce);\n          return preset;\n\n        case Lame.V1:\n          apply_vbr_preset(gfp, 1, enforce);\n          return preset;\n\n        case Lame.V0:\n          apply_vbr_preset(gfp, 0, enforce);\n          return preset;\n\n        default:\n          break;\n      }\n    }\n\n    if (8 <= preset && preset <= 320) {\n      return apply_abr_preset(gfp, preset, enforce);\n    }\n    /* no corresponding preset found */\n\n\n    gfp.preset = 0;\n    return preset;\n  }; // Rest from getset.c:\n\n  /**\n   * VBR quality level.<BR>\n   * 0 = highest<BR>\n   * 9 = lowest\n   */\n\n\n  function lame_set_VBR_q(gfp, VBR_q) {\n    var ret = 0;\n\n    if (0 > VBR_q) {\n      /* Unknown VBR quality level! */\n      ret = -1;\n      VBR_q = 0;\n    }\n\n    if (9 < VBR_q) {\n      ret = -1;\n      VBR_q = 9;\n    }\n\n    gfp.VBR_q = VBR_q;\n    gfp.VBR_q_frac = 0;\n    return ret;\n  }\n}\n\nmodule.exports = Presets;","map":null,"metadata":{},"sourceType":"script"}