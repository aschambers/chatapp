{"ast":null,"code":"var common = require('./common.js');\n\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar MeanBits = require('./MeanBits.js');\n\nvar Encoder = require('./Encoder.js');\n\nvar L3Side = require('./L3Side.js');\n\nvar LameInternalFlags = require('./LameInternalFlags.js');\n\nfunction CBRNewIterationLoop(_quantize) {\n  var quantize = _quantize;\n  this.quantize = quantize;\n\n  this.iteration_loop = function (gfp, pe, ms_ener_ratio, ratio) {\n    var gfc = gfp.internal_flags;\n    var l3_xmin = new_float(L3Side.SFBMAX);\n    var xrpow = new_float(576);\n    var targ_bits = new_int(2);\n    var mean_bits = 0,\n        max_bits;\n    var l3_side = gfc.l3_side;\n    var mb = new MeanBits(mean_bits);\n    this.quantize.rv.ResvFrameBegin(gfp, mb);\n    mean_bits = mb.bits;\n    /* quantize! */\n\n    for (var gr = 0; gr < gfc.mode_gr; gr++) {\n      /*\n       * calculate needed bits\n       */\n      max_bits = this.quantize.qupvt.on_pe(gfp, pe, targ_bits, mean_bits, gr, gr);\n\n      if (gfc.mode_ext == Encoder.MPG_MD_MS_LR) {\n        this.quantize.ms_convert(gfc.l3_side, gr);\n        this.quantize.qupvt.reduce_side(targ_bits, ms_ener_ratio[gr], mean_bits, max_bits);\n      }\n\n      for (var ch = 0; ch < gfc.channels_out; ch++) {\n        var adjust, masking_lower_db;\n        var cod_info = l3_side.tt[gr][ch];\n\n        if (cod_info.block_type != Encoder.SHORT_TYPE) {\n          // NORM, START or STOP type\n          adjust = 0;\n          masking_lower_db = gfc.PSY.mask_adjust - adjust;\n        } else {\n          adjust = 0;\n          masking_lower_db = gfc.PSY.mask_adjust_short - adjust;\n        }\n\n        gfc.masking_lower = Math.pow(10.0, masking_lower_db * 0.1);\n        /*\n         * init_outer_loop sets up cod_info, scalefac and xrpow\n         */\n\n        this.quantize.init_outer_loop(gfc, cod_info);\n\n        if (this.quantize.init_xrpow(gfc, cod_info, xrpow)) {\n          /*\n           * xr contains energy we will have to encode calculate the\n           * masking abilities find some good quantization in\n           * outer_loop\n           */\n          this.quantize.qupvt.calc_xmin(gfp, ratio[gr][ch], cod_info, l3_xmin);\n          this.quantize.outer_loop(gfp, cod_info, l3_xmin, xrpow, ch, targ_bits[ch]);\n        }\n\n        this.quantize.iteration_finish_one(gfc, gr, ch);\n        assert(cod_info.part2_3_length <= LameInternalFlags.MAX_BITS_PER_CHANNEL);\n        assert(cod_info.part2_3_length <= targ_bits[ch]);\n      }\n      /* for ch */\n\n    }\n    /* for gr */\n\n\n    this.quantize.rv.ResvFrameEnd(gfc, mean_bits);\n  };\n}\n\nmodule.exports = CBRNewIterationLoop;","map":null,"metadata":{},"sourceType":"script"}