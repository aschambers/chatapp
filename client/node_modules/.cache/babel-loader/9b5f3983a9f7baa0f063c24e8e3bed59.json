{"ast":null,"code":"var common = require('./common.js');\n\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar Takehiro = require('./Takehiro.js');\n\nvar Tables = require('./Tables.js');\n\nvar Encoder = require('./Encoder.js');\n\nvar LameInternalFlags = require('./LameInternalFlags.js');\n\nBitStream.EQ = function (a, b) {\n  return Math.abs(a) > Math.abs(b) ? Math.abs(a - b) <= Math.abs(a) * 1e-6 : Math.abs(a - b) <= Math.abs(b) * 1e-6;\n};\n\nBitStream.NEQ = function (a, b) {\n  return !BitStream.EQ(a, b);\n};\n\nfunction BitStream() {\n  var self = this;\n  var CRC16_POLYNOMIAL = 0x8005;\n  /*\n   * we work with ints, so when doing bit manipulation, we limit ourselves to\n   * MAX_LENGTH-2 just to be on the safe side\n   */\n\n  var MAX_LENGTH = 32; //GainAnalysis ga;\n  //MPGLib mpg;\n  //Version ver;\n  //VBRTag vbr;\n\n  var ga = null;\n  var mpg = null;\n  var ver = null;\n  var vbr = null; //public final void setModules(GainAnalysis ga, MPGLib mpg, Version ver,\n  //\tVBRTag vbr) {\n\n  this.setModules = function (_ga, _mpg, _ver, _vbr) {\n    ga = _ga;\n    mpg = _mpg;\n    ver = _ver;\n    vbr = _vbr;\n  };\n  /**\n   * Bit stream buffer.\n   */\n  //private byte[] buf;\n\n\n  var buf = null;\n  /**\n   * Bit counter of bit stream.\n   */\n\n  var totbit = 0;\n  /**\n   * Pointer to top byte in buffer.\n   */\n\n  var bufByteIdx = 0;\n  /**\n   * Pointer to top bit of top byte in buffer.\n   */\n\n  var bufBitIdx = 0;\n  /**\n   * compute bitsperframe and mean_bits for a layer III frame\n   */\n\n  this.getframebits = function (gfp) {\n    var gfc = gfp.internal_flags;\n    var bit_rate;\n    /* get bitrate in kbps [?] */\n\n    if (gfc.bitrate_index != 0) bit_rate = Tables.bitrate_table[gfp.version][gfc.bitrate_index];else bit_rate = gfp.brate;\n    assert(8 <= bit_rate && bit_rate <= 640);\n    /* main encoding routine toggles padding on and off */\n\n    /* one Layer3 Slot consists of 8 bits */\n\n    var bytes = 0 | (gfp.version + 1) * 72000 * bit_rate / gfp.out_samplerate + gfc.padding;\n    return 8 * bytes;\n  };\n\n  function putheader_bits(gfc) {\n    System.arraycopy(gfc.header[gfc.w_ptr].buf, 0, buf, bufByteIdx, gfc.sideinfo_len);\n    bufByteIdx += gfc.sideinfo_len;\n    totbit += gfc.sideinfo_len * 8;\n    gfc.w_ptr = gfc.w_ptr + 1 & LameInternalFlags.MAX_HEADER_BUF - 1;\n  }\n  /**\n   * write j bits into the bit stream\n   */\n\n\n  function putbits2(gfc, val, j) {\n    assert(j < MAX_LENGTH - 2);\n\n    while (j > 0) {\n      var k;\n\n      if (bufBitIdx == 0) {\n        bufBitIdx = 8;\n        bufByteIdx++;\n        assert(bufByteIdx < Lame.LAME_MAXMP3BUFFER);\n        assert(gfc.header[gfc.w_ptr].write_timing >= totbit);\n\n        if (gfc.header[gfc.w_ptr].write_timing == totbit) {\n          putheader_bits(gfc);\n        }\n\n        buf[bufByteIdx] = 0;\n      }\n\n      k = Math.min(j, bufBitIdx);\n      j -= k;\n      bufBitIdx -= k;\n      assert(j < MAX_LENGTH);\n      /* 32 too large on 32 bit machines */\n\n      assert(bufBitIdx < MAX_LENGTH);\n      buf[bufByteIdx] |= val >> j << bufBitIdx;\n      totbit += k;\n    }\n  }\n  /**\n   * write j bits into the bit stream, ignoring frame headers\n   */\n\n\n  function putbits_noheaders(gfc, val, j) {\n    assert(j < MAX_LENGTH - 2);\n\n    while (j > 0) {\n      var k;\n\n      if (bufBitIdx == 0) {\n        bufBitIdx = 8;\n        bufByteIdx++;\n        assert(bufByteIdx < Lame.LAME_MAXMP3BUFFER);\n        buf[bufByteIdx] = 0;\n      }\n\n      k = Math.min(j, bufBitIdx);\n      j -= k;\n      bufBitIdx -= k;\n      assert(j < MAX_LENGTH);\n      /* 32 too large on 32 bit machines */\n\n      assert(bufBitIdx < MAX_LENGTH);\n      buf[bufByteIdx] |= val >> j << bufBitIdx;\n      totbit += k;\n    }\n  }\n  /**\n   * Some combinations of bitrate, Fs, and stereo make it impossible to stuff\n   * out a frame using just main_data, due to the limited number of bits to\n   * indicate main_data_length. In these situations, we put stuffing bits into\n   * the ancillary data...\n   */\n\n\n  function drain_into_ancillary(gfp, remainingBits) {\n    var gfc = gfp.internal_flags;\n    var i;\n    assert(remainingBits >= 0);\n\n    if (remainingBits >= 8) {\n      putbits2(gfc, 0x4c, 8);\n      remainingBits -= 8;\n    }\n\n    if (remainingBits >= 8) {\n      putbits2(gfc, 0x41, 8);\n      remainingBits -= 8;\n    }\n\n    if (remainingBits >= 8) {\n      putbits2(gfc, 0x4d, 8);\n      remainingBits -= 8;\n    }\n\n    if (remainingBits >= 8) {\n      putbits2(gfc, 0x45, 8);\n      remainingBits -= 8;\n    }\n\n    if (remainingBits >= 32) {\n      var version = ver.getLameShortVersion();\n      if (remainingBits >= 32) for (i = 0; i < version.length && remainingBits >= 8; ++i) {\n        remainingBits -= 8;\n        putbits2(gfc, version.charAt(i), 8);\n      }\n    }\n\n    for (; remainingBits >= 1; remainingBits -= 1) {\n      putbits2(gfc, gfc.ancillary_flag, 1);\n      gfc.ancillary_flag ^= !gfp.disable_reservoir ? 1 : 0;\n    }\n\n    assert(remainingBits == 0);\n  }\n  /**\n   * write N bits into the header\n   */\n\n\n  function writeheader(gfc, val, j) {\n    var ptr = gfc.header[gfc.h_ptr].ptr;\n\n    while (j > 0) {\n      var k = Math.min(j, 8 - (ptr & 7));\n      j -= k;\n      assert(j < MAX_LENGTH);\n      /* >> 32 too large for 32 bit machines */\n\n      gfc.header[gfc.h_ptr].buf[ptr >> 3] |= val >> j << 8 - (ptr & 7) - k;\n      ptr += k;\n    }\n\n    gfc.header[gfc.h_ptr].ptr = ptr;\n  }\n\n  function CRC_update(value, crc) {\n    value <<= 8;\n\n    for (var i = 0; i < 8; i++) {\n      value <<= 1;\n      crc <<= 1;\n      if (((crc ^ value) & 0x10000) != 0) crc ^= CRC16_POLYNOMIAL;\n    }\n\n    return crc;\n  }\n\n  this.CRC_writeheader = function (gfc, header) {\n    var crc = 0xffff;\n    /* (jo) init crc16 for error_protection */\n\n    crc = CRC_update(header[2] & 0xff, crc);\n    crc = CRC_update(header[3] & 0xff, crc);\n\n    for (var i = 6; i < gfc.sideinfo_len; i++) {\n      crc = CRC_update(header[i] & 0xff, crc);\n    }\n\n    header[4] = byte(crc >> 8);\n    header[5] = byte(crc & 255);\n  };\n\n  function encodeSideInfo2(gfp, bitsPerFrame) {\n    var gfc = gfp.internal_flags;\n    var l3_side;\n    var gr, ch;\n    l3_side = gfc.l3_side;\n    gfc.header[gfc.h_ptr].ptr = 0;\n    Arrays.fill(gfc.header[gfc.h_ptr].buf, 0, gfc.sideinfo_len, 0);\n    if (gfp.out_samplerate < 16000) writeheader(gfc, 0xffe, 12);else writeheader(gfc, 0xfff, 12);\n    writeheader(gfc, gfp.version, 1);\n    writeheader(gfc, 4 - 3, 2);\n    writeheader(gfc, !gfp.error_protection ? 1 : 0, 1);\n    writeheader(gfc, gfc.bitrate_index, 4);\n    writeheader(gfc, gfc.samplerate_index, 2);\n    writeheader(gfc, gfc.padding, 1);\n    writeheader(gfc, gfp.extension, 1);\n    writeheader(gfc, gfp.mode.ordinal(), 2);\n    writeheader(gfc, gfc.mode_ext, 2);\n    writeheader(gfc, gfp.copyright, 1);\n    writeheader(gfc, gfp.original, 1);\n    writeheader(gfc, gfp.emphasis, 2);\n\n    if (gfp.error_protection) {\n      writeheader(gfc, 0, 16);\n      /* dummy */\n    }\n\n    if (gfp.version == 1) {\n      /* MPEG1 */\n      assert(l3_side.main_data_begin >= 0);\n      writeheader(gfc, l3_side.main_data_begin, 9);\n      if (gfc.channels_out == 2) writeheader(gfc, l3_side.private_bits, 3);else writeheader(gfc, l3_side.private_bits, 5);\n\n      for (ch = 0; ch < gfc.channels_out; ch++) {\n        var band;\n\n        for (band = 0; band < 4; band++) {\n          writeheader(gfc, l3_side.scfsi[ch][band], 1);\n        }\n      }\n\n      for (gr = 0; gr < 2; gr++) {\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          var gi = l3_side.tt[gr][ch];\n          writeheader(gfc, gi.part2_3_length + gi.part2_length, 12);\n          writeheader(gfc, gi.big_values / 2, 9);\n          writeheader(gfc, gi.global_gain, 8);\n          writeheader(gfc, gi.scalefac_compress, 4);\n\n          if (gi.block_type != Encoder.NORM_TYPE) {\n            writeheader(gfc, 1, 1);\n            /* window_switching_flag */\n\n            writeheader(gfc, gi.block_type, 2);\n            writeheader(gfc, gi.mixed_block_flag, 1);\n            if (gi.table_select[0] == 14) gi.table_select[0] = 16;\n            writeheader(gfc, gi.table_select[0], 5);\n            if (gi.table_select[1] == 14) gi.table_select[1] = 16;\n            writeheader(gfc, gi.table_select[1], 5);\n            writeheader(gfc, gi.subblock_gain[0], 3);\n            writeheader(gfc, gi.subblock_gain[1], 3);\n            writeheader(gfc, gi.subblock_gain[2], 3);\n          } else {\n            writeheader(gfc, 0, 1);\n            /* window_switching_flag */\n\n            if (gi.table_select[0] == 14) gi.table_select[0] = 16;\n            writeheader(gfc, gi.table_select[0], 5);\n            if (gi.table_select[1] == 14) gi.table_select[1] = 16;\n            writeheader(gfc, gi.table_select[1], 5);\n            if (gi.table_select[2] == 14) gi.table_select[2] = 16;\n            writeheader(gfc, gi.table_select[2], 5);\n            assert(0 <= gi.region0_count && gi.region0_count < 16);\n            assert(0 <= gi.region1_count && gi.region1_count < 8);\n            writeheader(gfc, gi.region0_count, 4);\n            writeheader(gfc, gi.region1_count, 3);\n          }\n\n          writeheader(gfc, gi.preflag, 1);\n          writeheader(gfc, gi.scalefac_scale, 1);\n          writeheader(gfc, gi.count1table_select, 1);\n        }\n      }\n    } else {\n      /* MPEG2 */\n      assert(l3_side.main_data_begin >= 0);\n      writeheader(gfc, l3_side.main_data_begin, 8);\n      writeheader(gfc, l3_side.private_bits, gfc.channels_out);\n      gr = 0;\n\n      for (ch = 0; ch < gfc.channels_out; ch++) {\n        var gi = l3_side.tt[gr][ch];\n        writeheader(gfc, gi.part2_3_length + gi.part2_length, 12);\n        writeheader(gfc, gi.big_values / 2, 9);\n        writeheader(gfc, gi.global_gain, 8);\n        writeheader(gfc, gi.scalefac_compress, 9);\n\n        if (gi.block_type != Encoder.NORM_TYPE) {\n          writeheader(gfc, 1, 1);\n          /* window_switching_flag */\n\n          writeheader(gfc, gi.block_type, 2);\n          writeheader(gfc, gi.mixed_block_flag, 1);\n          if (gi.table_select[0] == 14) gi.table_select[0] = 16;\n          writeheader(gfc, gi.table_select[0], 5);\n          if (gi.table_select[1] == 14) gi.table_select[1] = 16;\n          writeheader(gfc, gi.table_select[1], 5);\n          writeheader(gfc, gi.subblock_gain[0], 3);\n          writeheader(gfc, gi.subblock_gain[1], 3);\n          writeheader(gfc, gi.subblock_gain[2], 3);\n        } else {\n          writeheader(gfc, 0, 1);\n          /* window_switching_flag */\n\n          if (gi.table_select[0] == 14) gi.table_select[0] = 16;\n          writeheader(gfc, gi.table_select[0], 5);\n          if (gi.table_select[1] == 14) gi.table_select[1] = 16;\n          writeheader(gfc, gi.table_select[1], 5);\n          if (gi.table_select[2] == 14) gi.table_select[2] = 16;\n          writeheader(gfc, gi.table_select[2], 5);\n          assert(0 <= gi.region0_count && gi.region0_count < 16);\n          assert(0 <= gi.region1_count && gi.region1_count < 8);\n          writeheader(gfc, gi.region0_count, 4);\n          writeheader(gfc, gi.region1_count, 3);\n        }\n\n        writeheader(gfc, gi.scalefac_scale, 1);\n        writeheader(gfc, gi.count1table_select, 1);\n      }\n    }\n\n    if (gfp.error_protection) {\n      /* (jo) error_protection: add crc16 information to header */\n      CRC_writeheader(gfc, gfc.header[gfc.h_ptr].buf);\n    }\n\n    {\n      var old = gfc.h_ptr;\n      assert(gfc.header[old].ptr == gfc.sideinfo_len * 8);\n      gfc.h_ptr = old + 1 & LameInternalFlags.MAX_HEADER_BUF - 1;\n      gfc.header[gfc.h_ptr].write_timing = gfc.header[old].write_timing + bitsPerFrame;\n\n      if (gfc.h_ptr == gfc.w_ptr) {\n        /* yikes! we are out of header buffer space */\n        System.err.println(\"Error: MAX_HEADER_BUF too small in bitstream.c \\n\");\n      }\n    }\n  }\n\n  function huffman_coder_count1(gfc, gi) {\n    /* Write count1 area */\n    var h = Tables.ht[gi.count1table_select + 32];\n    var i,\n        bits = 0;\n    var ix = gi.big_values;\n    var xr = gi.big_values;\n    assert(gi.count1table_select < 2);\n\n    for (i = (gi.count1 - gi.big_values) / 4; i > 0; --i) {\n      var huffbits = 0;\n      var p = 0,\n          v;\n      v = gi.l3_enc[ix + 0];\n\n      if (v != 0) {\n        p += 8;\n        if (gi.xr[xr + 0] < 0) huffbits++;\n        assert(v <= 1);\n      }\n\n      v = gi.l3_enc[ix + 1];\n\n      if (v != 0) {\n        p += 4;\n        huffbits *= 2;\n        if (gi.xr[xr + 1] < 0) huffbits++;\n        assert(v <= 1);\n      }\n\n      v = gi.l3_enc[ix + 2];\n\n      if (v != 0) {\n        p += 2;\n        huffbits *= 2;\n        if (gi.xr[xr + 2] < 0) huffbits++;\n        assert(v <= 1);\n      }\n\n      v = gi.l3_enc[ix + 3];\n\n      if (v != 0) {\n        p++;\n        huffbits *= 2;\n        if (gi.xr[xr + 3] < 0) huffbits++;\n        assert(v <= 1);\n      }\n\n      ix += 4;\n      xr += 4;\n      putbits2(gfc, huffbits + h.table[p], h.hlen[p]);\n      bits += h.hlen[p];\n    }\n\n    return bits;\n  }\n  /**\n   * Implements the pseudocode of page 98 of the IS\n   */\n\n\n  function Huffmancode(gfc, tableindex, start, end, gi) {\n    var h = Tables.ht[tableindex];\n    var bits = 0;\n    assert(tableindex < 32);\n    if (0 == tableindex) return bits;\n\n    for (var i = start; i < end; i += 2) {\n      var cbits = 0;\n      var xbits = 0;\n      var linbits = h.xlen;\n      var xlen = h.xlen;\n      var ext = 0;\n      var x1 = gi.l3_enc[i];\n      var x2 = gi.l3_enc[i + 1];\n\n      if (x1 != 0) {\n        if (gi.xr[i] < 0) ext++;\n        cbits--;\n      }\n\n      if (tableindex > 15) {\n        /* use ESC-words */\n        if (x1 > 14) {\n          var linbits_x1 = x1 - 15;\n          assert(linbits_x1 <= h.linmax);\n          ext |= linbits_x1 << 1;\n          xbits = linbits;\n          x1 = 15;\n        }\n\n        if (x2 > 14) {\n          var linbits_x2 = x2 - 15;\n          assert(linbits_x2 <= h.linmax);\n          ext <<= linbits;\n          ext |= linbits_x2;\n          xbits += linbits;\n          x2 = 15;\n        }\n\n        xlen = 16;\n      }\n\n      if (x2 != 0) {\n        ext <<= 1;\n        if (gi.xr[i + 1] < 0) ext++;\n        cbits--;\n      }\n\n      assert((x1 | x2) < 16);\n      x1 = x1 * xlen + x2;\n      xbits -= cbits;\n      cbits += h.hlen[x1];\n      assert(cbits <= MAX_LENGTH);\n      assert(xbits <= MAX_LENGTH);\n      putbits2(gfc, h.table[x1], cbits);\n      putbits2(gfc, ext, xbits);\n      bits += cbits + xbits;\n    }\n\n    return bits;\n  }\n  /**\n   * Note the discussion of huffmancodebits() on pages 28 and 29 of the IS, as\n   * well as the definitions of the side information on pages 26 and 27.\n   */\n\n\n  function ShortHuffmancodebits(gfc, gi) {\n    var region1Start = 3 * gfc.scalefac_band.s[3];\n    if (region1Start > gi.big_values) region1Start = gi.big_values;\n    /* short blocks do not have a region2 */\n\n    var bits = Huffmancode(gfc, gi.table_select[0], 0, region1Start, gi);\n    bits += Huffmancode(gfc, gi.table_select[1], region1Start, gi.big_values, gi);\n    return bits;\n  }\n\n  function LongHuffmancodebits(gfc, gi) {\n    var bigvalues, bits;\n    var region1Start, region2Start;\n    bigvalues = gi.big_values;\n    assert(0 <= bigvalues && bigvalues <= 576);\n    var i = gi.region0_count + 1;\n    assert(0 <= i);\n    assert(i < gfc.scalefac_band.l.length);\n    region1Start = gfc.scalefac_band.l[i];\n    i += gi.region1_count + 1;\n    assert(0 <= i);\n    assert(i < gfc.scalefac_band.l.length);\n    region2Start = gfc.scalefac_band.l[i];\n    if (region1Start > bigvalues) region1Start = bigvalues;\n    if (region2Start > bigvalues) region2Start = bigvalues;\n    bits = Huffmancode(gfc, gi.table_select[0], 0, region1Start, gi);\n    bits += Huffmancode(gfc, gi.table_select[1], region1Start, region2Start, gi);\n    bits += Huffmancode(gfc, gi.table_select[2], region2Start, bigvalues, gi);\n    return bits;\n  }\n\n  function writeMainData(gfp) {\n    var gr,\n        ch,\n        sfb,\n        data_bits,\n        tot_bits = 0;\n    var gfc = gfp.internal_flags;\n    var l3_side = gfc.l3_side;\n\n    if (gfp.version == 1) {\n      /* MPEG 1 */\n      for (gr = 0; gr < 2; gr++) {\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          var gi = l3_side.tt[gr][ch];\n          var slen1 = Takehiro.slen1_tab[gi.scalefac_compress];\n          var slen2 = Takehiro.slen2_tab[gi.scalefac_compress];\n          data_bits = 0;\n\n          for (sfb = 0; sfb < gi.sfbdivide; sfb++) {\n            if (gi.scalefac[sfb] == -1) continue;\n            /* scfsi is used */\n\n            putbits2(gfc, gi.scalefac[sfb], slen1);\n            data_bits += slen1;\n          }\n\n          for (; sfb < gi.sfbmax; sfb++) {\n            if (gi.scalefac[sfb] == -1) continue;\n            /* scfsi is used */\n\n            putbits2(gfc, gi.scalefac[sfb], slen2);\n            data_bits += slen2;\n          }\n\n          assert(data_bits == gi.part2_length);\n\n          if (gi.block_type == Encoder.SHORT_TYPE) {\n            data_bits += ShortHuffmancodebits(gfc, gi);\n          } else {\n            data_bits += LongHuffmancodebits(gfc, gi);\n          }\n\n          data_bits += huffman_coder_count1(gfc, gi);\n          /* does bitcount in quantize.c agree with actual bit count? */\n\n          assert(data_bits == gi.part2_3_length + gi.part2_length);\n          tot_bits += data_bits;\n        }\n        /* for ch */\n\n      }\n      /* for gr */\n\n    } else {\n      /* MPEG 2 */\n      gr = 0;\n\n      for (ch = 0; ch < gfc.channels_out; ch++) {\n        var gi = l3_side.tt[gr][ch];\n        var i,\n            sfb_partition,\n            scale_bits = 0;\n        assert(gi.sfb_partition_table != null);\n        data_bits = 0;\n        sfb = 0;\n        sfb_partition = 0;\n\n        if (gi.block_type == Encoder.SHORT_TYPE) {\n          for (; sfb_partition < 4; sfb_partition++) {\n            var sfbs = gi.sfb_partition_table[sfb_partition] / 3;\n            var slen = gi.slen[sfb_partition];\n\n            for (i = 0; i < sfbs; i++, sfb++) {\n              putbits2(gfc, Math.max(gi.scalefac[sfb * 3 + 0], 0), slen);\n              putbits2(gfc, Math.max(gi.scalefac[sfb * 3 + 1], 0), slen);\n              putbits2(gfc, Math.max(gi.scalefac[sfb * 3 + 2], 0), slen);\n              scale_bits += 3 * slen;\n            }\n          }\n\n          data_bits += ShortHuffmancodebits(gfc, gi);\n        } else {\n          for (; sfb_partition < 4; sfb_partition++) {\n            var sfbs = gi.sfb_partition_table[sfb_partition];\n            var slen = gi.slen[sfb_partition];\n\n            for (i = 0; i < sfbs; i++, sfb++) {\n              putbits2(gfc, Math.max(gi.scalefac[sfb], 0), slen);\n              scale_bits += slen;\n            }\n          }\n\n          data_bits += LongHuffmancodebits(gfc, gi);\n        }\n\n        data_bits += huffman_coder_count1(gfc, gi);\n        /* does bitcount in quantize.c agree with actual bit count? */\n\n        assert(data_bits == gi.part2_3_length);\n        assert(scale_bits == gi.part2_length);\n        tot_bits += scale_bits + data_bits;\n      }\n      /* for ch */\n\n    }\n    /* for gf */\n\n\n    return tot_bits;\n  }\n  /* main_data */\n\n\n  function TotalBytes() {\n    this.total = 0;\n  }\n  /*\n   * compute the number of bits required to flush all mp3 frames currently in\n   * the buffer. This should be the same as the reservoir size. Only call this\n   * routine between frames - i.e. only after all headers and data have been\n   * added to the buffer by format_bitstream().\n   *\n   * Also compute total_bits_output = size of mp3 buffer (including frame\n   * headers which may not have yet been send to the mp3 buffer) + number of\n   * bits needed to flush all mp3 frames.\n   *\n   * total_bytes_output is the size of the mp3 output buffer if\n   * lame_encode_flush_nogap() was called right now.\n   */\n\n\n  function compute_flushbits(gfp, total_bytes_output) {\n    var gfc = gfp.internal_flags;\n    var flushbits, remaining_headers;\n    var bitsPerFrame;\n    var last_ptr, first_ptr;\n    first_ptr = gfc.w_ptr;\n    /* first header to add to bitstream */\n\n    last_ptr = gfc.h_ptr - 1;\n    /* last header to add to bitstream */\n\n    if (last_ptr == -1) last_ptr = LameInternalFlags.MAX_HEADER_BUF - 1;\n    /* add this many bits to bitstream so we can flush all headers */\n\n    flushbits = gfc.header[last_ptr].write_timing - totbit;\n    total_bytes_output.total = flushbits;\n\n    if (flushbits >= 0) {\n      /* if flushbits >= 0, some headers have not yet been written */\n\n      /* reduce flushbits by the size of the headers */\n      remaining_headers = 1 + last_ptr - first_ptr;\n      if (last_ptr < first_ptr) remaining_headers = 1 + last_ptr - first_ptr + LameInternalFlags.MAX_HEADER_BUF;\n      flushbits -= remaining_headers * 8 * gfc.sideinfo_len;\n    }\n    /*\n     * finally, add some bits so that the last frame is complete these bits\n     * are not necessary to decode the last frame, but some decoders will\n     * ignore last frame if these bits are missing\n     */\n\n\n    bitsPerFrame = self.getframebits(gfp);\n    flushbits += bitsPerFrame;\n    total_bytes_output.total += bitsPerFrame;\n    /* round up: */\n\n    if (total_bytes_output.total % 8 != 0) total_bytes_output.total = 1 + total_bytes_output.total / 8;else total_bytes_output.total = total_bytes_output.total / 8;\n    total_bytes_output.total += bufByteIdx + 1;\n\n    if (flushbits < 0) {\n      System.err.println(\"strange error flushing buffer ... \\n\");\n    }\n\n    return flushbits;\n  }\n\n  this.flush_bitstream = function (gfp) {\n    var gfc = gfp.internal_flags;\n    var l3_side;\n    var flushbits;\n    var last_ptr = gfc.h_ptr - 1;\n    /* last header to add to bitstream */\n\n    if (last_ptr == -1) last_ptr = LameInternalFlags.MAX_HEADER_BUF - 1;\n    l3_side = gfc.l3_side;\n    if ((flushbits = compute_flushbits(gfp, new TotalBytes())) < 0) return;\n    drain_into_ancillary(gfp, flushbits);\n    /* check that the 100% of the last frame has been written to bitstream */\n\n    assert(gfc.header[last_ptr].write_timing + this.getframebits(gfp) == totbit);\n    /*\n     * we have padded out all frames with ancillary data, which is the same\n     * as filling the bitreservoir with ancillary data, so :\n     */\n\n    gfc.ResvSize = 0;\n    l3_side.main_data_begin = 0;\n    /* save the ReplayGain value */\n\n    if (gfc.findReplayGain) {\n      var RadioGain = ga.GetTitleGain(gfc.rgdata);\n      assert(NEQ(RadioGain, GainAnalysis.GAIN_NOT_ENOUGH_SAMPLES));\n      gfc.RadioGain = Math.floor(RadioGain * 10.0 + 0.5) | 0;\n      /* round to nearest */\n    }\n    /* find the gain and scale change required for no clipping */\n\n\n    if (gfc.findPeakSample) {\n      gfc.noclipGainChange = Math.ceil(Math.log10(gfc.PeakSample / 32767.0) * 20.0 * 10.0) | 0;\n      /* round up */\n\n      if (gfc.noclipGainChange > 0) {\n        /* clipping occurs */\n        if (EQ(gfp.scale, 1.0) || EQ(gfp.scale, 0.0)) gfc.noclipScale = Math.floor(32767.0 / gfc.PeakSample * 100.0) / 100.0;\n        /* round down */\n        else {\n            /*\n             * the user specified his own scaling factor. We could\n             * suggest the scaling factor of\n             * (32767.0/gfp.PeakSample)*(gfp.scale) but it's usually\n             * very inaccurate. So we'd rather not advice him on the\n             * scaling factor.\n             */\n            gfc.noclipScale = -1;\n          }\n      } else\n        /* no clipping */\n        gfc.noclipScale = -1;\n    }\n  };\n\n  this.add_dummy_byte = function (gfp, val, n) {\n    var gfc = gfp.internal_flags;\n    var i;\n\n    while (n-- > 0) {\n      putbits_noheaders(gfc, val, 8);\n\n      for (i = 0; i < LameInternalFlags.MAX_HEADER_BUF; ++i) gfc.header[i].write_timing += 8;\n    }\n  };\n  /**\n   * This is called after a frame of audio has been quantized and coded. It\n   * will write the encoded audio to the bitstream. Note that from a layer3\n   * encoder's perspective the bit stream is primarily a series of main_data()\n   * blocks, with header and side information inserted at the proper locations\n   * to maintain framing. (See Figure A.7 in the IS).\n   */\n\n\n  this.format_bitstream = function (gfp) {\n    var gfc = gfp.internal_flags;\n    var l3_side;\n    l3_side = gfc.l3_side;\n    var bitsPerFrame = this.getframebits(gfp);\n    drain_into_ancillary(gfp, l3_side.resvDrain_pre);\n    encodeSideInfo2(gfp, bitsPerFrame);\n    var bits = 8 * gfc.sideinfo_len;\n    bits += writeMainData(gfp);\n    drain_into_ancillary(gfp, l3_side.resvDrain_post);\n    bits += l3_side.resvDrain_post;\n    l3_side.main_data_begin += (bitsPerFrame - bits) / 8;\n    /*\n     * compare number of bits needed to clear all buffered mp3 frames with\n     * what we think the resvsize is:\n     */\n\n    if (compute_flushbits(gfp, new TotalBytes()) != gfc.ResvSize) {\n      System.err.println(\"Internal buffer inconsistency. flushbits <> ResvSize\");\n    }\n    /*\n     * compare main_data_begin for the next frame with what we think the\n     * resvsize is:\n     */\n\n\n    if (l3_side.main_data_begin * 8 != gfc.ResvSize) {\n      System.err.printf(\"bit reservoir error: \\n\" + \"l3_side.main_data_begin: %d \\n\" + \"Resvoir size:             %d \\n\" + \"resv drain (post)         %d \\n\" + \"resv drain (pre)          %d \\n\" + \"header and sideinfo:      %d \\n\" + \"data bits:                %d \\n\" + \"total bits:               %d (remainder: %d) \\n\" + \"bitsperframe:             %d \\n\", 8 * l3_side.main_data_begin, gfc.ResvSize, l3_side.resvDrain_post, l3_side.resvDrain_pre, 8 * gfc.sideinfo_len, bits - l3_side.resvDrain_post - 8 * gfc.sideinfo_len, bits, bits % 8, bitsPerFrame);\n      System.err.println(\"This is a fatal error.  It has several possible causes:\");\n      System.err.println(\"90%%  LAME compiled with buggy version of gcc using advanced optimizations\");\n      System.err.println(\" 9%%  Your system is overclocked\");\n      System.err.println(\" 1%%  bug in LAME encoding library\");\n      gfc.ResvSize = l3_side.main_data_begin * 8;\n    } //;\n\n\n    assert(totbit % 8 == 0);\n\n    if (totbit > 1000000000) {\n      /*\n       * to avoid totbit overflow, (at 8h encoding at 128kbs) lets reset\n       * bit counter\n       */\n      var i;\n\n      for (i = 0; i < LameInternalFlags.MAX_HEADER_BUF; ++i) gfc.header[i].write_timing -= totbit;\n\n      totbit = 0;\n    }\n\n    return 0;\n  };\n  /**\n   * <PRE>\n   * copy data out of the internal MP3 bit buffer into a user supplied\n   *       unsigned char buffer.\n   *\n   *       mp3data=0      indicates data in buffer is an id3tags and VBR tags\n   *       mp3data=1      data is real mp3 frame data.\n   * </PRE>\n   */\n\n\n  this.copy_buffer = function (gfc, buffer, bufferPos, size, mp3data) {\n    var minimum = bufByteIdx + 1;\n    if (minimum <= 0) return 0;\n\n    if (size != 0 && minimum > size) {\n      /* buffer is too small */\n      return -1;\n    }\n\n    System.arraycopy(buf, 0, buffer, bufferPos, minimum);\n    bufByteIdx = -1;\n    bufBitIdx = 0;\n\n    if (mp3data != 0) {\n      var crc = new_int(1);\n      crc[0] = gfc.nMusicCRC;\n      vbr.updateMusicCRC(crc, buffer, bufferPos, minimum);\n      gfc.nMusicCRC = crc[0];\n      /**\n       * sum number of bytes belonging to the mp3 stream this info will be\n       * written into the Xing/LAME header for seeking\n       */\n\n      if (minimum > 0) {\n        gfc.VBR_seek_table.nBytesWritten += minimum;\n      }\n\n      if (gfc.decode_on_the_fly) {\n        /* decode the frame */\n        var pcm_buf = new_float_n([2, 1152]);\n        var mp3_in = minimum;\n        var samples_out = -1;\n        var i;\n        /* re-synthesis to pcm. Repeat until we get a samples_out=0 */\n\n        while (samples_out != 0) {\n          samples_out = mpg.hip_decode1_unclipped(gfc.hip, buffer, bufferPos, mp3_in, pcm_buf[0], pcm_buf[1]);\n          /*\n           * samples_out = 0: need more data to decode samples_out =\n           * -1: error. Lets assume 0 pcm output samples_out = number\n           * of samples output\n           */\n\n          /*\n           * set the lenght of the mp3 input buffer to zero, so that\n           * in the next iteration of the loop we will be querying\n           * mpglib about buffered data\n           */\n\n          mp3_in = 0;\n\n          if (samples_out == -1) {\n            /*\n             * error decoding. Not fatal, but might screw up the\n             * ReplayGain tag. What should we do? Ignore for now\n             */\n            samples_out = 0;\n          }\n\n          if (samples_out > 0) {\n            /* process the PCM data */\n\n            /*\n             * this should not be possible, and indicates we have\n             * overflown the pcm_buf buffer\n             */\n            assert(samples_out <= 1152);\n\n            if (gfc.findPeakSample) {\n              for (i = 0; i < samples_out; i++) {\n                if (pcm_buf[0][i] > gfc.PeakSample) gfc.PeakSample = pcm_buf[0][i];else if (-pcm_buf[0][i] > gfc.PeakSample) gfc.PeakSample = -pcm_buf[0][i];\n              }\n\n              if (gfc.channels_out > 1) for (i = 0; i < samples_out; i++) {\n                if (pcm_buf[1][i] > gfc.PeakSample) gfc.PeakSample = pcm_buf[1][i];else if (-pcm_buf[1][i] > gfc.PeakSample) gfc.PeakSample = -pcm_buf[1][i];\n              }\n            }\n\n            if (gfc.findReplayGain) if (ga.AnalyzeSamples(gfc.rgdata, pcm_buf[0], 0, pcm_buf[1], 0, samples_out, gfc.channels_out) == GainAnalysis.GAIN_ANALYSIS_ERROR) return -6;\n          }\n          /* if (samples_out>0) */\n\n        }\n        /* while (samples_out!=0) */\n\n      }\n      /* if (gfc.decode_on_the_fly) */\n\n    }\n    /* if (mp3data) */\n\n\n    return minimum;\n  };\n\n  this.init_bit_stream_w = function (gfc) {\n    buf = new_byte(Lame.LAME_MAXMP3BUFFER);\n    gfc.h_ptr = gfc.w_ptr = 0;\n    gfc.header[gfc.h_ptr].write_timing = 0;\n    bufByteIdx = -1;\n    bufBitIdx = 0;\n    totbit = 0;\n  }; // From machine.h\n\n}\n\nmodule.exports = BitStream;","map":null,"metadata":{},"sourceType":"script"}