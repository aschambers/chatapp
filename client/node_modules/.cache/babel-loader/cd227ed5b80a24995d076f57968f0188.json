{"ast":null,"code":"/* jshint node: true */\n\n/* global location */\n'use strict';\n\nvar rtc = require('rtc-tools');\n\nvar mbus = require('mbus');\n\nvar detectPlugin = require('rtc-core/plugin');\n\nvar debug = rtc.logger('rtc-quickconnect');\n\nvar extend = require('cog/extend');\n\nvar sdpSupport = require('./lib/sdpsupport');\n/**\n  # rtc-quickconnect\n\n  This is a high level helper module designed to help you get up\n  an running with WebRTC really, really quickly.  By using this module you\n  are trading off some flexibility, so if you need a more flexible\n  configuration you should drill down into lower level components of the\n  [rtc.io](http://www.rtc.io) suite.  In particular you should check out\n  [rtc](https://github.com/rtc-io/rtc).\n\n  ## Example Usage\n\n  In the simplest case you simply call quickconnect with a single string\n  argument which tells quickconnect which server to use for signaling:\n\n  <<< examples/simple.js\n\n  <<< docs/events.md\n\n  <<< docs/examples.md\n\n  ## Regarding Signalling and a Signalling Server\n\n  Signaling is an important part of setting up a WebRTC connection and for\n  our examples we use our own test instance of the\n  [rtc-switchboard](https://github.com/rtc-io/rtc-switchboard). For your\n  testing and development you are more than welcome to use this also, but\n  just be aware that we use this for our testing so it may go up and down\n  a little.  If you need something more stable, why not consider deploying\n  an instance of the switchboard yourself - it's pretty easy :)\n\n  ## Reference\n\n  ```\n  quickconnect(signalhost, opts?) => rtc-sigaller instance (+ helpers)\n  ```\n\n  ### Valid Quick Connect Options\n\n  The options provided to the `rtc-quickconnect` module function influence the\n  behaviour of some of the underlying components used from the rtc.io suite.\n\n  Listed below are some of the commonly used options:\n\n  - `ns` (default: '')\n\n    An optional namespace for your signalling room.  While quickconnect\n    will generate a unique hash for the room, this can be made to be more\n    unique by providing a namespace.  Using a namespace means two demos\n    that have generated the same hash but use a different namespace will be\n    in different rooms.\n\n  - `room` (default: null) _added 0.6_\n\n    Rather than use the internal hash generation\n    (plus optional namespace) for room name generation, simply use this room\n    name instead.  __NOTE:__ Use of the `room` option takes precendence over\n    `ns`.\n\n  - `debug` (default: false)\n\n  Write rtc.io suite debug output to the browser console.\n\n  - `expectedLocalStreams` (default: not specified) _added 3.0_\n\n    By providing a positive integer value for this option will mean that\n    the created quickconnect instance will wait until the specified number of\n    streams have been added to the quickconnect \"template\" before announcing\n    to the signaling server.\n\n  - `manualJoin` (default: `false`)\n\n    Set this value to `true` if you would prefer to call the `join` function\n    to connecting to the signalling server, rather than having that happen\n    automatically as soon as quickconnect is ready to.\n\n  #### Options for Peer Connection Creation\n\n  Options that are passed onto the\n  [rtc.createConnection](https://github.com/rtc-io/rtc#createconnectionopts-constraints)\n  function:\n\n  - `iceServers`\n\n  This provides a list of ice servers that can be used to help negotiate a\n  connection between peers.\n\n  #### Options for P2P negotiation\n\n  Under the hood, quickconnect uses the\n  [rtc/couple](https://github.com/rtc-io/rtc#rtccouple) logic, and the options\n  passed to quickconnect are also passed onto this function.\n\n**/\n\n\nmodule.exports = function (signalhost, opts) {\n  var hash = typeof location != 'undefined' && location.hash.slice(1);\n\n  var signaller = require('rtc-pluggable-signaller')(extend({\n    signaller: signalhost,\n    // use the primus endpoint as a fallback in case we are talking to an\n    // older switchboard instance\n    endpoints: ['/', '/primus']\n  }, opts));\n\n  var getPeerData = require('./lib/getpeerdata')(signaller.peers);\n\n  var generateIceServers = require('rtc-core/genice'); // init configurable vars\n\n\n  var ns = (opts || {}).ns || '';\n  var room = (opts || {}).room;\n  var debugging = (opts || {}).debug;\n  var allowJoin = !(opts || {}).manualJoin;\n  var profile = {};\n  var announced = false; // Schemes allow customisation about how connections are made\n  // In particular, providing schemes allows providing different sets of ICE servers\n  // between peers\n\n  var schemes = require('./lib/schemes')(signaller, opts); // collect the local streams\n\n\n  var localStreams = []; // create the calls map\n\n  var calls = signaller.calls = require('./lib/calls')(signaller, opts); // create the known data channels registry\n\n\n  var channels = {};\n  var pending = {}; // Reconnecting indicates peers that are in the process of reconnecting\n\n  var reconnecting = {}; // save the plugins passed to the signaller\n\n  var plugins = signaller.plugins = (opts || {}).plugins || [];\n  var plugin = detectPlugin(plugins);\n  var pluginReady; // check how many local streams have been expected (default: 0)\n\n  var expectedLocalStreams = parseInt((opts || {}).expectedLocalStreams, 10) || 0;\n  var announceTimer = 0;\n  var updateTimer = 0;\n  var CLOSED_STATES = ['failed', 'closed'];\n\n  function checkReadyToAnnounce() {\n    clearTimeout(announceTimer); // if we have already announced do nothing!\n\n    if (announced) {\n      return;\n    }\n\n    if (!allowJoin) {\n      return;\n    } // if we have a plugin but it's not initialized we aren't ready\n\n\n    if (plugin && !pluginReady) {\n      return;\n    } // if we are waiting for a set number of streams, then wait until we have\n    // the required number\n\n\n    if (expectedLocalStreams && localStreams.length < expectedLocalStreams) {\n      return;\n    } // announce ourselves to our new friend\n\n\n    announceTimer = setTimeout(function () {\n      var data = extend({\n        room: room\n      }, profile); // announce and emit the local announce event\n\n      signaller.announce(data);\n      announced = true;\n    }, 0);\n  }\n\n  function connect(id, connectOpts) {\n    debug('connecting to ' + id);\n    if (!id) return debug('invalid target peer ID');\n\n    if (pending[id]) {\n      return debug('a connection is already pending for ' + id + ', as of ' + (Date.now() - pending[id]) + 'ms ago');\n    }\n\n    connectOpts = connectOpts || {};\n    var scheme = schemes.get(connectOpts.scheme, true);\n    var data = getPeerData(id);\n    var pc;\n    var monitor;\n    var call; // if the room is not a match, abort\n\n    if (data.room !== room) {\n      return debug('mismatching room, expected: ' + room + ', got: ' + (data && data.room));\n    }\n\n    if (data.id !== id) {\n      return debug('mismatching ids, expected: ' + id + ', got: ' + data.id);\n    } // Allow prevention of connections if required\n\n\n    if (scheme && typeof scheme.allowConnection === 'function' && !scheme.allowConnection(id, data)) {\n      signaller('peer:rejected', id, data, scheme);\n      return debug('peer connection was rejected for ' + id);\n    }\n\n    pending[id] = Date.now(); // end any call to this id so we know we are starting fresh\n\n    calls.end(id);\n    signaller('peer:prepare', id, data, scheme);\n\n    function clearPending(msg) {\n      debug('connection for ' + id + ' is no longer pending [' + (msg || 'no reason') + '], connect available again');\n\n      if (pending[id]) {\n        delete pending[id];\n      }\n\n      if (reconnecting[id]) {\n        delete reconnecting[id];\n      }\n    } // Regenerate ICE servers (or use existing cached ICE)\n\n\n    generateIceServers(extend({\n      targetPeer: id\n    }, opts, (scheme || {}).connection), function (err, iceServers) {\n      if (err) {\n        signaller('icegeneration:error', id, scheme && scheme.id, err);\n      } else {\n        signaller('peer:iceservers', id, scheme && scheme.id, iceServers || []);\n      } // Generate the connection options for the provided options and default values\n\n\n      var connectionOptions = extend({\n        sdpSemantics: sdpSupport.detectTargetSemantics(signaller, data)\n      }, opts, {\n        iceServers: iceServers\n      }); // create a peer connection\n      // iceServers that have been created using genice taking precendence\n\n      pc = rtc.createConnection(connectionOptions, (opts || {}).constraints);\n      signaller('peer:connect', id, pc, data); // add this connection to the calls list\n\n      call = calls.create(id, pc, data, connectionOptions); // add the local streams/tracks\n\n      localStreams.forEach(function (stream) {\n        if (pc.addTrack) {\n          stream.getAudioTracks().concat(stream.getVideoTracks()).forEach(track => pc.addTrack(track, stream));\n        } else {\n          pc.addStream(stream);\n        } // Fire the couple event\n\n\n        signaller('peer:localMediaAdded', id, pc, data);\n      }); // add any necessary data channels\n\n      Object.keys(channels).forEach(function (label) {\n        addDataChannelToConnection(pc, id, label);\n      }); // Watch for any datachannel creation from in-band negotiated channels\n\n      pc.ondatachannel = function (evt) {\n        var channel = evt && evt.channel; // if we have no channel, abort\n\n        if (!channel) {\n          return;\n        }\n\n        if (channels[channel.label] !== undefined) {\n          gotPeerChannel(channel, pc, getPeerData(id));\n        }\n      }; // couple the connections\n\n\n      debug('coupling ' + signaller.id + ' to ' + id);\n      monitor = rtc.couple(pc, id, signaller, extend({}, opts, {\n        logger: mbus('pc.' + id, signaller)\n      })); // Apply the monitor to the call\n\n      call.monitor = monitor; // once active, trigger the peer connect event\n\n      monitor.once('connected', function () {\n        clearPending('connected successfully');\n        calls.start(id, pc, data);\n      });\n      monitor.once('closed', function () {\n        clearPending('closed');\n        calls.end(id);\n      });\n      monitor.once('aborted', function () {\n        clearPending('aborted');\n      });\n      monitor.once('failed', function () {\n        clearPending('failed');\n        calls.fail(id);\n      }); // The following states are intermediate states based on the disconnection timer\n\n      monitor.once('failing', calls.failing.bind(null, id));\n      monitor.once('recovered', calls.recovered.bind(null, id)); // Fire the couple event\n\n      signaller('peer:couple', id, pc, data, monitor); // if we are the master connnection, create the offer\n      // NOTE: this only really for the sake of politeness, as rtc couple\n      // implementation handles the slave attempting to create an offer\n\n      if (signaller.isMaster(id)) {\n        monitor.createOffer();\n      }\n\n      signaller('peer:prepared', id);\n    });\n  }\n\n  function getActiveCall(peerId) {\n    var call = calls.get(peerId);\n\n    if (!call) {\n      throw new Error('No active call for peer: ' + peerId);\n    }\n\n    return call;\n  }\n  /**\n    Adds a data channel to a peer connection, if required.\n    The channel will be added to the connection under the following situations:\n    1. This is the master peer in the connection to `targetPeer`\n    2. `opts.negotiated` is true\n   */\n\n\n  function addDataChannelToConnection(pc, targetPeer, label) {\n    if (!pc || !targetPeer || !label) return;\n    var channelId = Object.keys(channels).indexOf(label);\n    if (channelId === -1) return console.warn('Channel ID not found');\n    var channelOpts = channels[label] || {};\n    var negotiated = !!channelOpts.negotiated; // If negotiated, allow auto generation of the channel ID\n\n    if (negotiated) {\n      channelOpts = extend({\n        id: channelId\n      }, channelOpts);\n    } // If not negotiated, we have to be the master in order to create\n\n\n    if (!negotiated && !signaller.isMaster(targetPeer)) return;\n    var data = getPeerData(targetPeer);\n    gotPeerChannel(pc.createDataChannel(label, channelOpts), pc, data);\n  }\n\n  function gotPeerChannel(channel, pc, data) {\n    var channelMonitor;\n    var channelConnectionTimer;\n\n    function channelReady() {\n      var call = calls.get(data.id);\n      var args = [data.id, channel, data, pc]; // decouple the channel.onopen listener\n\n      debug('reporting channel \"' + channel.label + '\" ready, have call: ' + !!call);\n      clearInterval(channelMonitor);\n      clearTimeout(channelConnectionTimer);\n      channel.onopen = null; // save the channel\n\n      if (call) {\n        call.channels.set(channel.label, channel); // Remove the channel from the call on close, and emit the required events\n\n        channel.onclose = function () {\n          debug('channel \"' + channel.label + '\" to ' + data.id + ' has closed');\n          var args = [data.id, channel, channel.label]; // decouple the events\n\n          channel.onopen = null; // Remove the channel entry\n\n          call.channels.remove(channel.label); // emit the plain channel:closed event\n\n          signaller.apply(signaller, ['channel:closed'].concat(args)); // emit the labelled version of the event\n\n          signaller.apply(signaller, ['channel:closed:' + channel.label].concat(args));\n        };\n      } // trigger the %channel.label%:open event\n\n\n      debug('triggering channel:opened events for channel: ' + channel.label); // emit the plain channel:opened event\n\n      signaller.apply(signaller, ['channel:opened'].concat(args)); // emit the channel:opened:%label% eve\n\n      signaller.apply(signaller, ['channel:opened:' + channel.label].concat(args));\n    } // If the channel has failed to create for some reason, recreate the channel\n\n\n    function recreateChannel() {\n      debug('recreating data channel: ' + channel.label); // Clear timers\n\n      clearInterval(channelMonitor);\n      clearTimeout(channelConnectionTimer); // Force the channel to close if it is in an open state\n\n      if (['connecting', 'open'].indexOf(channel.readyState) !== -1) {\n        channel.close();\n      } // Recreate the channel using the cached options\n\n\n      signaller.createDataChannel(channel.label, channels[channel.label]);\n    }\n\n    debug('channel ' + channel.label + ' discovered for peer: ' + data.id);\n\n    if (channel.readyState === 'open') {\n      return channelReady();\n    }\n\n    debug('channel not ready, current state = ' + channel.readyState);\n    channel.onopen = channelReady; // monitor the channel open (don't trust the channel open event just yet)\n\n    channelMonitor = setInterval(function () {\n      debug('checking channel state, current state = ' + channel.readyState + ', connection state ' + pc.iceConnectionState);\n\n      if (channel.readyState === 'open') {\n        channelReady();\n      } // If the underlying connection has failed/closed, or if the ready state of the channel has transitioned to a closure\n      // state, then terminate the monitor\n      else if (CLOSED_STATES.indexOf(pc.iceConnectionState) !== -1 || CLOSED_STATES.indexOf(channel.readyState) !== -1) {\n          debug('connection or channel has terminated, cancelling channel monitor');\n          clearInterval(channelMonitor);\n          clearTimeout(channelConnectionTimer);\n        } // If the connection has connected, but the channel is stuck in the connecting state\n        // start a timer. If this expires, then we will attempt to created the data channel\n        else if (pc.iceConnectionState === 'connected' && channel.readyState === 'connecting' && !channelConnectionTimer) {\n            channelConnectionTimer = setTimeout(function () {\n              if (channel.readyState !== 'connecting') return;\n              var args = [data.id, channel, data, pc]; // emit the plain channel:failed event\n\n              signaller.apply(signaller, ['channel:failed'].concat(args)); // emit the channel:opened:%label% eve\n\n              signaller.apply(signaller, ['channel:failed:' + channel.label].concat(args)); // Recreate the channel\n\n              return recreateChannel();\n            }, (opts || {}).channelTimeout || 2000);\n          }\n    }, 500);\n  }\n\n  function initPlugin() {\n    return plugin && plugin.init(opts, function (err) {\n      if (err) {\n        return console.error('Could not initialize plugin: ', err);\n      }\n\n      pluginReady = true;\n      checkReadyToAnnounce();\n    });\n  }\n\n  function handleLocalAnnounce(data) {\n    // if we send an announce with an updated room then update our local room name\n    if (data && typeof data.room != 'undefined') {\n      room = data.room;\n    }\n  }\n\n  function handlePeerFilter(id, data) {\n    // only connect with the peer if we are ready\n    data.allow = data.allow && localStreams.length >= expectedLocalStreams;\n  }\n\n  function handlePeerUpdate(data) {\n    // Do not allow peer updates if we are not announced\n    if (!announced) return;\n    var id = data && data.id;\n    var activeCall = id && calls.get(id); // if we have received an update for a peer that has no active calls,\n    // and is not currently in the process of setting up a call\n    // then pass this onto the announce handler\n\n    if (id && !activeCall && !pending[id] && !reconnecting[id]) {\n      debug('received peer update from peer ' + id + ', no active calls');\n      signaller('peer:autoreconnect', id);\n      return signaller.reconnectTo(id);\n    }\n  }\n\n  function handlePeerLeave(data) {\n    var id = data && data.id;\n\n    if (id) {\n      delete pending[id];\n      calls.end(id);\n    }\n  }\n\n  function handlePeerClose(id) {\n    if (!announced) return;\n    delete pending[id];\n    debug('call has from ' + signaller.id + ' to ' + id + ' has ended, reannouncing');\n    return signaller.profile();\n  } // if the room is not defined, then generate the room name\n\n\n  if (!room) {\n    // if the hash is not assigned, then create a random hash value\n    if (typeof location != 'undefined' && !hash) {\n      hash = location.hash = '' + Math.pow(2, 53) * Math.random();\n    }\n\n    room = ns + '#' + hash;\n  }\n\n  if (debugging) {\n    rtc.logger.enable.apply(rtc.logger, Array.isArray(debug) ? debugging : ['*']);\n  }\n\n  signaller.on('peer:announce', function (data) {\n    connect(data.id, {\n      scheme: data.scheme\n    });\n  });\n  signaller.on('peer:update', handlePeerUpdate);\n  signaller.on('message:reconnect', function (data, sender, message) {\n    debug('received reconnect message'); // Sender arguments are always last\n\n    if (!message) {\n      message = sender;\n      sender = data;\n      data = undefined;\n    }\n\n    if (!sender.id) return console.warn('Could not reconnect, no sender ID'); // Abort any current calls\n\n    calls.abort(sender.id);\n    delete reconnecting[sender.id];\n    signaller('peer:reconnecting', sender.id, data || {}); // Reapply sender information in case aborts caused it to be removed\n\n    signaller.peers.set(sender.id, sender);\n    connect(sender.id, data || {}); // If this is the master, echo the reconnection back to the peer instructing that\n    // the reconnection has been accepted and to connect\n\n    var isMaster = signaller.isMaster(sender.id);\n\n    if (isMaster) {\n      signaller.to(sender.id).send('/reconnect', data || {});\n    }\n  });\n  /**\n    ### Quickconnect Broadcast and Data Channel Helper Functions\n     The following are functions that are patched into the `rtc-signaller`\n    instance that make working with and creating functional WebRTC applications\n    a lot simpler.\n   **/\n\n  /**\n    #### addStream\n     ```\n    addStream(stream:MediaStream) => qc\n    ```\n     Add the stream to active calls and also save the stream so that it\n    can be added to future calls.\n   **/\n\n  signaller.broadcast = signaller.addStream = function (stream) {\n    localStreams.push(stream); // if we have any active calls, then add the stream\n\n    calls.keys().forEach(function (id) {\n      // get call obj\n      var call = calls.get(id); // check addTrack or addStream\n\n      if (call.pc.addTrack) {\n        // Firefox + Chrome 64 and above\n        stream.getAudioTracks().concat(stream.getVideoTracks()).forEach(function (track) {\n          debug('addTrack trackId:', track.id, ',streamId:', stream.id);\n          call.pc.addTrack(track, stream);\n        });\n      } else {\n        // Upto chrome 63\n        call.pc.addStream(stream);\n      }\n\n      signaller('peer:localMediaAdded', id, call.pc);\n    });\n    checkReadyToAnnounce();\n    return signaller;\n  };\n  /**\n    #### addTrack\n     The `addTrack` function terminates do the pure WebRTC addTrack logic.\n  **/\n\n\n  signaller.addTrack = function (track, stream) {\n    if (localStreams.indexOf(stream) == -1) {\n      localStreams.push(stream);\n    } // if we have any active calls, then add the stream\n\n\n    calls.values().forEach(function (call) {\n      call.pc.addTrack(track, stream);\n    });\n    checkReadyToAnnounce();\n    return signaller;\n  };\n  /**\n    #### replaceTrack\n     The `replaceTrack` function call web WebRTC API for replaceTrack (sender)\n    replaceTrack(newTrack, oldTrackId)\n  **/\n\n\n  signaller.replaceTrack = function (track, trackId) {\n    // all tracks\n    var allTracks = [];\n    localStreams.forEach(s => {\n      allTracks = allTracks.concat(s.getTracks());\n    }); // find existing track\n\n    var removingTrack = allTracks.find(t => t.id === trackId);\n\n    if (removingTrack) {\n      var replacingStream = localStreams.find(s => s.getTracks().find(t => t === removingTrack)); // removing \n\n      replacingStream.removeTrack(removingTrack); // add new track\n\n      replacingStream.addTrack(track);\n    } else {\n      console.error('cannot find the track to be replaced:', trackId, track);\n      return;\n    } // replace pc track\n\n\n    calls.values().forEach(function (call) {\n      var sender = call.pc.getSenders().find(function (s) {\n        return s.track.id === removingTrack.id;\n      });\n\n      if (sender) {\n        // found the sender, then replace the track\n        sender.replaceTrack(track);\n      } else {\n        console.error('cannot find sender:', trackId, track);\n      }\n    });\n    return signaller;\n  };\n  /**\n    #### endCall\n     The `endCall` function terminates the active call with the given ID.\n    If a call with the call ID does not exist it will do nothing.\n  **/\n\n\n  signaller.endCall = calls.end;\n  /**\n    #### endCalls()\n     The `endCalls` function terminates all the active calls that have been\n    created in this quickconnect instance.  Calling `endCalls` does not\n    kill the connection with the signalling server.\n   **/\n\n  signaller.endCalls = function () {\n    calls.keys().forEach(calls.end);\n  };\n  /**\n    #### close()\n     The `close` function provides a convenient way of closing all associated\n    peer connections.  This function simply uses the `endCalls` function and\n    the underlying `leave` function of the signaller to do a \"full cleanup\"\n    of all connections.\n  **/\n\n\n  signaller.close = function () {\n    // We are no longer announced\n    announced = false; // Remove any pending update annoucements\n\n    if (updateTimer) clearTimeout(updateTimer); // Cleanup\n\n    signaller.endCalls();\n    signaller.leave();\n  };\n  /**\n    #### createDataChannel(label, config)\n     Request that a data channel with the specified `label` is created on\n    the peer connection.  When the data channel is open and available, an\n    event will be triggered using the label of the data channel.\n     For example, if a new data channel was requested using the following\n    call:\n     ```js\n    var qc = quickconnect('https://switchboard.rtc.io/').createDataChannel('test');\n    ```\n     Then when the data channel is ready for use, a `test:open` event would\n    be emitted by `qc`.\n   **/\n\n\n  signaller.createDataChannel = function (label, opts) {\n    // save the data channel opts in the local channels dictionary\n    channels[label] = opts || null; // create a channel on all existing calls\n\n    calls.keys().forEach(function (peerId) {\n      var call = calls.get(peerId);\n      var dc; // if we are the master connection, create the data channel\n\n      if (call && call.pc) {\n        var existingChannel = call.channels.get(label);\n\n        if (existingChannel && existingChannel.readyState !== 'closed') {\n          return debug('Attempted to create data channel \"' + label + '\" for a call to ' + peerId + ' but an open channel already exists');\n        } // Add the datachannel (if required)\n\n\n        addDataChannelToConnection(call.pc, peerId, label);\n      }\n    });\n    return signaller;\n  };\n  /**\n    #### join()\n     The `join` function is used when `manualJoin` is set to true when creating\n    a quickconnect instance.  Call the `join` function once you are ready to\n    join the signalling server and initiate connections with other people.\n   **/\n\n\n  signaller.join = function () {\n    allowJoin = true;\n    checkReadyToAnnounce();\n  };\n  /**\n    #### `get(name)`\n     The `get` function returns the property value for the specified property name.\n  **/\n\n\n  signaller.get = function (name) {\n    return profile[name];\n  };\n  /**\n    #### `getLocalStreams()`\n     Return a copy of the local streams that have currently been configured\n  **/\n\n\n  signaller.getLocalStreams = function () {\n    return [].concat(localStreams);\n  };\n  /**\n    #### reactive()\n     Flag that this session will be a reactive connection.\n   **/\n\n\n  signaller.reactive = function () {\n    // add the reactive flag\n    opts = opts || {};\n    opts.reactive = true; // chain\n\n    return signaller;\n  };\n  /**\n    #### registerScheme\n     Registers a connection scheme for use, and check it for validity\n   **/\n\n\n  signaller.registerScheme = schemes.add;\n  /**\n   #### getSche,e\n    Returns the connection sheme given by ID\n  **/\n\n  signaller.getScheme = schemes.get;\n  /**\n    #### removeStream\n     ```\n    removeStream(stream:MediaStream)\n    ```\n     Remove the specified stream from both the local streams that are to\n    be connected to new peers, and also from any active calls.\n   **/\n\n  signaller.removeStream = function (stream) {\n    var localIndex = localStreams.indexOf(stream); // remove the stream from any active calls\n\n    calls.values().forEach(function (call) {\n      // If `RTCPeerConnection.removeTrack` exists (Firefox), then use that\n      // as `RTCPeerConnection.removeStream` is not supported\n      if (call.pc.removeTrack) {\n        stream.getTracks().forEach(function (track) {\n          try {\n            call.pc.removeTrack(call.pc.getSenders().find(function (sender) {\n              return sender.track == track;\n            }));\n          } catch (e) {\n            // When using LocalMediaStreamTracks, this seems to throw an error due to\n            // LocalMediaStreamTrack not implementing the RTCRtpSender inteface.\n            // Without `removeStream` and with `removeTrack` not allowing for local stream\n            // removal, this needs some thought when dealing with FF renegotiation\n            console.error('Error removing media track', e);\n          }\n        });\n      } // Otherwise we just use `RTCPeerConnection.removeStream`\n      else {\n          try {\n            call.pc.removeStream(stream);\n          } catch (e) {\n            console.error('Failed to remove media stream', e);\n          }\n        }\n    }); // remove the stream from the localStreams array\n\n    if (localIndex >= 0) {\n      localStreams.splice(localIndex, 1);\n    }\n\n    return signaller;\n  };\n  /**\n    #### requestChannel\n     ```\n    requestChannel(targetId, label, callback)\n    ```\n     This is a function that can be used to respond to remote peers supplying\n    a data channel as part of their configuration.  As per the `receiveStream`\n    function this function will either fire the callback immediately if the\n    channel is already available, or once the channel has been discovered on\n    the call.\n   **/\n\n\n  signaller.requestChannel = function (targetId, label, callback) {\n    var call = getActiveCall(targetId);\n    var channel = call && call.channels.get(label); // if we have then channel trigger the callback immediately\n\n    if (channel) {\n      callback(null, channel);\n      return signaller;\n    } // if not, wait for it\n\n\n    signaller.once('channel:opened:' + label, function (id, dc) {\n      callback(null, dc);\n    });\n    return signaller;\n  };\n  /**\n    #### requestStream\n     ```\n    requestStream(targetId, idx, callback)\n    ```\n     Used to request a remote stream from a quickconnect instance. If the\n    stream is already available in the calls remote streams, then the callback\n    will be triggered immediately, otherwise this function will monitor\n    `stream:added` events and wait for a match.\n     In the case that an unknown target is requested, then an exception will\n    be thrown.\n  **/\n\n\n  signaller.requestStream = function (targetId, idx, callback) {\n    var call = getActiveCall(targetId);\n    var stream;\n\n    function waitForStream(peerId) {\n      if (peerId !== targetId) {\n        return;\n      } // get the stream\n\n\n      stream = call.pc.getRemoteStreams()[idx]; // if we have the stream, then remove the listener and trigger the cb\n\n      if (stream) {\n        signaller.removeListener('stream:added', waitForStream);\n        callback(null, stream);\n      }\n    } // look for the stream in the remote streams of the call\n\n\n    stream = call.pc.getRemoteStreams()[idx]; // if we found the stream then trigger the callback\n\n    if (stream) {\n      callback(null, stream);\n      return signaller;\n    } // otherwise wait for the stream\n\n\n    signaller.on('stream:added', waitForStream);\n    return signaller;\n  };\n  /**\n    #### profile(data)\n     Update the profile data with the attached information, so when\n    the signaller announces it includes this data in addition to any\n    room and id information.\n   **/\n\n\n  signaller.profile = function (data) {\n    extend(profile, data || {}); // if we have already announced, then reannounce our profile to provide\n    // others a `peer:update` event\n\n    if (announced) {\n      clearTimeout(updateTimer);\n      updateTimer = setTimeout(function () {\n        // Check that our announced status hasn't changed\n        if (!announced) return;\n        debug('[' + signaller.id + '] reannouncing');\n        signaller.announce(profile);\n      }, (opts || {}).updateDelay || 1000);\n    }\n\n    return signaller;\n  };\n  /**\n    #### waitForCall\n     ```\n    waitForCall(targetId, callback)\n    ```\n     Wait for a call from the specified targetId.  If the call is already\n    active the callback will be fired immediately, otherwise we will wait\n    for a `call:started` event that matches the requested `targetId`\n   **/\n\n\n  signaller.waitForCall = function (targetId, callback) {\n    var call = calls.get(targetId);\n\n    if (call && call.active) {\n      callback(null, call.pc);\n      return signaller;\n    }\n\n    signaller.on('call:started', function handleNewCall(id) {\n      if (id === targetId) {\n        signaller.removeListener('call:started', handleNewCall);\n        callback(null, calls.get(id).pc);\n      }\n    });\n  };\n  /**\n    Attempts to reconnect to a certain target peer. It will close any existing\n    call to that peer, and restart the connection process\n   **/\n\n\n  signaller.reconnectTo = function (id, reconnectOpts) {\n    if (!id) return;\n    signaller.to(id).send('/reconnect', reconnectOpts); // If this is the master, connect, otherwise the master will send a /reconnect\n    // message back instructing the connection to start\n\n    var isMaster = signaller.isMaster(id);\n\n    if (isMaster) {\n      // Abort any current calls\n      signaller('log', 'aborting call'); // Preserve peer data\n\n      var peerData = signaller.peers.get(id);\n\n      try {\n        calls.abort(id);\n      } catch (e) {\n        signaller('log', e.message);\n      }\n\n      signaller('log', 'call aborted');\n      signaller('peer:reconnecting', id, reconnectOpts || {}); // Reapply peer data in case it was deleted during abort\n\n      signaller.peers.set(id, peerData);\n      return connect(id, reconnectOpts);\n    } // Flag that we are waiting for the master to indicate the reconnection is a go\n    else {\n        reconnecting[id] = Date.now();\n      }\n  }; // if we have an expected number of local streams, then use a filter to\n  // check if we should respond\n\n\n  if (expectedLocalStreams) {\n    signaller.on('peer:filter', handlePeerFilter);\n  } // respond to local announce messages\n\n\n  signaller.on('local:announce', handleLocalAnnounce); // handle ping messages\n\n  signaller.on('message:ping', calls.ping); // Handle when a remote peer leaves that the appropriate closing occurs this\n  // side as well\n\n  signaller.on('message:leave', handlePeerLeave); // When a call:ended, we reannounce ourselves. This offers a degree of failure handling\n  // as if a call has dropped unexpectedly (ie. failure/unable to connect) the other peers\n  // connected to the signaller will attempt to reconnect\n\n  signaller.on('call:ended', handlePeerClose); // if we plugin is active, then initialize it\n\n  if (plugin) {\n    initPlugin();\n  } else {\n    // Test if we are ready to announce\n    process.nextTick(function () {\n      checkReadyToAnnounce();\n    });\n  } // pass the signaller on\n\n\n  return signaller;\n};","map":null,"metadata":{},"sourceType":"script"}