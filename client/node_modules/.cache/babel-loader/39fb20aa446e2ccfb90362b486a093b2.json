{"ast":null,"code":"var compareVersions = require('compare-versions'); // Plan B semantic\n\n\nvar PLAN_B = 'plan-b';\nvar UNIFIED_PLAN = 'unified-plan';\nvar DEFAULT_SEMANTIC = PLAN_B; // Indivates the \n\nvar BROWSER_SUPPORT = {\n  'chrome': {\n    '71.0.0.0': [UNIFIED_PLAN, PLAN_B],\n    // Prefer unified plan\n    '70.0.0.0': [PLAN_B, UNIFIED_PLAN],\n    // Prefer plan b\n    '30.0.0.0': [PLAN_B]\n  },\n  'firefox': {\n    '22.0': [UNIFIED_PLAN]\n  },\n  'ios': {\n    '12.1.1.0': [UNIFIED_PLAN, PLAN_B],\n    // 12.1.1 problem 12.3 iphone\n    '12.0.0.0': [PLAN_B, UNIFIED_PLAN],\n    // 12.xxx\n    '11.0': [PLAN_B]\n  },\n  'safari': {\n    '12.1.1.0': [UNIFIED_PLAN, PLAN_B],\n    '12.0.0.0': [PLAN_B, UNIFIED_PLAN],\n    // currently, worked one\n    '11.0': [PLAN_B]\n  }\n};\nvar DEFAULT_SUPPORT = [DEFAULT_SEMANTIC];\n/**\n * getSupportedSemantics\n * Returns which SDP semantics are supported by the given peer attributes\n */\n\nfunction getSupportedSemantics(data) {\n  if (!data || !data.browser || !data.browserVersion) return DEFAULT_SUPPORT;\n  var versions = BROWSER_SUPPORT[data.browser];\n  if (!versions) return DEFAULT_SUPPORT;\n  return Object.keys(versions).filter(function (v) {\n    return compareVersions(data.browserVersion, v) >= 0;\n  }).map(function (v) {\n    return versions[v];\n  })[0] || DEFAULT_SUPPORT;\n}\n/**\n * detectTargetSemantics\n * Attempts to determine the best SDP semantic to achieve a connection between this peer,\n * and the peer it is connecting to\n */\n\n\nexports.detectTargetSemantics = function (signaller, peer) {\n  if (!peer || !signaller || !signaller.attributes) return DEFAULT_SEMANTIC; // Have the master be the source, so that we can correctly identify a preferred semantic\n  // in the event of different prioritization (using different semantics would be a problem)\n\n  var isMaster = signaller.isMaster(peer.id);\n  var source = getSupportedSemantics(isMaster ? signaller.attributes : peer);\n  var target = getSupportedSemantics(isMaster ? peer : signaller.attributes);\n  return source.filter(function (semantic) {\n    return target.indexOf(semantic) !== -1;\n  })[0] || DEFAULT_SEMANTIC;\n};","map":null,"metadata":{},"sourceType":"script"}