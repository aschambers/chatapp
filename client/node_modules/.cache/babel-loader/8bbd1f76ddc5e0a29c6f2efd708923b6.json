{"ast":null,"code":"var reDelim = /[\\.\\:]/;\n/**\n  # mbus\n\n  If Node's EventEmitter and Eve were to have a child, it might look something like this.\n  No wildcard support at this stage though...\n\n  ## Example Usage\n\n  <<< docs/usage.md\n\n  ## Reference\n\n  ### `mbus(namespace?, parent?, scope?)`\n\n  Create a new message bus with `namespace` inheriting from the `parent`\n  mbus instance.  If events from this message bus should be triggered with\n  a specific `this` scope, then specify it using the `scope` argument.\n\n**/\n\nvar createBus = module.exports = function (namespace, parent, scope) {\n  var registry = {};\n  var feeds = [];\n\n  function bus(name) {\n    var args = [].slice.call(arguments, 1);\n    var delimited = normalize(name);\n    var handlers = registry[delimited] || [];\n    var results; // send through the feeds\n\n    feeds.forEach(function (feed) {\n      feed({\n        name: delimited,\n        args: args\n      });\n    }); // run the registered handlers\n\n    results = [].concat(handlers).map(function (handler) {\n      return handler.apply(scope || this, args);\n    }); // run the parent handlers\n\n    if (bus.parent) {\n      results = results.concat(bus.parent.apply(scope || this, [(namespace ? namespace + '.' : '') + delimited].concat(args)));\n    }\n\n    return results;\n  }\n  /**\n    ### `mbus#clear()`\n     Reset the handler registry, which essential deregisters all event listeners.\n     _Alias:_ `removeAllListeners`\n  **/\n\n\n  function clear(name) {\n    // if we have a name, reset handlers for that handler\n    if (name) {\n      delete registry[normalize(name)];\n    } // otherwise, reset the entire handler registry\n    else {\n        registry = {};\n      }\n  }\n  /**\n    ### `mbus#feed(handler)`\n     Attach a handler function that will see all events that are sent through\n    this bus in an \"object stream\" format that matches the following format:\n     ```\n    { name: 'event.name', args: [ 'event', 'args' ] }\n    ```\n     The feed function returns a function that can be called to stop the feed\n    sending data.\n   **/\n\n\n  function feed(handler) {\n    function stop() {\n      feeds.splice(feeds.indexOf(handler), 1);\n    }\n\n    feeds.push(handler);\n    return stop;\n  }\n\n  function normalize(name) {\n    return (Array.isArray(name) ? name : name.split(reDelim)).join('.');\n  }\n  /**\n    ### `mbus#off(name, handler)`\n     Deregister an event handler.\n  **/\n\n\n  function off(name, handler) {\n    var handlers = registry[normalize(name)] || [];\n    var idx = handlers ? handlers.indexOf(handler._actual || handler) : -1;\n\n    if (idx >= 0) {\n      handlers.splice(idx, 1);\n    }\n  }\n  /**\n    ### `mbus#on(name, handler)`\n     Register an event handler for the event `name`.\n   **/\n\n\n  function on(name, handler) {\n    var handlers;\n    name = normalize(name);\n    handlers = registry[name];\n\n    if (handlers) {\n      handlers.push(handler);\n    } else {\n      registry[name] = [handler];\n    }\n\n    return bus;\n  }\n  /**\n    ### `mbus#once(name, handler)`\n     Register an event handler for the event `name` that will only\n    trigger once (i.e. the handler will be deregistered immediately after\n    being triggered the first time).\n   **/\n\n\n  function once(name, handler) {\n    function handleEvent() {\n      var result = handler.apply(this, arguments);\n      bus.off(name, handleEvent);\n      return result;\n    }\n\n    handler._actual = handleEvent;\n    return on(name, handleEvent);\n  }\n\n  if (typeof namespace == 'function') {\n    parent = namespace;\n    namespace = '';\n  }\n\n  namespace = normalize(namespace || '');\n  bus.clear = bus.removeAllListeners = clear;\n  bus.feed = feed;\n  bus.on = bus.addListener = on;\n  bus.once = once;\n  bus.off = bus.removeListener = off;\n  bus.parent = parent || namespace && createBus();\n  return bus;\n};","map":null,"metadata":{},"sourceType":"script"}