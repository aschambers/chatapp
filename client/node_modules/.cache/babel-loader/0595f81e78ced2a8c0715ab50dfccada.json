{"ast":null,"code":"/*\n *      quantize_pvt source file\n *\n *      Copyright (c) 1999-2002 Takehiro Tominaga\n *      Copyright (c) 2000-2002 Robert Hegemann\n *      Copyright (c) 2001 Naoki Shibata\n *      Copyright (c) 2002-2005 Gabriel Bouvigne\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: QuantizePVT.java,v 1.24 2011/05/24 20:48:06 kenchis Exp $ */\nvar ScaleFac = require('./ScaleFac.js');\n\nvar common = require('./common.js');\n\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar Encoder = require('./Encoder.js');\n\nvar MeanBits = require('./MeanBits.js');\n\nvar LameInternalFlags = require('./LameInternalFlags.js');\n\nQuantizePVT.Q_MAX = 256 + 1;\nQuantizePVT.Q_MAX2 = 116;\nQuantizePVT.LARGE_BITS = 100000;\nQuantizePVT.IXMAX_VAL = 8206;\n\nfunction QuantizePVT() {\n  var tak = null;\n  var rv = null;\n  var psy = null;\n\n  this.setModules = function (_tk, _rv, _psy) {\n    tak = _tk;\n    rv = _rv;\n    psy = _psy;\n  };\n\n  function POW20(x) {\n    assert(0 <= x + QuantizePVT.Q_MAX2 && x < QuantizePVT.Q_MAX);\n    return pow20[x + QuantizePVT.Q_MAX2];\n  }\n\n  this.IPOW20 = function (x) {\n    assert(0 <= x && x < QuantizePVT.Q_MAX);\n    return ipow20[x];\n  };\n  /**\n   * smallest such that 1.0+DBL_EPSILON != 1.0\n   */\n\n\n  var DBL_EPSILON = 2.2204460492503131e-016;\n  /**\n   * ix always <= 8191+15. see count_bits()\n   */\n\n  var IXMAX_VAL = QuantizePVT.IXMAX_VAL;\n  var PRECALC_SIZE = IXMAX_VAL + 2;\n  var Q_MAX = QuantizePVT.Q_MAX;\n  /**\n   * <CODE>\n   * minimum possible number of\n   * -cod_info.global_gain + ((scalefac[] + (cod_info.preflag ? pretab[sfb] : 0))\n   * << (cod_info.scalefac_scale + 1)) + cod_info.subblock_gain[cod_info.window[sfb]] * 8;\n   *\n   * for long block, 0+((15+3)<<2) = 18*4 = 72\n   * for short block, 0+(15<<2)+7*8 = 15*4+56 = 116\n   * </CODE>\n   */\n\n  var Q_MAX2 = QuantizePVT.Q_MAX2;\n  var LARGE_BITS = QuantizePVT.LARGE_BITS;\n  /**\n   * Assuming dynamic range=96dB, this value should be 92\n   */\n\n  var NSATHSCALE = 100;\n  /**\n   * The following table is used to implement the scalefactor partitioning for\n   * MPEG2 as described in section 2.4.3.2 of the IS. The indexing corresponds\n   * to the way the tables are presented in the IS:\n   *\n   * [table_number][row_in_table][column of nr_of_sfb]\n   */\n\n  this.nr_of_sfb_block = [[[6, 5, 5, 5], [9, 9, 9, 9], [6, 9, 9, 9]], [[6, 5, 7, 3], [9, 9, 12, 6], [6, 9, 12, 6]], [[11, 10, 0, 0], [18, 18, 0, 0], [15, 18, 0, 0]], [[7, 7, 7, 0], [12, 12, 12, 0], [6, 15, 12, 0]], [[6, 6, 6, 3], [12, 9, 9, 6], [6, 12, 9, 6]], [[8, 8, 5, 0], [15, 12, 9, 0], [6, 18, 9, 0]]];\n  /**\n   * Table B.6: layer3 preemphasis\n   */\n\n  var pretab = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 3, 3, 3, 2, 0];\n  this.pretab = pretab;\n  /**\n   * Here are MPEG1 Table B.8 and MPEG2 Table B.1 -- Layer III scalefactor\n   * bands. <BR>\n   * Index into this using a method such as:<BR>\n   * idx = fr_ps.header.sampling_frequency + (fr_ps.header.version * 3)\n   */\n\n  this.sfBandIndex = [// Table B.2.b: 22.05 kHz\n  new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576], [0, 4, 8, 12, 18, 24, 32, 42, 56, 74, 100, 132, 174, 192], [0, 0, 0, 0, 0, 0, 0] //  sfb21 pseudo sub bands\n  , [0, 0, 0, 0, 0, 0, 0] //  sfb12 pseudo sub bands\n  ),\n  /* Table B.2.c: 24 kHz */\n\n  /* docs: 332. mpg123(broken): 330 */\n  new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 114, 136, 162, 194, 232, 278, 332, 394, 464, 540, 576], [0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 136, 180, 192], [0, 0, 0, 0, 0, 0, 0]\n  /*  sfb21 pseudo sub bands */\n  , [0, 0, 0, 0, 0, 0, 0]\n  /*  sfb12 pseudo sub bands */\n  ),\n  /* Table B.2.a: 16 kHz */\n  new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576], [0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 134, 174, 192], [0, 0, 0, 0, 0, 0, 0]\n  /*  sfb21 pseudo sub bands */\n  , [0, 0, 0, 0, 0, 0, 0]\n  /*  sfb12 pseudo sub bands */\n  ),\n  /* Table B.8.b: 44.1 kHz */\n  new ScaleFac([0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 52, 62, 74, 90, 110, 134, 162, 196, 238, 288, 342, 418, 576], [0, 4, 8, 12, 16, 22, 30, 40, 52, 66, 84, 106, 136, 192], [0, 0, 0, 0, 0, 0, 0]\n  /*  sfb21 pseudo sub bands */\n  , [0, 0, 0, 0, 0, 0, 0]\n  /*  sfb12 pseudo sub bands */\n  ),\n  /* Table B.8.c: 48 kHz */\n  new ScaleFac([0, 4, 8, 12, 16, 20, 24, 30, 36, 42, 50, 60, 72, 88, 106, 128, 156, 190, 230, 276, 330, 384, 576], [0, 4, 8, 12, 16, 22, 28, 38, 50, 64, 80, 100, 126, 192], [0, 0, 0, 0, 0, 0, 0]\n  /*  sfb21 pseudo sub bands */\n  , [0, 0, 0, 0, 0, 0, 0]\n  /*  sfb12 pseudo sub bands */\n  ),\n  /* Table B.8.a: 32 kHz */\n  new ScaleFac([0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 54, 66, 82, 102, 126, 156, 194, 240, 296, 364, 448, 550, 576], [0, 4, 8, 12, 16, 22, 30, 42, 58, 78, 104, 138, 180, 192], [0, 0, 0, 0, 0, 0, 0]\n  /*  sfb21 pseudo sub bands */\n  , [0, 0, 0, 0, 0, 0, 0]\n  /*  sfb12 pseudo sub bands */\n  ),\n  /* MPEG-2.5 11.025 kHz */\n  new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576], [0 / 3, 12 / 3, 24 / 3, 36 / 3, 54 / 3, 78 / 3, 108 / 3, 144 / 3, 186 / 3, 240 / 3, 312 / 3, 402 / 3, 522 / 3, 576 / 3], [0, 0, 0, 0, 0, 0, 0]\n  /*  sfb21 pseudo sub bands */\n  , [0, 0, 0, 0, 0, 0, 0]\n  /*  sfb12 pseudo sub bands */\n  ),\n  /* MPEG-2.5 12 kHz */\n  new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576], [0 / 3, 12 / 3, 24 / 3, 36 / 3, 54 / 3, 78 / 3, 108 / 3, 144 / 3, 186 / 3, 240 / 3, 312 / 3, 402 / 3, 522 / 3, 576 / 3], [0, 0, 0, 0, 0, 0, 0]\n  /*  sfb21 pseudo sub bands */\n  , [0, 0, 0, 0, 0, 0, 0]\n  /*  sfb12 pseudo sub bands */\n  ),\n  /* MPEG-2.5 8 kHz */\n  new ScaleFac([0, 12, 24, 36, 48, 60, 72, 88, 108, 132, 160, 192, 232, 280, 336, 400, 476, 566, 568, 570, 572, 574, 576], [0 / 3, 24 / 3, 48 / 3, 72 / 3, 108 / 3, 156 / 3, 216 / 3, 288 / 3, 372 / 3, 480 / 3, 486 / 3, 492 / 3, 498 / 3, 576 / 3], [0, 0, 0, 0, 0, 0, 0]\n  /*  sfb21 pseudo sub bands */\n  , [0, 0, 0, 0, 0, 0, 0]\n  /*  sfb12 pseudo sub bands */\n  )];\n  var pow20 = new_float(Q_MAX + Q_MAX2 + 1);\n  var ipow20 = new_float(Q_MAX);\n  var pow43 = new_float(PRECALC_SIZE);\n  var adj43 = new_float(PRECALC_SIZE);\n  this.adj43 = adj43;\n  /**\n   * <PRE>\n   * compute the ATH for each scalefactor band cd range: 0..96db\n   *\n   * Input: 3.3kHz signal 32767 amplitude (3.3kHz is where ATH is smallest =\n   * -5db) longblocks: sfb=12 en0/bw=-11db max_en0 = 1.3db shortblocks: sfb=5\n   * -9db 0db\n   *\n   * Input: 1 1 1 1 1 1 1 -1 -1 -1 -1 -1 -1 -1 (repeated) longblocks: amp=1\n   * sfb=12 en0/bw=-103 db max_en0 = -92db amp=32767 sfb=12 -12 db -1.4db\n   *\n   * Input: 1 1 1 1 1 1 1 -1 -1 -1 -1 -1 -1 -1 (repeated) shortblocks: amp=1\n   * sfb=5 en0/bw= -99 -86 amp=32767 sfb=5 -9 db 4db\n   *\n   *\n   * MAX energy of largest wave at 3.3kHz = 1db AVE energy of largest wave at\n   * 3.3kHz = -11db Let's take AVE: -11db = maximum signal in sfb=12. Dynamic\n   * range of CD: 96db. Therefor energy of smallest audible wave in sfb=12 =\n   * -11 - 96 = -107db = ATH at 3.3kHz.\n   *\n   * ATH formula for this wave: -5db. To adjust to LAME scaling, we need ATH =\n   * ATH_formula - 103 (db) ATH = ATH * 2.5e-10 (ener)\n   * </PRE>\n   */\n\n  function ATHmdct(gfp, f) {\n    var ath = psy.ATHformula(f, gfp);\n    ath -= NSATHSCALE;\n    /* modify the MDCT scaling for the ATH and convert to energy */\n\n    ath = Math.pow(10.0, ath / 10.0 + gfp.ATHlower);\n    return ath;\n  }\n\n  function compute_ath(gfp) {\n    var ATH_l = gfp.internal_flags.ATH.l;\n    var ATH_psfb21 = gfp.internal_flags.ATH.psfb21;\n    var ATH_s = gfp.internal_flags.ATH.s;\n    var ATH_psfb12 = gfp.internal_flags.ATH.psfb12;\n    var gfc = gfp.internal_flags;\n    var samp_freq = gfp.out_samplerate;\n\n    for (var sfb = 0; sfb < Encoder.SBMAX_l; sfb++) {\n      var start = gfc.scalefac_band.l[sfb];\n      var end = gfc.scalefac_band.l[sfb + 1];\n      ATH_l[sfb] = Float.MAX_VALUE;\n\n      for (var i = start; i < end; i++) {\n        var freq = i * samp_freq / (2 * 576);\n        var ATH_f = ATHmdct(gfp, freq);\n        /* freq in kHz */\n\n        ATH_l[sfb] = Math.min(ATH_l[sfb], ATH_f);\n      }\n    }\n\n    for (var sfb = 0; sfb < Encoder.PSFB21; sfb++) {\n      var start = gfc.scalefac_band.psfb21[sfb];\n      var end = gfc.scalefac_band.psfb21[sfb + 1];\n      ATH_psfb21[sfb] = Float.MAX_VALUE;\n\n      for (var i = start; i < end; i++) {\n        var freq = i * samp_freq / (2 * 576);\n        var ATH_f = ATHmdct(gfp, freq);\n        /* freq in kHz */\n\n        ATH_psfb21[sfb] = Math.min(ATH_psfb21[sfb], ATH_f);\n      }\n    }\n\n    for (var sfb = 0; sfb < Encoder.SBMAX_s; sfb++) {\n      var start = gfc.scalefac_band.s[sfb];\n      var end = gfc.scalefac_band.s[sfb + 1];\n      ATH_s[sfb] = Float.MAX_VALUE;\n\n      for (var i = start; i < end; i++) {\n        var freq = i * samp_freq / (2 * 192);\n        var ATH_f = ATHmdct(gfp, freq);\n        /* freq in kHz */\n\n        ATH_s[sfb] = Math.min(ATH_s[sfb], ATH_f);\n      }\n\n      ATH_s[sfb] *= gfc.scalefac_band.s[sfb + 1] - gfc.scalefac_band.s[sfb];\n    }\n\n    for (var sfb = 0; sfb < Encoder.PSFB12; sfb++) {\n      var start = gfc.scalefac_band.psfb12[sfb];\n      var end = gfc.scalefac_band.psfb12[sfb + 1];\n      ATH_psfb12[sfb] = Float.MAX_VALUE;\n\n      for (var i = start; i < end; i++) {\n        var freq = i * samp_freq / (2 * 192);\n        var ATH_f = ATHmdct(gfp, freq);\n        /* freq in kHz */\n\n        ATH_psfb12[sfb] = Math.min(ATH_psfb12[sfb], ATH_f);\n      }\n      /* not sure about the following */\n\n\n      ATH_psfb12[sfb] *= gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12];\n    }\n    /*\n     * no-ATH mode: reduce ATH to -200 dB\n     */\n\n\n    if (gfp.noATH) {\n      for (var sfb = 0; sfb < Encoder.SBMAX_l; sfb++) {\n        ATH_l[sfb] = 1E-20;\n      }\n\n      for (var sfb = 0; sfb < Encoder.PSFB21; sfb++) {\n        ATH_psfb21[sfb] = 1E-20;\n      }\n\n      for (var sfb = 0; sfb < Encoder.SBMAX_s; sfb++) {\n        ATH_s[sfb] = 1E-20;\n      }\n\n      for (var sfb = 0; sfb < Encoder.PSFB12; sfb++) {\n        ATH_psfb12[sfb] = 1E-20;\n      }\n    }\n    /*\n     * work in progress, don't rely on it too much\n     */\n\n\n    gfc.ATH.floor = 10. * Math.log10(ATHmdct(gfp, -1.));\n  }\n  /**\n   * initialization for iteration_loop\n   */\n\n\n  this.iteration_init = function (gfp) {\n    var gfc = gfp.internal_flags;\n    var l3_side = gfc.l3_side;\n    var i;\n\n    if (gfc.iteration_init_init == 0) {\n      gfc.iteration_init_init = 1;\n      l3_side.main_data_begin = 0;\n      compute_ath(gfp);\n      pow43[0] = 0.0;\n\n      for (i = 1; i < PRECALC_SIZE; i++) pow43[i] = Math.pow(i, 4.0 / 3.0);\n\n      for (i = 0; i < PRECALC_SIZE - 1; i++) adj43[i] = i + 1 - Math.pow(0.5 * (pow43[i] + pow43[i + 1]), 0.75);\n\n      adj43[i] = 0.5;\n\n      for (i = 0; i < Q_MAX; i++) ipow20[i] = Math.pow(2.0, (i - 210) * -0.1875);\n\n      for (i = 0; i <= Q_MAX + Q_MAX2; i++) pow20[i] = Math.pow(2.0, (i - 210 - Q_MAX2) * 0.25);\n\n      tak.huffman_init(gfc);\n      {\n        var bass, alto, treble, sfb21;\n        i = gfp.exp_nspsytune >> 2 & 63;\n        if (i >= 32) i -= 64;\n        bass = Math.pow(10, i / 4.0 / 10.0);\n        i = gfp.exp_nspsytune >> 8 & 63;\n        if (i >= 32) i -= 64;\n        alto = Math.pow(10, i / 4.0 / 10.0);\n        i = gfp.exp_nspsytune >> 14 & 63;\n        if (i >= 32) i -= 64;\n        treble = Math.pow(10, i / 4.0 / 10.0);\n        /*\n         * to be compatible with Naoki's original code, the next 6 bits\n         * define only the amount of changing treble for sfb21\n         */\n\n        i = gfp.exp_nspsytune >> 20 & 63;\n        if (i >= 32) i -= 64;\n        sfb21 = treble * Math.pow(10, i / 4.0 / 10.0);\n\n        for (i = 0; i < Encoder.SBMAX_l; i++) {\n          var f;\n          if (i <= 6) f = bass;else if (i <= 13) f = alto;else if (i <= 20) f = treble;else f = sfb21;\n          gfc.nsPsy.longfact[i] = f;\n        }\n\n        for (i = 0; i < Encoder.SBMAX_s; i++) {\n          var f;\n          if (i <= 5) f = bass;else if (i <= 10) f = alto;else if (i <= 11) f = treble;else f = sfb21;\n          gfc.nsPsy.shortfact[i] = f;\n        }\n      }\n    }\n  };\n  /**\n   * allocate bits among 2 channels based on PE<BR>\n   * mt 6/99<BR>\n   * bugfixes rh 8/01: often allocated more than the allowed 4095 bits\n   */\n\n\n  this.on_pe = function (gfp, pe, targ_bits, mean_bits, gr, cbr) {\n    var gfc = gfp.internal_flags;\n    var tbits = 0,\n        bits;\n    var add_bits = new_int(2);\n    var ch;\n    /* allocate targ_bits for granule */\n\n    var mb = new MeanBits(tbits);\n    var extra_bits = rv.ResvMaxBits(gfp, mean_bits, mb, cbr);\n    tbits = mb.bits;\n    /* maximum allowed bits for this granule */\n\n    var max_bits = tbits + extra_bits;\n\n    if (max_bits > LameInternalFlags.MAX_BITS_PER_GRANULE) {\n      // hard limit per granule\n      max_bits = LameInternalFlags.MAX_BITS_PER_GRANULE;\n    }\n\n    for (bits = 0, ch = 0; ch < gfc.channels_out; ++ch) {\n      /******************************************************************\n       * allocate bits for each channel\n       ******************************************************************/\n      targ_bits[ch] = Math.min(LameInternalFlags.MAX_BITS_PER_CHANNEL, tbits / gfc.channels_out);\n      add_bits[ch] = 0 | targ_bits[ch] * pe[gr][ch] / 700.0 - targ_bits[ch];\n      /* at most increase bits by 1.5*average */\n\n      if (add_bits[ch] > mean_bits * 3 / 4) add_bits[ch] = mean_bits * 3 / 4;\n      if (add_bits[ch] < 0) add_bits[ch] = 0;\n      if (add_bits[ch] + targ_bits[ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL) add_bits[ch] = Math.max(0, LameInternalFlags.MAX_BITS_PER_CHANNEL - targ_bits[ch]);\n      bits += add_bits[ch];\n    }\n\n    if (bits > extra_bits) {\n      for (ch = 0; ch < gfc.channels_out; ++ch) {\n        add_bits[ch] = extra_bits * add_bits[ch] / bits;\n      }\n    }\n\n    for (ch = 0; ch < gfc.channels_out; ++ch) {\n      targ_bits[ch] += add_bits[ch];\n      extra_bits -= add_bits[ch];\n    }\n\n    for (bits = 0, ch = 0; ch < gfc.channels_out; ++ch) {\n      bits += targ_bits[ch];\n    }\n\n    if (bits > LameInternalFlags.MAX_BITS_PER_GRANULE) {\n      var sum = 0;\n\n      for (ch = 0; ch < gfc.channels_out; ++ch) {\n        targ_bits[ch] *= LameInternalFlags.MAX_BITS_PER_GRANULE;\n        targ_bits[ch] /= bits;\n        sum += targ_bits[ch];\n      }\n\n      assert(sum <= LameInternalFlags.MAX_BITS_PER_GRANULE);\n    }\n\n    return max_bits;\n  };\n\n  this.reduce_side = function (targ_bits, ms_ener_ratio, mean_bits, max_bits) {\n    assert(max_bits <= LameInternalFlags.MAX_BITS_PER_GRANULE);\n    assert(targ_bits[0] + targ_bits[1] <= LameInternalFlags.MAX_BITS_PER_GRANULE);\n    /*\n     * ms_ener_ratio = 0: allocate 66/33 mid/side fac=.33 ms_ener_ratio =.5:\n     * allocate 50/50 mid/side fac= 0\n     */\n\n    /* 75/25 split is fac=.5 */\n\n    var fac = .33 * (.5 - ms_ener_ratio) / .5;\n    if (fac < 0) fac = 0;\n    if (fac > .5) fac = .5;\n    /* number of bits to move from side channel to mid channel */\n\n    /* move_bits = fac*targ_bits[1]; */\n\n    var move_bits = 0 | fac * .5 * (targ_bits[0] + targ_bits[1]);\n\n    if (move_bits > LameInternalFlags.MAX_BITS_PER_CHANNEL - targ_bits[0]) {\n      move_bits = LameInternalFlags.MAX_BITS_PER_CHANNEL - targ_bits[0];\n    }\n\n    if (move_bits < 0) move_bits = 0;\n\n    if (targ_bits[1] >= 125) {\n      /* dont reduce side channel below 125 bits */\n      if (targ_bits[1] - move_bits > 125) {\n        /* if mid channel already has 2x more than average, dont bother */\n\n        /* mean_bits = bits per granule (for both channels) */\n        if (targ_bits[0] < mean_bits) targ_bits[0] += move_bits;\n        targ_bits[1] -= move_bits;\n      } else {\n        targ_bits[0] += targ_bits[1] - 125;\n        targ_bits[1] = 125;\n      }\n    }\n\n    move_bits = targ_bits[0] + targ_bits[1];\n\n    if (move_bits > max_bits) {\n      targ_bits[0] = max_bits * targ_bits[0] / move_bits;\n      targ_bits[1] = max_bits * targ_bits[1] / move_bits;\n    }\n\n    assert(targ_bits[0] <= LameInternalFlags.MAX_BITS_PER_CHANNEL);\n    assert(targ_bits[1] <= LameInternalFlags.MAX_BITS_PER_CHANNEL);\n    assert(targ_bits[0] + targ_bits[1] <= LameInternalFlags.MAX_BITS_PER_GRANULE);\n  };\n  /**\n   *  Robert Hegemann 2001-04-27:\n   *  this adjusts the ATH, keeping the original noise floor\n   *  affects the higher frequencies more than the lower ones\n   */\n\n\n  this.athAdjust = function (a, x, athFloor) {\n    /*\n     * work in progress\n     */\n    var o = 90.30873362;\n    var p = 94.82444863;\n    var u = Util.FAST_LOG10_X(x, 10.0);\n    var v = a * a;\n    var w = 0.0;\n    u -= athFloor;\n    /* undo scaling */\n\n    if (v > 1E-20) w = 1. + Util.FAST_LOG10_X(v, 10.0 / o);\n    if (w < 0) w = 0.;\n    u *= w;\n    u += athFloor + o - p;\n    /* redo scaling */\n\n    return Math.pow(10., 0.1 * u);\n  };\n  /**\n   * Calculate the allowed distortion for each scalefactor band, as determined\n   * by the psychoacoustic model. xmin(sb) = ratio(sb) * en(sb) / bw(sb)\n   *\n   * returns number of sfb's with energy > ATH\n   */\n\n\n  this.calc_xmin = function (gfp, ratio, cod_info, pxmin) {\n    var pxminPos = 0;\n    var gfc = gfp.internal_flags;\n    var gsfb,\n        j = 0,\n        ath_over = 0;\n    var ATH = gfc.ATH;\n    var xr = cod_info.xr;\n    var enable_athaa_fix = gfp.VBR == VbrMode.vbr_mtrh ? 1 : 0;\n    var masking_lower = gfc.masking_lower;\n\n    if (gfp.VBR == VbrMode.vbr_mtrh || gfp.VBR == VbrMode.vbr_mt) {\n      /* was already done in PSY-Model */\n      masking_lower = 1.0;\n    }\n\n    for (gsfb = 0; gsfb < cod_info.psy_lmax; gsfb++) {\n      var en0, xmin;\n      var rh1, rh2;\n      var width, l;\n      if (gfp.VBR == VbrMode.vbr_rh || gfp.VBR == VbrMode.vbr_mtrh) xmin = athAdjust(ATH.adjust, ATH.l[gsfb], ATH.floor);else xmin = ATH.adjust * ATH.l[gsfb];\n      width = cod_info.width[gsfb];\n      rh1 = xmin / width;\n      rh2 = DBL_EPSILON;\n      l = width >> 1;\n      en0 = 0.0;\n\n      do {\n        var xa, xb;\n        xa = xr[j] * xr[j];\n        en0 += xa;\n        rh2 += xa < rh1 ? xa : rh1;\n        j++;\n        xb = xr[j] * xr[j];\n        en0 += xb;\n        rh2 += xb < rh1 ? xb : rh1;\n        j++;\n      } while (--l > 0);\n\n      if (en0 > xmin) ath_over++;\n\n      if (gsfb == Encoder.SBPSY_l) {\n        var x = xmin * gfc.nsPsy.longfact[gsfb];\n\n        if (rh2 < x) {\n          rh2 = x;\n        }\n      }\n\n      if (enable_athaa_fix != 0) {\n        xmin = rh2;\n      }\n\n      if (!gfp.ATHonly) {\n        var e = ratio.en.l[gsfb];\n\n        if (e > 0.0) {\n          var x;\n          x = en0 * ratio.thm.l[gsfb] * masking_lower / e;\n          if (enable_athaa_fix != 0) x *= gfc.nsPsy.longfact[gsfb];\n          if (xmin < x) xmin = x;\n        }\n      }\n\n      if (enable_athaa_fix != 0) pxmin[pxminPos++] = xmin;else pxmin[pxminPos++] = xmin * gfc.nsPsy.longfact[gsfb];\n    }\n    /* end of long block loop */\n\n    /* use this function to determine the highest non-zero coeff */\n\n\n    var max_nonzero = 575;\n\n    if (cod_info.block_type != Encoder.SHORT_TYPE) {\n      // NORM, START or STOP type, but not SHORT\n      var k = 576;\n\n      while (k-- != 0 && BitStream.EQ(xr[k], 0)) {\n        max_nonzero = k;\n      }\n    }\n\n    cod_info.max_nonzero_coeff = max_nonzero;\n\n    for (var sfb = cod_info.sfb_smin; gsfb < cod_info.psymax; sfb++, gsfb += 3) {\n      var width, b;\n      var tmpATH;\n      if (gfp.VBR == VbrMode.vbr_rh || gfp.VBR == VbrMode.vbr_mtrh) tmpATH = athAdjust(ATH.adjust, ATH.s[sfb], ATH.floor);else tmpATH = ATH.adjust * ATH.s[sfb];\n      width = cod_info.width[gsfb];\n\n      for (b = 0; b < 3; b++) {\n        var en0 = 0.0,\n            xmin;\n        var rh1, rh2;\n        var l = width >> 1;\n        rh1 = tmpATH / width;\n        rh2 = DBL_EPSILON;\n\n        do {\n          var xa, xb;\n          xa = xr[j] * xr[j];\n          en0 += xa;\n          rh2 += xa < rh1 ? xa : rh1;\n          j++;\n          xb = xr[j] * xr[j];\n          en0 += xb;\n          rh2 += xb < rh1 ? xb : rh1;\n          j++;\n        } while (--l > 0);\n\n        if (en0 > tmpATH) ath_over++;\n\n        if (sfb == Encoder.SBPSY_s) {\n          var x = tmpATH * gfc.nsPsy.shortfact[sfb];\n\n          if (rh2 < x) {\n            rh2 = x;\n          }\n        }\n\n        if (enable_athaa_fix != 0) xmin = rh2;else xmin = tmpATH;\n\n        if (!gfp.ATHonly && !gfp.ATHshort) {\n          var e = ratio.en.s[sfb][b];\n\n          if (e > 0.0) {\n            var x;\n            x = en0 * ratio.thm.s[sfb][b] * masking_lower / e;\n            if (enable_athaa_fix != 0) x *= gfc.nsPsy.shortfact[sfb];\n            if (xmin < x) xmin = x;\n          }\n        }\n\n        if (enable_athaa_fix != 0) pxmin[pxminPos++] = xmin;else pxmin[pxminPos++] = xmin * gfc.nsPsy.shortfact[sfb];\n      }\n      /* b */\n\n\n      if (gfp.useTemporal) {\n        if (pxmin[pxminPos - 3] > pxmin[pxminPos - 3 + 1]) pxmin[pxminPos - 3 + 1] += (pxmin[pxminPos - 3] - pxmin[pxminPos - 3 + 1]) * gfc.decay;\n        if (pxmin[pxminPos - 3 + 1] > pxmin[pxminPos - 3 + 2]) pxmin[pxminPos - 3 + 2] += (pxmin[pxminPos - 3 + 1] - pxmin[pxminPos - 3 + 2]) * gfc.decay;\n      }\n    }\n    /* end of short block sfb loop */\n\n\n    return ath_over;\n  };\n\n  function StartLine(j) {\n    this.s = j;\n  }\n\n  this.calc_noise_core = function (cod_info, startline, l, step) {\n    var noise = 0;\n    var j = startline.s;\n    var ix = cod_info.l3_enc;\n\n    if (j > cod_info.count1) {\n      while (l-- != 0) {\n        var temp;\n        temp = cod_info.xr[j];\n        j++;\n        noise += temp * temp;\n        temp = cod_info.xr[j];\n        j++;\n        noise += temp * temp;\n      }\n    } else if (j > cod_info.big_values) {\n      var ix01 = new_float(2);\n      ix01[0] = 0;\n      ix01[1] = step;\n\n      while (l-- != 0) {\n        var temp;\n        temp = Math.abs(cod_info.xr[j]) - ix01[ix[j]];\n        j++;\n        noise += temp * temp;\n        temp = Math.abs(cod_info.xr[j]) - ix01[ix[j]];\n        j++;\n        noise += temp * temp;\n      }\n    } else {\n      while (l-- != 0) {\n        var temp;\n        temp = Math.abs(cod_info.xr[j]) - pow43[ix[j]] * step;\n        j++;\n        noise += temp * temp;\n        temp = Math.abs(cod_info.xr[j]) - pow43[ix[j]] * step;\n        j++;\n        noise += temp * temp;\n      }\n    }\n\n    startline.s = j;\n    return noise;\n  };\n  /**\n   * <PRE>\n   * -oo dB  =>  -1.00\n   * - 6 dB  =>  -0.97\n   * - 3 dB  =>  -0.80\n   * - 2 dB  =>  -0.64\n   * - 1 dB  =>  -0.38\n   *   0 dB  =>   0.00\n   * + 1 dB  =>  +0.49\n   * + 2 dB  =>  +1.06\n   * + 3 dB  =>  +1.68\n   * + 6 dB  =>  +3.69\n   * +10 dB  =>  +6.45\n   * </PRE>\n   */\n\n\n  this.calc_noise = function (cod_info, l3_xmin, distort, res, prev_noise) {\n    var distortPos = 0;\n    var l3_xminPos = 0;\n    var sfb,\n        l,\n        over = 0;\n    var over_noise_db = 0;\n    /* 0 dB relative to masking */\n\n    var tot_noise_db = 0;\n    /* -200 dB relative to masking */\n\n    var max_noise = -20.0;\n    var j = 0;\n    var scalefac = cod_info.scalefac;\n    var scalefacPos = 0;\n    res.over_SSD = 0;\n\n    for (sfb = 0; sfb < cod_info.psymax; sfb++) {\n      var s = cod_info.global_gain - (scalefac[scalefacPos++] + (cod_info.preflag != 0 ? pretab[sfb] : 0) << cod_info.scalefac_scale + 1) - cod_info.subblock_gain[cod_info.window[sfb]] * 8;\n      var noise = 0.0;\n\n      if (prev_noise != null && prev_noise.step[sfb] == s) {\n        /* use previously computed values */\n        noise = prev_noise.noise[sfb];\n        j += cod_info.width[sfb];\n        distort[distortPos++] = noise / l3_xmin[l3_xminPos++];\n        noise = prev_noise.noise_log[sfb];\n      } else {\n        var step = POW20(s);\n        l = cod_info.width[sfb] >> 1;\n\n        if (j + cod_info.width[sfb] > cod_info.max_nonzero_coeff) {\n          var usefullsize;\n          usefullsize = cod_info.max_nonzero_coeff - j + 1;\n          if (usefullsize > 0) l = usefullsize >> 1;else l = 0;\n        }\n\n        var sl = new StartLine(j);\n        noise = this.calc_noise_core(cod_info, sl, l, step);\n        j = sl.s;\n\n        if (prev_noise != null) {\n          /* save noise values */\n          prev_noise.step[sfb] = s;\n          prev_noise.noise[sfb] = noise;\n        }\n\n        noise = distort[distortPos++] = noise / l3_xmin[l3_xminPos++];\n        /* multiplying here is adding in dB, but can overflow */\n\n        noise = Util.FAST_LOG10(Math.max(noise, 1E-20));\n\n        if (prev_noise != null) {\n          /* save noise values */\n          prev_noise.noise_log[sfb] = noise;\n        }\n      }\n\n      if (prev_noise != null) {\n        /* save noise values */\n        prev_noise.global_gain = cod_info.global_gain;\n      }\n\n      tot_noise_db += noise;\n\n      if (noise > 0.0) {\n        var tmp;\n        tmp = Math.max(0 | noise * 10 + .5, 1);\n        res.over_SSD += tmp * tmp;\n        over++;\n        /* multiplying here is adding in dB -but can overflow */\n\n        /* over_noise *= noise; */\n\n        over_noise_db += noise;\n      }\n\n      max_noise = Math.max(max_noise, noise);\n    }\n\n    res.over_count = over;\n    res.tot_noise = tot_noise_db;\n    res.over_noise = over_noise_db;\n    res.max_noise = max_noise;\n    return over;\n  };\n  /**\n   * updates plotting data\n   *\n   * Mark Taylor 2000-??-??\n   *\n   * Robert Hegemann: moved noise/distortion calc into it\n   */\n\n\n  this.set_pinfo = function (gfp, cod_info, ratio, gr, ch) {\n    var gfc = gfp.internal_flags;\n    var sfb, sfb2;\n    var l;\n    var en0, en1;\n    var ifqstep = cod_info.scalefac_scale == 0 ? .5 : 1.0;\n    var scalefac = cod_info.scalefac;\n    var l3_xmin = new_float(L3Side.SFBMAX);\n    var xfsf = new_float(L3Side.SFBMAX);\n    var noise = new CalcNoiseResult();\n    calc_xmin(gfp, ratio, cod_info, l3_xmin);\n    calc_noise(cod_info, l3_xmin, xfsf, noise, null);\n    var j = 0;\n    sfb2 = cod_info.sfb_lmax;\n    if (cod_info.block_type != Encoder.SHORT_TYPE && 0 == cod_info.mixed_block_flag) sfb2 = 22;\n\n    for (sfb = 0; sfb < sfb2; sfb++) {\n      var start = gfc.scalefac_band.l[sfb];\n      var end = gfc.scalefac_band.l[sfb + 1];\n      var bw = end - start;\n\n      for (en0 = 0.0; j < end; j++) en0 += cod_info.xr[j] * cod_info.xr[j];\n\n      en0 /= bw;\n      /* convert to MDCT units */\n\n      /* scaling so it shows up on FFT plot */\n\n      en1 = 1e15;\n      gfc.pinfo.en[gr][ch][sfb] = en1 * en0;\n      gfc.pinfo.xfsf[gr][ch][sfb] = en1 * l3_xmin[sfb] * xfsf[sfb] / bw;\n      if (ratio.en.l[sfb] > 0 && !gfp.ATHonly) en0 = en0 / ratio.en.l[sfb];else en0 = 0.0;\n      gfc.pinfo.thr[gr][ch][sfb] = en1 * Math.max(en0 * ratio.thm.l[sfb], gfc.ATH.l[sfb]);\n      /* there is no scalefactor bands >= SBPSY_l */\n\n      gfc.pinfo.LAMEsfb[gr][ch][sfb] = 0;\n      if (cod_info.preflag != 0 && sfb >= 11) gfc.pinfo.LAMEsfb[gr][ch][sfb] = -ifqstep * pretab[sfb];\n\n      if (sfb < Encoder.SBPSY_l) {\n        /* scfsi should be decoded by caller side */\n        assert(scalefac[sfb] >= 0);\n        gfc.pinfo.LAMEsfb[gr][ch][sfb] -= ifqstep * scalefac[sfb];\n      }\n    }\n    /* for sfb */\n\n\n    if (cod_info.block_type == Encoder.SHORT_TYPE) {\n      sfb2 = sfb;\n\n      for (sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n        var start = gfc.scalefac_band.s[sfb];\n        var end = gfc.scalefac_band.s[sfb + 1];\n        var bw = end - start;\n\n        for (var i = 0; i < 3; i++) {\n          for (en0 = 0.0, l = start; l < end; l++) {\n            en0 += cod_info.xr[j] * cod_info.xr[j];\n            j++;\n          }\n\n          en0 = Math.max(en0 / bw, 1e-20);\n          /* convert to MDCT units */\n\n          /* scaling so it shows up on FFT plot */\n\n          en1 = 1e15;\n          gfc.pinfo.en_s[gr][ch][3 * sfb + i] = en1 * en0;\n          gfc.pinfo.xfsf_s[gr][ch][3 * sfb + i] = en1 * l3_xmin[sfb2] * xfsf[sfb2] / bw;\n          if (ratio.en.s[sfb][i] > 0) en0 = en0 / ratio.en.s[sfb][i];else en0 = 0.0;\n          if (gfp.ATHonly || gfp.ATHshort) en0 = 0;\n          gfc.pinfo.thr_s[gr][ch][3 * sfb + i] = en1 * Math.max(en0 * ratio.thm.s[sfb][i], gfc.ATH.s[sfb]);\n          /* there is no scalefactor bands >= SBPSY_s */\n\n          gfc.pinfo.LAMEsfb_s[gr][ch][3 * sfb + i] = -2.0 * cod_info.subblock_gain[i];\n\n          if (sfb < Encoder.SBPSY_s) {\n            gfc.pinfo.LAMEsfb_s[gr][ch][3 * sfb + i] -= ifqstep * scalefac[sfb2];\n          }\n\n          sfb2++;\n        }\n      }\n    }\n    /* block type short */\n\n\n    gfc.pinfo.LAMEqss[gr][ch] = cod_info.global_gain;\n    gfc.pinfo.LAMEmainbits[gr][ch] = cod_info.part2_3_length + cod_info.part2_length;\n    gfc.pinfo.LAMEsfbits[gr][ch] = cod_info.part2_length;\n    gfc.pinfo.over[gr][ch] = noise.over_count;\n    gfc.pinfo.max_noise[gr][ch] = noise.max_noise * 10.0;\n    gfc.pinfo.over_noise[gr][ch] = noise.over_noise * 10.0;\n    gfc.pinfo.tot_noise[gr][ch] = noise.tot_noise * 10.0;\n    gfc.pinfo.over_SSD[gr][ch] = noise.over_SSD;\n  };\n  /**\n   * updates plotting data for a whole frame\n   *\n   * Robert Hegemann 2000-10-21\n   */\n\n\n  function set_frame_pinfo(gfp, ratio) {\n    var gfc = gfp.internal_flags;\n    gfc.masking_lower = 1.0;\n    /*\n     * for every granule and channel patch l3_enc and set info\n     */\n\n    for (var gr = 0; gr < gfc.mode_gr; gr++) {\n      for (var ch = 0; ch < gfc.channels_out; ch++) {\n        var cod_info = gfc.l3_side.tt[gr][ch];\n        var scalefac_sav = new_int(L3Side.SFBMAX);\n        System.arraycopy(cod_info.scalefac, 0, scalefac_sav, 0, scalefac_sav.length);\n        /*\n         * reconstruct the scalefactors in case SCFSI was used\n         */\n\n        if (gr == 1) {\n          var sfb;\n\n          for (sfb = 0; sfb < cod_info.sfb_lmax; sfb++) {\n            if (cod_info.scalefac[sfb] < 0)\n              /* scfsi */\n              cod_info.scalefac[sfb] = gfc.l3_side.tt[0][ch].scalefac[sfb];\n          }\n        }\n\n        set_pinfo(gfp, cod_info, ratio[gr][ch], gr, ch);\n        System.arraycopy(scalefac_sav, 0, cod_info.scalefac, 0, scalefac_sav.length);\n      }\n      /* for ch */\n\n    }\n    /* for gr */\n\n  }\n}\n\nmodule.exports = QuantizePVT;","map":null,"metadata":{},"sourceType":"script"}