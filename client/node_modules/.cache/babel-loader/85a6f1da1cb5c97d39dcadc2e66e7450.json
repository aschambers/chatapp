{"ast":null,"code":"var rtc = require('rtc-tools');\n\nvar debug = rtc.logger('rtc-quickconnect');\n\nvar cleanup = require('rtc-tools/cleanup');\n\nvar getable = require('cog/getable');\n\nmodule.exports = function (signaller, opts) {\n  var calls = getable({});\n\n  var getPeerData = require('./getpeerdata')(signaller.peers);\n\n  var heartbeats = require('./heartbeat')(signaller, opts);\n\n  var debugPrefix = '[' + signaller.id + '] ';\n\n  function create(id, pc, data, connectionOptions) {\n    var heartbeat = heartbeats.create(id);\n    var call = {\n      active: false,\n      signalling: false,\n      pc: pc,\n      channels: getable({}),\n      streams: [],\n      lastping: Date.now(),\n      heartbeat: heartbeat,\n      sdpsemantics: connectionOptions.sdpSemantics\n    };\n    calls.set(id, call); // Detect changes to the communication with this peer via\n    // the signaller\n\n    heartbeat.on('signalling:state', function (connected) {\n      call.signalling = connected;\n    }); // Indicate the call creation\n\n    debug(debugPrefix + 'call has been created for ' + id + ' (not yet started)');\n    signaller('call:created', id, pc, data); // ontrack\n\n    pc.ontrack = createTrackHandler(id);\n    return call;\n  }\n\n  function createTrackHandler(id) {\n    return function (evt) {\n      debug(debugPrefix + 'peer ' + id + ' detected track'); // updateRemoteStreams(id); \n      // receiveRemoteStream(id)(evt.stream); \n\n      var call = calls.get(id);\n\n      if (call && call.pc) {\n        call.streams = [].concat(call.pc.getRemoteStreams());\n      }\n\n      signaller('track:detected', id, evt.track, evt.streams[0], getPeerData(id));\n    };\n  }\n\n  function createStreamAddHandler(id) {\n    return function (evt) {\n      debug(debugPrefix + 'peer ' + id + ' added stream');\n      updateRemoteStreams(id);\n      receiveRemoteStream(id)(evt.stream);\n    };\n  }\n\n  function createStreamRemoveHandler(id) {\n    return function (evt) {\n      debug(debugPrefix + 'peer ' + id + ' removed stream');\n      updateRemoteStreams(id);\n      signaller('stream:removed', id, evt.stream);\n    };\n  }\n  /**\n    Failing is invoked when a call in the process of failing, usually as a result\n    of a disconnection in the PeerConnection. A connection that is failing can\n    be recovered, however, encountering this state does indicate the call is in trouble\n   **/\n\n\n  function failing(id) {\n    var call = calls.get(id); // If no call exists, do nothing\n\n    if (!call) {\n      return;\n    }\n\n    debug(debugPrefix + 'call is failing for ' + id);\n    signaller('call:failing', id, call && call.pc);\n  }\n  /**\n    Recovered is invoked when a call which was previously failing has recovered. Namely,\n    the PeerConnection has been restored by connectivity being reestablished (primary cause\n    would probably be network connection drop outs, such as WiFi)\n   **/\n\n\n  function recovered(id) {\n    var call = calls.get(id); // If no call exists, do nothing\n\n    if (!call) {\n      return;\n    }\n\n    debug(debugPrefix + 'call has recovered for ' + id);\n    signaller('call:recovered', id, call && call.pc);\n  }\n\n  function fail(id) {\n    var call = calls.get(id); // If no call exists, do nothing\n\n    if (!call) {\n      return;\n    }\n\n    debug(debugPrefix + 'call has failed for ' + id);\n    signaller('call:failed', id, call && call.pc);\n    end(id);\n  }\n  /**\n    Stops the coupling process for a call\n   **/\n\n\n  function abort(id) {\n    var call = calls.get(id); // If no call, do nothing\n\n    if (!call) return;\n    if (call.monitor) call.monitor.abort();\n    signaller('call:aborted', id, call && call.pc);\n    end(id);\n  }\n\n  function end(id) {\n    var call = calls.get(id); // if we have no data, then do nothing\n\n    if (!call) {\n      return;\n    } // Stop the heartbeat\n\n\n    if (call.heartbeat) {\n      call.heartbeat.destroy();\n    } // If a monitor is attached, remove all listeners\n\n\n    if (call.monitor) {\n      call.monitor.stop();\n    } // Close any datachannels that are still open\n\n\n    call.channels.keys().forEach(function (label) {\n      var channel = call.channels.get(label);\n      channel.close();\n    }); // trigger stream:removed events for each of the remotestreams in the pc\n\n    call.streams.forEach(function (stream) {\n      signaller('stream:removed', id, stream);\n    });\n    call.monitor.destroy();\n    call.monitor = null;\n    call.pc = null;\n    call.heartbeat = null;\n    call.active = false; // delete the call data\n\n    calls.delete(id); // trigger the call:ended event\n\n    debug(debugPrefix + 'call has ended for ' + id);\n    signaller('call:ended', id, call.pc);\n    signaller('call:' + id + ':ended', call.pc); // ensure the peer connection is properly cleaned up\n\n    cleanup(call.pc);\n  }\n\n  function ping(sender) {\n    var call = calls.get(sender && sender.id); // set the last ping for the data\n\n    if (call) {\n      call.lastping = Date.now();\n      call.heartbeat.touch();\n    }\n  }\n\n  function receiveRemoteStream(id) {\n    return function (stream) {\n      signaller('stream:added', id, stream, getPeerData(id));\n    };\n  }\n\n  function start(id, pc, data) {\n    var call = calls.get(id);\n    var streams = [].concat(pc.getRemoteStreams()); // flag the call as active\n\n    call.active = true;\n    call.streams = [].concat(pc.getRemoteStreams()); // PS: ontrack/onaddstream here is too late, the first track/addstream event already happens\n    // but will not fix for now, as process.nextTick (few lines following) is already doing the emit event (not want to cause duplicate events fire)\n    // hence, only put the ontrack at the early point (before the event happens for the first time)\n\n    debug('onaddstream (cannot first one), onremovestream here');\n    pc.onaddstream = createStreamAddHandler(id);\n    pc.onremovestream = createStreamRemoveHandler(id);\n    debug(debugPrefix + ' -> ' + id + ' call start: ' + streams.length + ' streams');\n    signaller('call:started', id, pc, data); // configure the heartbeat timer\n\n    call.lastping = Date.now(); // Monitor the heartbeat for signaller disconnection\n\n    call.heartbeat.once('disconnected', function () {\n      signaller('call:expired', id, call.pc);\n      return end(id);\n    }); // examine the existing remote streams after a short delay\n\n    process.nextTick(function () {\n      // iterate through any remote streams\n      streams.forEach(receiveRemoteStream(id));\n    });\n  }\n\n  function updateRemoteStreams(id) {\n    var call = calls.get(id);\n\n    if (call && call.pc) {\n      call.streams = [].concat(call.pc.getRemoteStreams());\n    }\n  }\n\n  calls.abort = abort;\n  calls.create = create;\n  calls.end = end;\n  calls.fail = fail;\n  calls.failing = failing;\n  calls.ping = ping;\n  calls.start = start;\n  calls.recovered = recovered;\n  return calls;\n};","map":null,"metadata":{},"sourceType":"script"}