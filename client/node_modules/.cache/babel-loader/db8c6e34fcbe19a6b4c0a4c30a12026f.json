{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nexports.default = function (_ref) {\n  var _class, _temp2;\n\n  var Component = _ref.Component,\n      createElement = _ref.createElement;\n  return _temp2 = _class = function (_Component) {\n    _inherits(ReactHint, _Component);\n\n    function ReactHint() {\n      var _temp, _this, _ret;\n\n      _classCallCheck(this, ReactHint);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {\n        target: null\n      }, _this._containerStyle = {\n        position: 'relative'\n      }, _this.toggleEvents = function (_ref2, flag) {\n        var events = _ref2.events,\n            _ref2$events = _ref2.events,\n            click = _ref2$events.click,\n            focus = _ref2$events.focus,\n            hover = _ref2$events.hover;\n        var action = flag ? 'addEventListener' : 'removeEventListener';\n        var hasEvents = events === true;\n        (click || hasEvents) && document[action]('click', _this.toggleHint);\n        (focus || hasEvents) && document[action]('focusin', _this.toggleHint);\n        (hover || hasEvents) && document[action]('mouseover', _this.toggleHint);\n        (click || hover || hasEvents) && document[action]('touchend', _this.toggleHint);\n      }, _this.toggleHint = function () {\n        var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            _ref3$target = _ref3.target,\n            target = _ref3$target === undefined ? null : _ref3$target;\n\n        target = _this.getHint(target);\n        clearTimeout(_this._timeout);\n        _this._timeout = setTimeout(function () {\n          return _this.setState(function () {\n            return {\n              target: target\n            };\n          });\n        }, target === null ? _this.props.delay.hide === undefined ? _this.props.delay : _this.props.delay.hide : _this.props.delay.show === undefined ? _this.props.delay : _this.props.delay.show);\n      }, _this.getHint = function (el) {\n        var _this$props = _this.props,\n            attribute = _this$props.attribute,\n            persist = _this$props.persist;\n        var target = _this.state.target;\n\n        while (el) {\n          if (el === document) break;\n          if (persist && el === _this._hint) return target;\n          if (el.hasAttribute(attribute)) return el;\n          el = el.parentNode;\n        }\n\n        return null;\n      }, _this.shallowEqual = function (a, b) {\n        var keys = Object.keys(a);\n        return keys.length === Object.keys(b).length && keys.reduce(function (result, key) {\n          return result && (typeof a[key] === 'function' && typeof b[key] === 'function' || a[key] === b[key]);\n        }, true);\n      }, _this.getHintData = function (_ref4, _ref5) {\n        var target = _ref4.target;\n        var attribute = _ref5.attribute,\n            autoPosition = _ref5.autoPosition,\n            position = _ref5.position;\n        var content = target.getAttribute(attribute) || '';\n        var at = target.getAttribute(attribute + '-at') || position;\n\n        var _this$_container$getB = _this._container.getBoundingClientRect(),\n            containerTop = _this$_container$getB.top,\n            containerLeft = _this$_container$getB.left;\n\n        var _this$_hint$getBoundi = _this._hint.getBoundingClientRect(),\n            hintWidth = _this$_hint$getBoundi.width,\n            hintHeight = _this$_hint$getBoundi.height;\n\n        var _target$getBoundingCl = target.getBoundingClientRect(),\n            targetTop = _target$getBoundingCl.top,\n            targetLeft = _target$getBoundingCl.left,\n            targetWidth = _target$getBoundingCl.width,\n            targetHeight = _target$getBoundingCl.height;\n\n        if (autoPosition) {\n          var isHoriz = ['left', 'right'].includes(at);\n          var _document$documentEle = document.documentElement,\n              clientHeight = _document$documentEle.clientHeight,\n              clientWidth = _document$documentEle.clientWidth;\n          var directions = {\n            left: (isHoriz ? targetLeft - hintWidth : targetLeft + (targetWidth - hintWidth >> 1)) > 0,\n            right: (isHoriz ? targetLeft + targetWidth + hintWidth : targetLeft + (targetWidth + hintWidth >> 1)) < clientWidth,\n            bottom: (isHoriz ? targetTop + (targetHeight + hintHeight >> 1) : targetTop + targetHeight + hintHeight) < clientHeight,\n            top: (isHoriz ? targetTop - (hintHeight >> 1) : targetTop - hintHeight) > 0\n          };\n\n          switch (at) {\n            case 'left':\n              if (!directions.left) at = 'right';\n              if (!directions.top) at = 'bottom';\n              if (!directions.bottom) at = 'top';\n              break;\n\n            case 'right':\n              if (!directions.right) at = 'left';\n              if (!directions.top) at = 'bottom';\n              if (!directions.bottom) at = 'top';\n              break;\n\n            case 'bottom':\n              if (!directions.bottom) at = 'top';\n              if (!directions.left) at = 'right';\n              if (!directions.right) at = 'left';\n              break;\n\n            case 'top':\n            default:\n              if (!directions.top) at = 'bottom';\n              if (!directions.left) at = 'right';\n              if (!directions.right) at = 'left';\n              break;\n          }\n        }\n\n        var top = void 0,\n            left = void 0;\n\n        switch (at) {\n          case 'left':\n            top = targetHeight - hintHeight >> 1;\n            left = -hintWidth;\n            break;\n\n          case 'right':\n            top = targetHeight - hintHeight >> 1;\n            left = targetWidth;\n            break;\n\n          case 'bottom':\n            top = targetHeight;\n            left = targetWidth - hintWidth >> 1;\n            break;\n\n          case 'top':\n          default:\n            top = -hintHeight;\n            left = targetWidth - hintWidth >> 1;\n        }\n\n        return {\n          content: content,\n          at: at,\n          top: top + targetTop - containerTop | 0,\n          left: left + targetLeft - containerLeft | 0\n        };\n      }, _temp), _possibleConstructorReturn(_this, _ret);\n    }\n\n    ReactHint.prototype.componentDidMount = function componentDidMount() {\n      this.toggleEvents(this.props, true);\n    };\n\n    ReactHint.prototype.componentWillUnmount = function componentWillUnmount() {\n      this.toggleEvents(this.props, false);\n      clearTimeout(this._timeout);\n    };\n\n    ReactHint.prototype.shouldComponentUpdate = function shouldComponentUpdate(props, state) {\n      return !this.shallowEqual(state, this.state) || !this.shallowEqual(props, this.props);\n    };\n\n    ReactHint.prototype.componentDidUpdate = function componentDidUpdate() {\n      if (this.state.target) this.setState(this.getHintData);\n    };\n\n    ReactHint.prototype.render = function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          className = _props.className,\n          onRenderContent = _props.onRenderContent;\n      var _state = this.state,\n          target = _state.target,\n          content = _state.content,\n          at = _state.at,\n          top = _state.top,\n          left = _state.left;\n      return createElement('div', {\n        ref: function ref(_ref7) {\n          return _this2._container = _ref7;\n        },\n        style: this._containerStyle\n      }, target && createElement('div', {\n        className: className + ' ' + className + '--' + at,\n        ref: function ref(_ref6) {\n          return _this2._hint = _ref6;\n        },\n        role: 'tooltip',\n        style: {\n          top: top,\n          left: left\n        }\n      }, onRenderContent ? onRenderContent(target, content) : createElement('div', {\n        className: className + '__content'\n      }, content)));\n    };\n\n    return ReactHint;\n  }(Component), _class.defaultProps = {\n    attribute: 'data-rh',\n    autoPosition: false,\n    className: 'react-hint',\n    delay: 0,\n    events: false,\n    onRenderContent: null,\n    persist: false,\n    position: 'top'\n  }, _temp2;\n};\n\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}