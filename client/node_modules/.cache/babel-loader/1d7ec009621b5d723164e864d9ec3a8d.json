{"ast":null,"code":"/* jshint node: true */\n'use strict';\n\nvar nub = require('whisk/nub');\n\nvar pluck = require('whisk/pluck');\n\nvar flatten = require('whisk/flatten');\n\nvar reLineBreak = /\\r?\\n/;\nvar reTrailingNewlines = /\\r?\\n$/; // list sdp line types that are not \"significant\"\n\nvar nonHeaderLines = ['a', 'c', 'b', 'k'];\n\nvar parsers = require('./parsers');\n/**\n  # rtc-sdp\n\n  This is a utility module for intepreting and patching sdp.\n\n  ## Usage\n\n  The `rtc-sdp` main module exposes a single function that is capable of\n  parsing lines of SDP, and providing an object allowing you to perform\n  operations on those parsed lines:\n\n  ```js\n  var sdp = require('rtc-sdp')(lines);\n  ```\n\n  The currently supported operations are listed below:\n\n**/\n\n\nmodule.exports = function (sdp) {\n  var ops = {};\n  var parsed = [];\n  var activeCollector; // initialise the lines\n\n  var lines = sdp.split(reLineBreak).filter(Boolean).map(function (line) {\n    return line.split('=');\n  });\n  var inputOrder = nub(lines.filter(function (line) {\n    return line[0] && nonHeaderLines.indexOf(line[0]) < 0;\n  }).map(pluck(0)));\n\n  var findLine = ops.findLine = function (type, index) {\n    var lineData = parsed.filter(function (line) {\n      return line[0] === type;\n    })[index || 0];\n    return lineData && lineData[1];\n  }; // push into parsed sections\n\n\n  lines.forEach(function (line) {\n    var customParser = parsers[line[0]];\n\n    if (customParser) {\n      activeCollector = customParser(parsed, line);\n    } else if (activeCollector) {\n      activeCollector = activeCollector(line);\n    } else {\n      parsed.push(line);\n    }\n  });\n  /**\n    ### `sdp.addIceCandidate(data)`\n     Modify the sdp to include candidates as denoted by the data.\n  **/\n\n  ops.addIceCandidate = function (data) {\n    var lineIndex = (data || {}).lineIndex || (data || {}).sdpMLineIndex;\n    var mLine = typeof lineIndex != 'undefined' && findLine('m', lineIndex);\n    var candidate = (data || {}).candidate; // if we have the mLine add the new candidate\n\n    if (mLine && candidate) {\n      mLine.childlines.push(candidate.replace(reTrailingNewlines, '').split('='));\n    }\n  };\n  /**\n    ### `sdp.getMediaTypes() => []`\n     Retrieve the list of media types that have been defined in the sdp via\n    `m=` lines.\n  **/\n\n\n  ops.getMediaTypes = function () {\n    function getMediaType(data) {\n      return data[1].def.split(/\\s/)[0];\n    }\n\n    return parsed.filter(function (parts) {\n      return parts[0] === 'm' && parts[1] && parts[1].def;\n    }).map(getMediaType);\n  };\n  /**\n    ### `sdp.getMediaIDs() => []`\n     Returns the list of unique media line IDs that have been defined in the sdp\n    via `a=mid:` lines.\n   **/\n\n\n  ops.getMediaIDs = function () {\n    return parsed.filter(function (parts) {\n      return parts[0] === 'm' && parts[1] && parts[1].childlines && parts[1].childlines.length > 0;\n    }).map(function (mediaLine) {\n      var lines = mediaLine[1].childlines; // Default ID to the media type\n\n      var mediaId = mediaLine[1].def.split(/\\s/)[0]; // Look for the media ID\n\n      for (var i = 0; i < lines.length; i++) {\n        var tokens = lines[i][1].split(':');\n\n        if (tokens.length > 0 && tokens[0] === 'mid') {\n          mediaId = tokens[1];\n          break;\n        }\n      }\n\n      return mediaId;\n    });\n  };\n  /**\n    ### `sdp.toString()`\n     Convert the SDP structure that is currently retained in memory, into a string\n    that can be provided to a `setLocalDescription` (or `setRemoteDescription`)\n    WebRTC call.\n   **/\n\n\n  ops.toString = function () {\n    return parsed.map(function (line) {\n      return typeof line[1].toArray == 'function' ? line[1].toArray() : [line];\n    }).reduce(flatten).map(function (line) {\n      return line.join('=');\n    }).join('\\r\\n') + '\\r\\n';\n  };\n  /**\n    ## SDP Filtering / Munging Functions\n     There are additional functions included in the module to assign with\n    performing \"single-shot\" SDP filtering (or munging) operations:\n   **/\n\n\n  return ops;\n};","map":null,"metadata":{},"sourceType":"script"}