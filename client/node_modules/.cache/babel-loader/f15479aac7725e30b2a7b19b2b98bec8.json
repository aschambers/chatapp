{"ast":null,"code":"var sources = require('./sources');\n\nvar sinks = require('./sinks');\n\nvar throughs = require('./throughs');\n\nvar u = require('pull-core');\n\nfunction isFunction(fun) {\n  return 'function' === typeof fun;\n}\n\nfunction isReader(fun) {\n  return fun && (fun.type === \"Through\" || fun.length === 1);\n}\n\nvar exports = module.exports = function pull() {\n  var args = [].slice.call(arguments);\n  if (isReader(args[0])) return function (read) {\n    args.unshift(read);\n    return pull.apply(null, args);\n  };\n  var read = args.shift(); //if the first function is a duplex stream,\n  //pipe from the source.\n\n  if (isFunction(read.source)) read = read.source;\n\n  function next() {\n    var s = args.shift();\n    if (null == s) return next();\n    if (isFunction(s)) return s;\n    return function (read) {\n      s.sink(read); //this supports pipeing through a duplex stream\n      //pull(a, b, a) \"telephone style\".\n      //if this stream is in the a (first & last position)\n      //s.source will have already been used, but this should never be called\n      //so that is okay.\n\n      return s.source;\n    };\n  }\n\n  while (args.length) read = next()(read);\n\n  return read;\n};\n\nfor (var k in sources) exports[k] = u.Source(sources[k]);\n\nfor (var k in throughs) exports[k] = u.Through(throughs[k]);\n\nfor (var k in sinks) exports[k] = u.Sink(sinks[k]);\n\nvar maybe = require('./maybe')(exports);\n\nfor (var k in maybe) exports[k] = maybe[k];\n\nexports.Duplex = exports.Through = exports.pipeable = u.Through;\nexports.Source = exports.pipeableSource = u.Source;\nexports.Sink = exports.pipeableSink = u.Sink;","map":null,"metadata":{},"sourceType":"script"}