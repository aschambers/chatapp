{"ast":null,"code":"/* jshint node: true */\n'use strict';\n\nvar mbus = require('mbus'); // define some state mappings to simplify the events we generate\n\n\nvar stateMappings = {\n  completed: 'connected'\n}; // define the events that we need to watch for peer connection\n// state changes\n\nvar peerStateEvents = ['signalingstatechange', 'iceconnectionstatechange'];\n/**\n  ### rtc-tools/monitor\n\n  ```\n  monitor(pc, targetId, signaller, parentBus) => mbus\n  ```\n\n  The monitor is a useful tool for determining the state of `pc` (an\n  `RTCPeerConnection`) instance in the context of your application. The\n  monitor uses both the `iceConnectionState` information of the peer\n  connection and also the various\n  [signaller events](https://github.com/rtc-io/rtc-signaller#signaller-events)\n  to determine when the connection has been `connected` and when it has\n  been `disconnected`.\n\n  A monitor created `mbus` is returned as the result of a\n  [couple](https://github.com/rtc-io/rtc#rtccouple) between a local peer\n  connection and it's remote counterpart.\n\n**/\n\nmodule.exports = function (pc, targetId, signaller, parentBus) {\n  var monitor = mbus('', parentBus);\n  var state;\n  var connectionState;\n  var signalingState;\n  var isClosed = false;\n\n  function checkState() {\n    var newConnectionState = pc.iceConnectionState;\n    var newState = getMappedState(newConnectionState);\n    var newSignalingState = pc.signalingState; // flag the we had a state change\n\n    monitor('statechange', pc, newState);\n    monitor('connectionstatechange', pc, newConnectionState); // if the active state has changed, then send the appopriate message\n\n    if (state !== newState) {\n      monitor(newState);\n      state = newState;\n    }\n\n    if (connectionState !== newConnectionState) {\n      monitor('connectionstate:' + newConnectionState);\n      connectionState = newConnectionState;\n    } // As Firefox does not always support `onclose`, if the state is closed\n    // and we haven't already handled the close, do so now\n\n\n    if (newState === 'closed' && !isClosed) {\n      handleClose();\n    } // Check the signalling state to see if it has also changed\n\n\n    if (signalingState !== newSignalingState) {\n      monitor('signalingchange', pc, newSignalingState, signalingState);\n      monitor('signaling:' + newSignalingState, pc, newSignalingState, signalingState);\n      signalingState = newSignalingState;\n    }\n  }\n\n  function handleClose() {\n    isClosed = true;\n    monitor('closed');\n  }\n\n  pc.onclose = handleClose;\n  peerStateEvents.forEach(function (evtName) {\n    pc['on' + evtName] = checkState;\n  });\n\n  monitor.close = function () {\n    pc.onclose = null;\n    peerStateEvents.forEach(function (evtName) {\n      pc['on' + evtName] = null;\n    });\n  };\n\n  monitor.checkState = checkState;\n\n  monitor.destroy = function () {\n    monitor.clear();\n  }; // if we haven't been provided a valid peer connection, abort\n\n\n  if (!pc) {\n    return monitor;\n  } // determine the initial is active state\n\n\n  state = getMappedState(pc.iceConnectionState);\n  return monitor;\n};\n/* internal helpers */\n\n\nfunction getMappedState(state) {\n  return stateMappings[state] || state;\n}","map":null,"metadata":{},"sourceType":"script"}